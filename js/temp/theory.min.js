export default'\n<details>\n<summary>Список вопросов</summary>\n<nav>\n<a href="#1">1. Как создать объект?</a><a href="#2">2. Что такое прототипы?</a><a href="#3">3. В чем разница между call(), apply() и bind()?</a><a href="#4">4. Что такое JSON и какие у него есть методы?</a><a href="#5">5. Что делает метод Array.slice()?</a><a href="#6">6. Что делает метод Array.splice()?</a><a href="#7">7. В чем разница между slice() и splice()?</a><a href="#8">8. Как сравниваются объекты и карты?</a><a href="#9">9. В чем разница между операторами "==" и "==="?</a><a href="#10">10. Что такое лямбда- или стрелочные функции?</a><a href="#11">11. Почему функции называют объектами первого класса?</a><a href="#12">12. Что такое функция первого порядка?</a><a href="#13">13. Что такое функция высшего порядка?</a><a href="#14">14. Что такое унарная функция?</a><a href="#15">15. Что такое каррирование (currying)?</a><a href="#16">16. Что такое чистая функция?</a><a href="#17">17. Для чего используется ключевое слово "let"?</a><a href="#18">18. В чем разница между let и var?</a><a href="#19">19. Почему в качестве ключевого слова было выбрано слово "let"?</a><a href="#20">20. Как переопределить переменную в блоке switch?</a><a href="#21">21. Что такое временная мертвая зона?</a><a href="#22">22. Что такое немедленно вызываемое функциональное выражение (Immediately Invoked Function Expression, IIFE)?</a><a href="#23">23. В чем заключаются преимущества использования модулей?</a><a href="#24">24. Что такое запоминание или мемоизация?</a><a href="#25">25. Что такое поднятие переменных (hoisting)?</a><a href="#26">26. Что такое класс?</a><a href="#27">27. Что такое замыкание?</a><a href="#28">28. Что такое модуль?</a><a href="#29">29. Что такое область видимости?</a><a href="#30">30. Что такое сервис-воркер (service worker)?</a><a href="#31">31. Как взаимодействовать с объектной моделью документа (Document Object Model, DOM) с помощью сервис-воркеров?</a><a href="#32">32. Как повторно использовать информацию при перезапуске сервис-воркера?</a><a href="#33">33. Что такое индексированная база данных (IndexedDB)?</a><a href="#34">34. Что такое веб-хранилище (Web Storage)?</a><a href="#35">35. Что такое postMessage?</a><a href="#36">36. Что такое куки (cookie)?</a><a href="#37">37. Зачем нужны куки?</a><a href="#38">38. Какими возможностями обладают куки?</a><a href="#39">39. Как удалить куки?</a><a href="#40">40. В чем разница между куки, локальным и сессионным хранилищами?</a><a href="#41">41. В чем главное отличие между локальным и сессионным хранилищами?</a><a href="#42">42. Как получить доступ к веб-хранилищу?</a><a href="#43">43. Какие методы предоставляет сессионное хранилище?</a><a href="#44">44. Какое событие возникает при работе с веб-хранилищем?</a><a href="#45">45. Для чего используется веб-хранилище?</a><a href="#46">46. Как определить поддержку веб-хранилища браузером?</a><a href="#47">47. Как определить поддержку сервис-воркеров браузером?</a><a href="#48">48. Приведите пример веб-воркера</a><a href="#49">49. Назовите ограничения веб-воркеров по работе с DOM</a><a href="#50">50. Что такое промис (promise)?</a><a href="#51">51. Зачем нужны промисы?</a><a href="#52">52. Назовите три возможных состояния промиса</a><a href="#53">53. Что такое функция обратного вызова (колбэк)?</a><a href="#54">54. Зачем нужны колбэки?</a><a href="#55">55. Что такое ад колбэков?</a><a href="#56">56. Что такое события, отправляемые сервером (server-sent events, SSE)?</a><a href="#57">57. Как получать сообщения (уведомления или события), отправленные сервером?</a><a href="#58">58. Как проверить поддержку SSE браузером?</a><a href="#59">59. Какие события возникают при работе с SSE?</a><a href="#60">60. Назовите основные правила работы с промисами</a><a href="#61">61. Что такое колбэк в колбэке?</a><a href="#62">62. Что такое цепочка промисов?</a><a href="#63">63. Что такое Promise.all()?</a><a href="#64">64. Что такое Promise.race()?</a><a href="#65">65. Что такое строгий режим?</a><a href="#66">66. Зачем нужен строгий режим?</a><a href="#67">67. Как включить строгий режим?</a><a href="#68">68. Для чего используется двойное отрицание?</a><a href="#69">69. Для чего используется оператор delete?</a><a href="#70">70. Для чего используется оператор typeof?</a><a href="#71">71. Что такое undefined?</a><a href="#72">72. Что такое null?</a><a href="#73">73. В чем разница между null и undefined?</a><a href="#74">74. Что такое eval?</a><a href="#75">75. Как получить доступ к истории браузера?</a><a href="#76">76. Какие типы данных существуют в JavaScript?</a><a href="#77">77. Что делает isNaN()?</a><a href="#78">78. В чем разница между необъявленными и неопределенными переменными?</a><a href="#79">79. Что такое глобальные переменные?</a><a href="#80">80. Какие проблемы влечет за собой создание глобальных переменных?</a><a href="#81">81. Что такое NaN?</a><a href="#82">82. Что делает isFinite()?</a><a href="#83">83. Что такое поток или рспространение событий (event flow/propagation)?</a><a href="#84">84. Что такое всплытие события?</a><a href="#85">85. Что такое погружение или захват события?</a><a href="#86">86. Как отправить форму на обработку?</a><a href="#87">87. Как получить информацию об операционной системе?</a><a href="#88">88. В чем разница между событиями DOMContentLoaded и load?</a><a href="#89">89. В чем разница между нативными, хостовыми (принадлежащими среде выполнения кода) и пользовательскими объектами?</a><a href="#90">90. Какие средства используются для откладки кода?</a><a href="#91">91. В чем заключаются преимущества и недостатки промисов по сравнению с колбэками?</a><a href="#92">92. В чем разница между атрибутом и свойством элемента?</a><a href="#93">93. Что такое политика общего происхождения (same-origin policy, SOP)?</a><a href="#94">94. Что делает void 0?</a><a href="#95">95. JavaScript - это компилируемый или интерпретируемый язык программирования?</a><a href="#96">96. Чувствителен ли JavaScript к регистру?</a><a href="#97">97. Связаны ли Java и JavaScript?</a><a href="#98">98. Что такое событие (event)?</a><a href="#99">99. Кто придумал JavaScript?</a><a href="#100">100. Для чего используется preventDefault()?</a><a href="#101">101. Для чего используется stopPropagation()?</a><a href="#102">102. Что делает инструкция return false?</a><a href="#103">103. Что такое BOM?</a><a href="#104">104. Для чего используется setTimeout()?</a><a href="#105">105. Для чего используется setInterval()?</a><a href="#106">106. Почему JavaScript называют однопоточным (single threated)?</a><a href="#107">107. Что такое делегирование событий (event delegation)?</a><a href="#108">108. Что такое ECMAScript?</a><a href="#109">109. Назовите особенности синтаксиса JSON</a><a href="#110">110. Что делает JSON.stringify()?</a><a href="#111">111. Что делает JSON.parse()?</a><a href="#112">112. Зачем нужен JSON?</a><a href="#113">113. Что такое PWA (Progressive Web Application - прогрессивное веб-приложение)?</a><a href="#114">114. Для чего используется clearTimeout()?</a><a href="#115">115. Для чего используется clearInterval()?</a><a href="#116">116. Как выполнить перенаправление?</a><a href="#117">117. Как проверить, существует ли подстрока в строке?</a><a href="#118">118. Как проверить корректность адреса электронной почты?</a><a href="#119">119. Как получить текущий URL?</a><a href="#120">120. Какие свойства имеет объект location?</a><a href="#121">121. Как получить строку запроса?</a><a href="#122">122. Как проверить, существует ли свойство в объекте?</a><a href="#123">123. Как перебрать перечисляемые свойства объекта?</a><a href="#124">124. Как проверить, что объект является пустым?</a><a href="#125">125. Что такое объект arguments?</a><a href="#126">126. Как сделать первую букву строки заглавной?</a><a href="#127">127. Как получить текущую дату?</a><a href="#128">128. Как сравнить два объекта Date?</a><a href="#129">129. Как проверить, что строка начинается с другой строки?</a><a href="#130">130. Как удалить проблемы в строке?</a><a href="#131">131. Как добавить новое свойство в объект?</a><a href="#132">132. Является ли выражение !-- специальным оператором?</a><a href="#133">133. Как присвоить переменной значение по умолчанию?</a><a href="#134">134. Как создать многострочную строку?</a><a href="#135">135. Можем ли мы добавлять свойства функциям?</a><a href="#136">136. Как узнать, сколько аргументов ожидает получить функция?</a><a href="#137">137. Что такое полифил (polyfill)?</a><a href="#138">138. Для чего используются операторы continue и break?</a><a href="#139">139. Что такое метка (label)?</a><a href="#140">140. В чем заключаются преимущества объявления переменных в начале кода?</a><a href="#141">141. В чем заключаются преимущества инициализации переменной при объявлении?</a><a href="#142">142. Назовите основные рекомендации по созданию объекта</a><a href="#143">143. Как определить массив в формате JSON?</a><a href="#144">144. Как реализовать функцию, возвращающую случайное целое число в заданном диапазоне?</a><a href="#145">145. Что такое tree shaking (встряхивание дерева)?</a><a href="#146">146. Для чего используется tree shaking (встряхивание дерева)?</a><a href="#147">147. Что такое регулярное выражение?</a><a href="#148">148. Какие методы используются в регулярных выражениях?</a><a href="#149">149. Какие флаги используются в регулярных выражениях?</a><a href="#150">150. Какие специальные символы используются в регулярных выражениях?</a><a href="#151">151. Как изменить стили HTML-элемента?</a><a href="#152">152. Что такое debugger (отладчик)?</a><a href="#153">153. Для чего используются контрольные точки debugger (отладчика)?</a><a href="#154">154. Можно ли использовать зарезервированные слова в качестве идентификаторов?</a><a href="#155">155. Как определить ширину и высоту изображения?</a><a href="#156">156. Как отправить синхронный HTTP-запрос?</a><a href="#157">157. Как сделать асинхронный HTTP-запрос?</a><a href="#158">158. Как получить дату в нужном формате?</a><a href="#159">159. Как получить максимальные размеры страницы?</a><a href="#160">160. Что такое условный или тернарный оператор?</a><a href="#161">161. Можно ли использовать цепочку из тернарных операторов?</a><a href="#162">162. Как начать выполнение кода после полной загрузки страницы?</a><a href="#163">163. В чем разница между __proto__ и prototype?</a><a href="#164">164. Приведите пример обязательного использования точки с запятой</a><a href="#165">165. Для чего используется метод freeze()?</a><a href="#166">166. Зачем нужен метод freeze()?</a><a href="#167">167. Как сделать первую букву каждого слова в строке заглавной?</a><a href="#168">168. Как узнать, что на странице отключен JavaScript?</a><a href="#169">169. Какие операторы поддерживаются JavaScript?</a><a href="#170">170. Для чего используется оператор rest ... (прочие параметры)?</a><a href="#171">171. Для чего используется оператор spread ... (оператор распространения)?</a><a href="#172">172. Как определить, заморожен ли объект?</a><a href="#173">173. Как определить равенство значений, используя объект?</a><a href="#174">174. Как создать копию объекта?</a><a href="#175">175. Что такое прокси?</a><a href="#176">176. Для чего используется метод seal()?</a><a href="#177">177. В чем разница между методами freeze() и seal()?</a><a href="#178">178. Как получить перечисляемые пары ключ/значение объекта?</a><a href="#179">179. В чем главное отличие методов Object.keys(), Object.values() и Object.entries()?</a><a href="#180">180. Как создать объект с определенным прототипом, не используя функцию-конструктор и классы?</a><a href="#181">181. Для чего используется WeakSet?</a><a href="#182">182. В чем разница между Set и WeakSet?</a><a href="#183">183. Какие методы доступны в WeakSet?</a><a href="#184">184. Для чего используется WeakMap?</a><a href="#185">185. В чем разница между Map и WeakMap?</a><a href="#186">186. Какие методы доступны в WeakMap?</a><a href="#187">187. Как закодировать URL?</a><a href="#188">188. Как раскодировать URL?</a><a href="#189">189. Как вывести содержимое страницы на печать?</a><a href="#190">190. Что такое анонимная функция?</a><a href="#191">191. Каков приоритет использования локальных и глобальных переменных?</a><a href="#192">192. Что такое аксессоры?</a><a href="#193">193. Как определить свойство в конструкторе объекта?</a><a href="#194">194. В чем заключаются особенности геттеров и сеттеров?</a><a href="#195">195. Можно ли добавить к объекту геттеры и сеттеры с помощью метода Object.defineProperty()?</a><a href="#196">196. Для чего используется switch...case?</a><a href="#197">197. Назовите правила использования switch...case</a><a href="#198">198. Назовите примитивные типы данных.</a>\n</nav>\n</details>\n<a href="#article">Дополнительная литература</a>\n\x3c!-- 1 --\x3e\n<section id="1">\n<h3>1. Как создать объект?</h3>\n<p>Существует несколько способов это сделать. Вот некоторые из них:</p>\n<p>Литерал объекта:</p>\n<pre><code class="lang-js">\nconst object = {}\n</code></pre>\n<p>Конструктор объекта (использовать не рекомендуется):</p>\n<pre><code class="lang-js">\nconst object = new Object()\n</code></pre>\n<p>Метод Object.create()</p>\n<p>При использовании данного метода ему в качестве аргумента передается объект, который станет прототипом нового объекта.</p>\n<pre><code class="lang-js">\n// создаем объект без прототипа - пустой объект\nconst object = Object.create(null)\n</code></pre>\n<p>Функция-конструктор</p>\n<p>Создаем функцию-конструктор и применяем оператор "new" для создания экземпляра этой функции - объекта:\n</p>\n<pre><code class="lang-js">\nfunction Person (name) {\n    const object = {}\n    object.name = name\n    object.age = 30\n    return object\n}\nconst user = new Person(\'Ванька\')\n</code></pre>\n<p>Класс:</p>\n<pre><code class="lang-js">\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n}\n\nconst user = new Person(\'Ванька\')\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 2 --\x3e\n<section id="2">\n<h3>2. Что такое прототипы?</h3>\n<p>Прототипы используется для создания новых объектов на основе существующих. Такая техника называется прототипным наследованием. Прототип экземпляра объекта доступен через Object.getPrototypeOf(object) или свойство __proto__ (внутреннее скрытое свойство [[Prototype]]).</p>\n<img src="img/1.png" alt="1">\n<nav>\n<a href="https://learn.javascript.ru/prototype-inheritance" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Learn/JavaScript/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B/Object_prototypes" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 3 --\x3e\n<section id="3">\n<h3>3. В чем разница между call(), apply() и bind()?</h3>\n<p>Разницу между данными методами проще всего объяснить с помощью примеров.</p>\n<p>Метод call() вызывает функцию с указанным значением this и аргументами через запятую.</p>\n<pre><code class="lang-js">\nconst employee1 = { firstName: \'Иван\', lastName: \'Иванов\' }\nconst employee2 = { firstName: \'Петр\', lastName: \'Петров\' }\n\nfunction invite (greet1, greet2) {\n    console.log(`&#36;{greet1}, &#36;{this.firstName} &#36;{this.lastName}. &#36;{greet2}`)\n}\n\ninvite.call(employee1, \'Привет\', \'Как дела?\') // Привет, Иван Иванов. Как дела?\ninvite.call(employee2, \'Привет\', \'Как дела?\') // Привет, Петр Петров. Как дела?\n</code></pre>\n<p>Метод apply() вызывает функцию с указанным значением this и аргументами в виде массива.</p>\n<pre><code class="lang-js">\nconst employee1 = { firstName: \'Иван\', lastName: \'Иванов\' }\nconst employee2 = { firstName: \'Петр\', lastName: \'Петров\' }\n\nfunction invite (greet1, greet2) {\n    console.log(`&#36;{greet1}, &#36;{this.firstName} &#36;{this.lastName}. &#36;{greet2}`)\n}\n\ninvite.apply(employee1, [\'Привет\', \'Как дела?\']) // Привет, Иван Иванов. Как дела?\ninvite.apply(employee2, [\'Привет\', \'Как дела?\']) // Привет, Петр Петров. Как дела?\n</code></pre>\n<p>Метод bind() возвращает новую функцию с указанным значением this и позволяет передать ей массив или любое количество аргументов через запятую.</p>\n<pre><code class="lang-js">\nconst employee1 = { firstName: \'Иван\', lastName: \'Иванов\' }\nconst employee2 = { firstName: \'Петр\', lastName: \'Петров\' }\n\nfunction invite (greet1, greet2) {\n    console.log(`&#36;{greet1}, &#36;{this.firstName} &#36;{this.lastName}. &#36;{greet2}`)\n}\n\nconst inviteEmployee1 = invite.bind(employee1)\nconst inviteEmployee2 = invite.bind(employee2)\ninviteEmployee1(\'Привет\', \'Как дела?\') // Привет, Иван Иванов. Как дела?\ninviteEmployee2(\'Привет\', \'Как дела?\') // Привет, Петр Петров. Как дела?\n</code></pre>\n<p>Таким образом, методы call() и apply() вызывают функцию после ее привязки к объекту. Разница между ними состоит в способе передачи аргументов. Эту разницу легко запомнить при помощи первых букв методов: call - это запятая (comma, c), apply - массив (array, a). Метод bind() возвращает новую функцию, привязанную к указаному объекту.</p>\n<nav>\n<a href="https://learn.javascript.ru/call-apply-decorators" target="_blank">JSR - Call/Apply</a>\n<a href="https://learn.javascript.ru/bind" target="_blank">JSR - Bind</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank">MDN - Call</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank">MDN - Apply</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank">MDN - Bind</a>\n</nav>\n</section>\n\n\x3c!-- 4 --\x3e\n<section id="4">\n<h3>4. Что такое JSON и какие у него есть методы?</h3>\n<p>JSON - это текстовый формат данных, основанный на синтаксисе объектов JavaScript, изобретенный Дугласом Крокфордом. Он используется для передачи данных по сети и, обычно, имеет расширение .json и MIME-тип application/json.</p>\n<p>Разбор (парсинг): преобразует строку в формате JSON в объект.</p>\n<pre><code class="lang-js">\nJSON.parse(text)\n</code></pre>\n<p>Стрингификация: преобразует объект в строку в формате JSON для передачи по сети.</p>\n<pre><code class="lang-js">\nJSON.stringify(object)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/json" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 5 --\x3e\n<section id="5">\n<h3>5. Что делает метод Array.slice()?</h3>\n<p>Метод slice() возвращает выбранные элементы массива в виде нового массива. Он возвращает элементы, начиная с индекса, указанного в первом аргументе, и заканчивая, но не включая, индексом, указанном во втором необязательном аргументе. Если второй аргумент отсутствует, то будут извлечены все элементы, начиная с индекса, указанного в первом аргументе.</p>\n<pre><code class="lang-js">\nconst arrayIntegers = [1, 2, 3, 4, 5]\nconst arrayIntegers1 = arrayIntegers.slice(0, 2) // [1, 2]\nconst arrayIntegers2 = arrayIntegers.slice(2, 3) // [3]\nconst arrayIntegers3 = arrayIntegers.slice(4) // [5]\n</code></pre>\n<p>Обратите внимание, что данный метод не изменяет исходный массив, а лишь возвращает его подмножество в виде нового массива.</p>\n<nav>\n<a href="https://learn.javascript.ru/array-methods" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 6 --\x3e\n<section id="6">\n<h3>6. Что делает метод Array.splice()?</h3>\n<p>Метод splice() используется для добавления или удаления элементов в или из массива. Первый аргумент определяет начальную позицию для добавления или удаления элементов, второй опциональный аргумент - количество удаляемых элементов. Каждый последующий аргумент (третий и т.д.) добавляется в массив:</p>\n<pre><code class="lang-js">\nlet arrayOriginal1 = [1, 2, 3, 4, 5]\nlet arrayOriginal2 = [1, 2, 3, 4, 5]\nlet arrayOriginal3 = [1, 2, 3, 4, 5]\n\nlet array1 = arrayOriginal1.splice(0, 2) // возвращается [1, 2]; исходный массив = [3, 4, 5]\nlet array2 = arrayOriginal2.slice(3) // возвращается [4, 5]; исходный массив = [1, 2, 3]\nlet array3 = arrayOriginal3.slice(3, 1, \'a\', \'b\', \'c\') // возвращается [4]; исходный массив = [1, 2, 3, \'a\', \'b\', \'c\']\n</code></pre>\n<p>Обратите внимание, что метод splice() модифицирует исходный массив и возвращает массив извлеченных элементов.</p>\n<nav>\n<a href="https://learn.javascript.ru/array-methods" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 7 --\x3e\n<section id="7">\n<h3>7. В чем разница между slice() и splice()?</h3>\n<p>Основные отличия состоят в следующем:</p>\n<table>\n<tbody><tr>\n<th>Slice</th>\n<th>Splice</th>\n</tr>\n<tr>\n<td>Не изменяет исходный массив</td>\n<td>Изменяет исходный массив</td>\n</tr>\n<tr>\n<td>Возвращает подмассив исходного массива</td>\n<td>Возвращает удаленные элементы в виде массива</td>\n</tr>\n<tr>\n<td>Служит для извлечения элементов из массива</td>\n<td>Служит для добавления/удаления элементов в/из массива</td>\n</tr>\n</tbody></table>\n<nav>\n<a href="https://learn.javascript.ru/array-methods" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">MDN - Slice</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">MDN - Splice</a>\n</nav>\n</section>\n\n\x3c!-- 8 --\x3e\n<section id="8">\n<h3>8. Как сравниваются объекты и карты?</h3>\n<p>Объекты похожи на карты в том, что они оба позволяют устанавливать ключи для значений, извлекать значения, удалять ключи и определять наличие значения по ключу. По этой причине объекты раньше использовались как карты. Однако, между ними существуют некоторые отличия, которые делают использование карт более предпочтительным в определенных случаях.</p>\n<ul>\n<li>Ключами объекта могут быть только строки и символы, а ключами карты - любые значения, включая функции и объекты</li>\n<li>Ключи карты упорядочены, а ключи объекта нет. Поэтому при итерации ключи карты возвращаются в порядке их добавления</li>\n<li>Вы можете получить размер карты с помощью свойства size, а количество свойств объекта определяется вручную</li>\n<li>Карта является итерируемой сущностью, а для итерации по объекту необходимо сначала каким-то образом получить его ключи, а затем их перебрать</li>\n<li>При использовании объекта в качестве карты следует помнить о том, что любой объект имеет прототип, поэтому собственные ключи такой карты могут пересекаться с пользовательскими ключами. Поэтому для создания карты-объекта следует использовать Object.create(null), но сейчас такой способ используется редко</li>\n<li>Объект уступает карте в плане производительности, когда речь идет о быстром добавлении/удалении ключей</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/map-set" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 9 --\x3e\n<section id="9">\n<h3>9. В чем разница между операторами "==" и "==="?</h3>\n<p>JavaScript предоставляет два способа для сравнения значений: строгое (===, !==) и абстрактное (==, !==). При строгом сравнении значения сравниваются как есть, а при нестрогом, при необходимости, осуществляется неявное преобразование (приведение) типов значений. Строгие операторы используют следующие правила для сравнения различных типов значений:</p>\n<ul>\n<li>Две строки являются строго равными, когда они имеют одинаковый набор символов, одинаковую длину и одинаковые символы на одних и тех же позициях</li>\n<li>\nДва числа являются строго равными, если равны их значения. Существует два особых случая:\n<ul>\n<li>NaN не равно ничему, включая NaN</li>\n<li>Положительный и отрицательный нули равны друг другу</li>\n</ul>\n</li>\n<li>Логические значение являются строго равными, когда оба являются истинными или ложными, т.е. true или false</li>\n<li>Два объекта являются строго равными, если ссылаются на один и тот же объект (место в памяти)</li>\n<li>null === undefined возвращает false, а null == undefined - true</li>\n</ul>\n<p>Несколько примеров:</p>\n<pre><code class="lang-js">\n0 == false // true\n0 === false // false\n1 == "1" // true\n1 === "1" // false\nnull == undefined // true\nnull === undefined // false\n\'0\' == false // true\n\'0\' === false // false\n[] == [] // или\n[] === [] // false, ссылаются на разные места в памяти\n{} == {} // или\n{} === {} // false, ссылаются на разные места в памяти\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/comparison" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 10 --\x3e\n<section id="10">\n<h3>10. Что такое лямбда- или стрелочные функции?</h3>\n<p>Стрелочные функции - это сокращенный способ записи функциональных выражений. Они не имеют собственных this, arguments, super и new.target. Эти функции служат хорошей альтернативой функциям, не имеющим методов, но не могут использоваться как конструкторы.</p>\n<pre><code class="lang-js">\nfunction regularSum (x, y) {\n    return x + y\n}\n\nconst arrowSum = (x, y) =&gt; x + y\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/arrow-functions-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 11 --\x3e\n<section id="11">\n<h3>11. Почему функции называют объектами первого класса?</h3>\n<p>В JavaScript функции являются объектами первого класса. Это означает, что функции могут использоваться как обычные переменные.</p>\n<p>Например, функция может передаваться в качестве аргумента другой функции, возвращаться как значение из другой функции и присваиваться переменной. В следующем примере функция присваиваивается обработчику:</p>\n<pre><code class="lang-js">\nconst handler = () =&gt; console.log(\'Я - функция обработки клика\')\ndocument.addEventListener(\'click\', handler)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/function-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/First-class_Function" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 12 --\x3e\n<section id="12">\n<h3>12. Что такое функция первого порядка?</h3>\n<p>Функция первого порядка - это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значение:</p>\n<pre><code class="lang-js">\nconst firstOrder = () =&gt; console.log(\'Я - функция первого порядка\')\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/function-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 13 --\x3e\n<section id="13">\n<h3>13. Что такое функция высшего порядка?</h3>\n<p>Функция высшего порядка - это функция, которая принимает другую функцию в качестве аргумента или возращает другую функцию как значение:</p>\n<pre><code class="lang-js">\nconst firstOrderFun = () =&gt; console.log(\'Я - функция высшего порядка\')\nconst higherOrder = returnFirstOrderFun =&gt; returnFirstOrderFun()\nhigherOrder(firstOrderFunc)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/function-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 14 --\x3e\n<section id="14">\n<h3>14. Что такое унарная функция?</h3>\n<p>Унарная функция (функция-монада) - это функция, принимающая только один аргумент:</p>\n<pre><code class="lang-js">\nconst unaryFun = a =&gt; console.log(a + 10) // прибавляем 10 к переданному аргументу и выводим результат в консоль\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/function-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 15 --\x3e\n<section id="15">\n<h3>15. Что такое каррирование (currying)?</h3>\n<p>Каррирование - это процесс преобразования функции с несколькими параметрами в несколько функций с одним параметром. Данный процесс назван в четь математика Хаскелла Карри. Каррирование превращает одну n-арную функцию в несколько унарных функций (уменьшает арность функции):</p>\n<pre><code class="lang-js">\nconst sum = (a, b, c) =&gt; a + b + c\nconst currySum = a =&gt; b =&gt; c =&gt; a + b + c\n\ncurrySum(1) // возвращает функцию: b =&gt; c =&gt; 1 + b + c\ncurrySum(1)(2) // возвращает функцию: c =&gt; 3 + c\ncurrySum(1)(2)(3) // возвращает число 6\n</code></pre>\n<p>Каррирование применяется в целях обеспечения возможности повторного использования кода (частичное применение функции) и создания композиции из функций.</p>\n<nav>\n<a href="https://learn.javascript.ru/currying-partials" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 16 --\x3e\n<section id="16">\n<h3>16. Что такое чистая функция?</h3>\n<p>Чистая функция - это функция, возвращаемое значение которой зависит только от передаваемых аргументов, без побочных эффектов. Проще говоря, если вы вызывается функцию n раз с n аргументами, и функция всегда возвращает одно и тоже значение, значит, она является чистой:</p>\n<pre><code class="lang-js">\n// не чистая\nlet numberArray = []\nconst impureAddNumber = number =&gt; numberArray.push(number)\n// чистая\nconst pureAddNumber = number =&gt; argNumberArray =&gt; argNumberArray.concat([number])\n\nconsole.log(impureAddNumber(1)) // 1\nconsole.log(numberArray) // [1]\nconsole.log(pureAddNumber(2)(numberArray)) // [1, 2]\nconsole.log(numberArray) // [1]\n</code></pre>\n<p>В приведенном примере impureAddNumber не является чистой функцией, поскольку метод push() возвращает новую длину массива, которая не зависит от передаваемого аргумента. Вторая функция является чистой, поскольку метод concat() объединяет два массива без побочных эффектов и возвращает новый массив. Чистые функции важны для юнит-тестирования и не нуждаются во внедрении зависимостей. Отсутствие побочных эффектов повышает надежность приложения за счет более слабых связей между его элементами. Одним из воплощений данного принципа является концепция неизменности (иммутабельности), представленная в ES6, и заключающаяся в предпочтении const перед let.</p>\n<nav>\n<a href="https://learn.javascript.ru/function-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 17 --\x3e\n<section id="17">\n<h3>17. Для чего используется ключевое слово "let"?</h3>\n<p>Ключевое слово "let" служит для объявления локальной переменной, имеющей блочную область видимости. Область видимости такой переменной органичена блоком, оператором или выражением, в котором она используется. Переменные, объявленные с помощью ключевого слова "var", имеют глобальную область видимости или область видимости функции, в которой они определены:</p>\n<pre><code class="lang-js">\nlet counter = 1\nif (counter === 1) {\n    let counter = 2\n    console.log(counter) // 2\n}\nconsole.log(counter) // 1 (переменная counter, объявленная в блоке, здесь не существует)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/variables" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 18 --\x3e\n<section id="18">\n<h3>18. В чем разница между let и var?</h3>\n<p>Основные отличия состоят в следующем:</p>\n<table>\n<tbody><tr>\n<th>var</th>\n<th>let</th>\n</tr>\n<tr>\n<td>Доступно с момента появления JavaScript</td>\n<td>Представлено в ES6</td>\n</tr>\n<tr>\n<td>Имеет глобальную или функциональную область видимости</td>\n<td>Имеет блочную область видимости</td>\n</tr>\n<tr>\n<td>Переменные поднимаются в начало области видимости</td>\n<td>Переменные также поднимаются, но не инициализируются (поднимается только объявление, но не присвоение значения)</td>\n</tr>\n</tbody></table>\n<p>Несколько примеров:</p>\n<pre><code class="lang-js">\nfunction userDetails(username) {\n    if (username) {\n        console.log(salary)\n        console.log(age)\n        let age = 30\n        var salary = 10000\n    }\n    console.log(salary) // 10000 (область видимости функции)\n    console.log(age) // SyntaxError: "age" is not defined (блочная область видимости)\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/variables" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let" target="_blank">MDN - let</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var" target="_blank">MDN - var</a>\n</nav>\n</section>\n\n\x3c!-- 19 --\x3e\n<section id="19">\n<h3>19. Почему в качестве ключевого слова было выбрано слово "let"?</h3>\n<p>Let (пусть) - это математический оператор, который использовался ранними языками программирования, такими как Scheme и Basic. В настоящее время let используется большим количеством языков программирования, так что данное слово является наиболее близкой альтернативой сокращению "var" (variable - переменная).</p>\n<nav>\n<a href="https://learn.javascript.ru/variables" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 20 --\x3e\n<section id="20">\n<h3>20. Как переопределить переменную в блоке switch?</h3>\n<p>Если вы попытаетесь переопределить переменную, объявленную с помощью ключевого слова "let" в блоке switch, то получите ошибку:</p>\n<pre><code class="lang-js">\nlet counter = 1\nswitch(x) {\n    case 0:\n        let name\n        break\n    case 1:\n        let name // SyntaxError\n        break\n}\n</code></pre>\n<p>Для решения данной задачи необходимо создать новый блок внутри case - новую лексическую область видимости:</p>\n<pre><code class="lang-js">\nlet counter = 1\nswitch(x) {\n    case 0: {\n        let name\n        break\n    }\n    case 1: {\n        let name\n        break\n    }\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/switch" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 21 --\x3e\n<section id="21">\n<h3>21. Что такое временная мертвая зона?</h3>\n<p>При попытке доступа к переменным, объявленным с помощью ключевого слова "let" или "const" (но не "var"), до их определения (т.е. до присваивания им значения внутри текущей области видимости) будет выброшено исключение ReferenceError (ошибка ссылки). Другими словами, временной мертвой зоной называется время между созданием контекста (области видимости) переменной и ее определением:</p>\n<pre><code class="lang-js">\nfunction someMethod () {\n    console.log(counter1) // undefined\n    console.log(counter2) // ReferenceError\n    var counter1 = 1\n    const counter2 = 2\n}\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 22 --\x3e\n<section id="22">\n<h3>22. Что такое немедленно вызываемое функциональное выражение (Immediately Invoked Function Expression, IIFE)?</h3>\n<p>IIFE - это функция, которая вызывается сразу после определения. Синтаксис такой функции может выглядеть так (один из вариантов, наиболее распространенный):</p>\n<pre><code class="lang-js">\n(function () {\n    // код\n})()\n\n// или, если речь идет о стрелочной функции\n(() =&gt; {\n    // код\n})()\n</code></pre>\n<p>Главная причина использования IIFE заключается в обеспечении приватности переменных, поскольку доступ к переменным, объявленным внутри IIFE, нельзя получить из внешнего окружения:</p>\n<pre><code class="lang-js">\n(function () {\n    var message = \'IIFE\'\n    console.log(message)\n})()\nconsole.log(message) // SyntaxError: "message" is not defined\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/closure#bloki-koda-i-tsikly-iife" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/IIFE" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 23 --\x3e\n<section id="23">\n<h3>23. В чем заключаются преимущества использования модулей?</h3>\n<p>Среди прочего, можно назвать следующее:</p>\n<ul>\n<li>Повышение читаемости и облегчение поддержки кода</li>\n<li>Возможность повторного использования кода</li>\n<li>Сохранение чистоты глобального пространства имен</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/modules-intro" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 24 --\x3e\n<section id="24">\n<h3>24. Что такое запоминание или мемоизация?</h3>\n<p>Мемоизация - это способ повышения производительности функции за счет сохранения в кэше ранее полученных результатов выполнения этой функции. При каждом вызове функции переданный ей аргумент становится индексом кэша. Если данные имеются в кэше, они возвращаются без повторного выполнения функции. В противном случае, функция выполняется, а результат записывается в кэш:</p>\n<pre><code class="lang-js">\nconst memoAdd = () =&gt; {\n    let cache = {}\n    return value =&gt; {\n        if (value in cache) {\n            console.log(\'Получение данных из кэша\')\n            return cache[value] // в данном случае, cache.value не может быть использовано в качестве названия свойства, поскольку названия свойств в JavaScript не могут начинаться с числа. Поэтому используется скобочная нотация\n        } else {\n            console.log(\'Результат вычисляется\')\n            let result = value + 20\n            cache[value] = result\n            return result\n        }\n    }\n}\n// возвращаем функцию из memoAdd\nconst add = memoAdd()\nconsole.log(add(20)) // Результат вычисляется 40\nconsole.log(add(20)) // Получения данных из кэша 40\n</code></pre>\n\n</section>\n\n\x3c!-- 25 --\x3e\n<section id="25">\n<h3>25. Что такое поднятие переменных (hoisting)?</h3>\n<p>Поднятие - это процесс перемещения переменных и функциональных выражений в начало их области видимости перед выполнением кода. Запомните: поднимаются только сами переменные и выражения, а не их инициализация (т.е. поднимается объявление переменной, а не присваивание ей значения):</p>\n<pre><code class="lang-js">\nconsole.log(message) // undefined\nvar message = \'Привет!\'\n</code></pre>\n<p>Для интерпретатора данный код выглядит так:</p>\n<pre><code class="lang-js">\nvar message\nconsole.log(message)\nmessage = \'Привет!\'\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/var" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 26 --\x3e\n<section id="26">\n<h3>26. Что такое класс?</h3>\n<p>Классы, представленные в ES6, являются синтаксическим сахаром (оберткой, абстракцией или надстройкой) для протипного наследования (для прототипа функции-конструктора). Пример функции-конструктора:</p>\n<pre><code class="lang-js">\nfunction Bike(model, color) {\n    this.model = model\n    this.color = color\n}\n\nBike.prototype.getDetails = function () {\n    return \'Эта \' + this.model + \' велосипеда имеет \' + this.color + \' цвет.\'\n}\n</code></pre>\n<p>Тот же пример с использованием класса:</p>\n<pre><code class="lang-js">\nclass Bike {\n    constructor (color, model) {\n        this.color = color\n        this.model = model\n    }\n\n    getDetails () {\n        return `Эта &#36;{this.model} велосипеда имеет &#36;{this.color} цвет.`\n    }\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/class" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 27 --\x3e\n<section id="27">\n<h3>27. Что такое замыкание?</h3>\n<p>Замыкание - это комбинация функции и ее лексического окружения. Проще говоря, замыкание - это когда внутренняя функция имеет доступ к переменным, объявленным во внешней функции. Замыкание имеет цепочку из трех областей видимости:</p>\n<ul>\n<li>Собственная область видимости</li>\n<li>Область видимости внешней функции</li>\n<li>Глобальная область видимости</li>\n</ul>\n<pre><code class="lang-js">\nconst welcome = name =&gt; {\n    const greet = message =&gt; {\n        console.log(`&#36;{message}, &#36;{name}!`)\n    }\n    return greet\n}\n\nconst fun = welcome(\'Ванька\')\nfun(\'Привет\') // Привет, Ванька!\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/closure" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 28 --\x3e\n<section id="28">\n<h3>28. Что такое модуль?</h3>\n<p>Модули - это небольшие части независимого переиспользуемого кода, лежащие в основе многих шаблонов проектирования. Большинство модулей экспортируется в качестве объектов, функций или конструкторов.</p>\n<nav>\n<a href="https://learn.javascript.ru/modules-intro" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 30 --\x3e\n<section id="29">\n<h3>29. Что такое область видимости?</h3>\n<p>Область видимости определяет доступность переменных, функций и объектов в разных местах кода во время его выполнения. Другими словами, область видимости - это видимость переменных и других ресурсов в текущем контексте выполнения кода.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Glossary/Scope" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 31 --\x3e\n<section id="30">\n<h3>30. Что такое сервис-воркер (service worker)?</h3>\n<p>Сервис-воркер - это скрипт, который выполняется независимо от веб-страницы, на которой он запущен, и действий пользователя. Фактически сервис-воркер выполняет роль прокси-сервера между приложением и браузером. Основными возможностями сервис-воркеров является следующее: обеспечение работы приложения в режиме оффлайн, периодическая фоновая синхронизация, пуш-уведомления, перехват и обработка сетевых запросов и программное управление кэшем.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 32 --\x3e\n<section id="31">\n<h3>31. Как взаимодействовать с объектной моделью документа (Document Object Model, DOM) с помощью сервис-воркеров?</h3>\n<p>Сервис-воркеры не имеют прямого доступа к DOM. Однако, они могут взаимодействовать со страницей через интерфейс postMessage, а страница - может изменять DOM.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker" target="_blank">MDN - ServiceWorker</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Client/postMessage" target="_blank">MDN - postMessage</a>\n</nav>\n</section>\n\n\x3c!-- 33 --\x3e\n<section id="32">\n<h3>32. Как повторно использовать информацию при перезапуске сервис-воркера?</h3>\n<p>Одной из проблем сервис-воркеров является то, что их выполнение прекращается, когда они не используются, и повторно запускается при необходимости. Это не позволяет добавлять обработчики событий fetch и message глобально. Для повторного использования информации необходимо обеспечить взаимодействие сервис-воркеров с индексированной базой данных (IndexedDB) или локальным хранилищем (local storage).</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 34 --\x3e\n<section id="33">\n<h3>33. Что такое индексированная база данных (IndexedDB)?</h3>\n<p>IndexedDB - это низкоуровневый прикладной интерфейс для хранения большого объема структурированных данных, включая файлы и blobs, на стороне клиента. Данный интерфейс использует индексы для повышения скорости поиска данных.</p>\n<nav>\n<a href="https://learn.javascript.ru/indexeddb" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 35 --\x3e\n<section id="34">\n<h3>34. Что такое веб-хранилище (Web Storage)?</h3>\n<p>Веб-хранилище - это интерфейс, позволяющий хранить данные в виде пар ключ/значение локально, т.е. в браузере пользователя, более удобным способом, чем при использовании куки. Веб-хранилище предоставляет два механизма хранения данных:</p>\n<ul>\n<li>Локальное хранилище (local stotage) - хранит данные текущего пользователя неограниченное количество времени</li>\n<li>Сессионное хранилище (session storage) - хранит данные на протяжении текущей сессии, т.е. при закрытии вкладки браузера данные будут потеряны</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 36 --\x3e\n<section id="35">\n<h3>35. Что такое postMessage?</h3>\n<p>postMessage - это способ коммуникации разных источников объекта window (например, страницы и генерируемого ею поп-апа (всплывающего окна) или страницы и встроенного в нее фрейма (iframe)). Обычно, скрипты одной страницы не имеют доступа к другой странице, если данная страница следует Политике общего происхождения или одного источника (источник - протокол, хост и порт).</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Client/postMessage" target="_blank">MDN - postMessage</a>\n</nav>\n</section>\n\n\x3c!-- 37 --\x3e\n<section id="36">\n<h3>36. Что такое куки (cookie)?</h3>\n<p>Куки - это небольшой фрагмент данных, который сохраняется на компьютере пользователя для последующего использования браузером. Куки сохраняются в виде пар ключ/значение:</p>\n<pre><code class="lang-js">\ndocument.cookie = \'username=Ванька\'\n</code></pre>\n<img src="img/2.png" alt="2">\n<nav>\n<a href="https://learn.javascript.ru/cookie" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/cookie" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 38 --\x3e\n<section id="37">\n<h3>37. Зачем нужны куки?</h3>\n<p>Куки используются для сохранения информации о пользователе (не рекомендуется использовать для хранения конфиденциальной информации). Обычно, данный процесс состоит из двух этапов:</p>\n<ul>\n<li>При первом посещении страницы профиль пользователя сохраняется в куки</li>\n<li>При повторном посещении страницы профиль пользователя извлекается из куки</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/cookie" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/cookie" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 39 --\x3e\n<section id="38">\n<h3>38. Какими возможностями обладают куки?</h3>\n<p>По умолчанию, куки удаляются при закрытии браузера, однако это можно изменить, установив время жизни (expires) в формате UTC:</p>\n<pre><code class="lang-js">\ndocument.cookie = \'username=Ванька; expires=Sat, 5 Sep 2020 12:00:00 UTC\'\n</code></pre>\n<p>По умолчанию, куки принадлежат текущей странице, однако это также можно изменить, установив путь (path):</p>\n<pre><code class="lang-js">\ndocument.cookie = \'username=Ванька; path=/services\'\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/cookie" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/cookie" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 40 --\x3e\n<section id="39">\n<h3>39. Как удалить куки?</h3>\n<p>Удалить куки можно, установив прошедшее время в качестве времени жизни. В этом случае не нужно определять значение куки:</p>\n<pre><code class="lang-js">\ndocument.cookie = \'username=; expires=Sat, 05 Jun 2020 00:00:00 UTC; path=/;\'\n</code></pre>\n<p>Обратите внимание, что в данном случае необходимо определить путь для удаления правильного куки. Некоторые браузеры не позволяют удалить куки без указания этого параметра.</p>\n<nav>\n<a href="https://learn.javascript.ru/cookie" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/cookie" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 41 --\x3e\n<section id="40">\n<h3>40. В чем разница между куки, локальным и сессионным хранилищами?</h3>\n<p>Основные отличия состоят в следующем:</p>\n<table>\n<tbody><tr>\n<th>Критерий</th>\n<th>Куки</th>\n<th>Локальное хранилище</th>\n<th>Сессионное хранилище</th>\n</tr>\n<tr>\n<td>Доступность</td>\n<td>Как на сервере, так и на клиенте</td>\n<td>Только на клиенте</td>\n<td>Только на клиенте</td>\n</tr>\n<tr>\n<td>Время жизни</td>\n<td>Устанавливается с помощью expires</td>\n<td>До удаления пользователем</td>\n<td>До закрытия вкладки браузера</td>\n</tr>\n<tr>\n<td>Поддержка шифрования</td>\n<td>Поддерживается</td>\n<td>Не поддерживается</td>\n<td>Не поддерживается</td>\n</tr>\n<tr>\n<td>Максимальный размер данных</td>\n<td>4 Кб</td>\n<td>Около 5 Мб (зависит от браузера)</td>\n<td>Около 5 Мб (зависит от браузера)</td>\n</tr>\n</tbody></table>\n<nav>\n<a href="https://learn.javascript.ru/cookie" target="_blank">JSR - Куки</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/cookie" target="_blank">MDN - Cookie</a>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR - LocalStorage, SessionStotage</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN - Web Storage</a>\n</nav>\n</section>\n\n\x3c!-- 42 --\x3e\n<section id="41">\n<h3>41. В чем главное отличие между локальным и сессионным хранилищами?</h3>\n<p>Локальное хранилище - это тоже самое, что и сессионное хранилище, за исключением того, что в первом данные сохраняются даже при закрытии и перезагрузке браузера, а во втором данные удаляются по окончании сессии (закрытие вкладки браузера).</p>\n<nav>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 43 --\x3e\n<section id="42">\n<h3>42. Как получить доступ к веб-хранилищу?</h3>\n<p>Объект window предоставляет объекты WindowLocalStorage и WindowSessionStorage, которые имеют свойства localStorage и sessionStorage, соответственно. Эти свойства создают экземпляр объекта Storage, с помощью которого можно записывать, извлекать и удалять данные для определенного домена и типа хранилища (сессионное или локальное):</p>\n<pre><code class="lang-js">\n// сохраняем данные\nlocalStorage.setItem(\'data\', document.querySelector(\'.data\').value)\n// получаем данные\nlocalStorage.getItem(\'data\')\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 44 --\x3e\n<section id="43">\n<h3>43. Какие методы предоставляет сессионное хранилище?</h3>\n<p>Сессионное хранилище предоставляет методы для чтения, записи и удаления данных:</p>\n<pre><code class="lang-js">\n// записываем данные\nsessionStorage.setItem(\'key\', \'value\')\n\n// получаем данные\nconst data = sessionStorage.getItem(\'key\')\n\n// удаляем определенные данные\nsessionStorage.removeItem(\'key\')\n\n// удаляем все данные\nsessionStorage.clear()\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 45 --\x3e\n<section id="44">\n<h3>44. Какое событие возникает при работе с веб-хранилищем?</h3>\n<p>При изменении хранилища в контексте другого документа возникает событие storage:</p>\n<pre><code class="lang-js">\nwindow.onstorage = function () {}\n</code></pre>\n<p>Пример обработки данного события:</p>\n<pre><code class="lang-js">\nwindow.onstorage = event =&gt; {\n    console.log(`&#36;{event.key} был изменен.\n    Старое значение: &#36;{event.oldValue}.\n    Новое значение: &#36;{event.newValue}.`)\n}\n</code></pre>\n<p>Данное событие позволяет реализовать своего рода чат.</p>\n<nav>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 46 --\x3e\n<section id="45">\n<h3>45. Для чего используется веб-хранилище?</h3>\n<p>Веб-хранилище является более безопасным и может хранить больший объем данных, чем куки, что не влияет на производительность. Кроме того, данные не отправляются на сервер (в случае с куки данные включаются в заголовки запроса и ответа при каждом обращении клиента к серверу). Поэтому такой способ хранения данных является более предпочтительным, чем куки.</p>\n<nav>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 47 --\x3e\n<section id="46">\n<h3>46. Как определить поддержку веб-хранилища браузером?</h3>\n<p>Перед использованием веб-хранилища рекомендуется проверить поддержку данного интерфейса браузерами:</p>\n<pre><code class="lang-js">\nif (typeof(Storage) !== \'undefined\') {\n    // код\n} else {\n    // веб-хранилище не поддерживается\n}\n\n// или\nif (\'Storage\' in window) {\n    console.log(\'ok\')\n} else {\n    console.warn(\'не ok\')\n}\n</code></pre>\n<p>По данным <a href="https://caniuse.com/#feat=namevalue-storage" target="_blank">CanIUse</a> поддержка веб-хранилища на сегодняшний день составляет 98%.</p>\n<nav>\n<a href="https://learn.javascript.ru/localstorage" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 48 --\x3e\n<section id="47">\n<h3>47. Как определить поддержку сервис-воркеров браузером?</h3>\n<p>Перед использованием сервис-воркеров рекомендуется проверить поддержку данного интерфейса браузерами:</p>\n<pre><code class="lang-js">\nif (typeof(Worker) !== undefined) {\n    // код\n} else {\n    // сервис-воркеры не поддерживаются\n}\n// или\nif (\'Worker\' in window) {\n    console.log(\'ok\')\n} else {\n    console.warn(\'не ok\')\n}\n</code></pre>\n<p>По данным <a href="https://caniuse.com/#feat=serviceworkers" target="_blank">CanIUse</a> поддержка сервис-воркеров на сегодняшний день составляет 94%.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 49 --\x3e\n<section id="48">\n<h3>48. Приведите пример веб-воркера</h3>\n<p>Для использования веб-воркера необходимости сделать следующее.</p>\n<p>Создать файл для воркера, например, get-current-time.js:</p>\n<pre><code class="lang-js">\nconst getCurrentTime = () =&gt; {\n    let time = new Date().toLocaleTimeString()\n    postMessage(time)\n    setTimeout(() =&gt; getCurrentTime(), 1000)\n}\n\ngetCurrentTime()\n</code></pre>\n<p>Метод postMessage() используется для отправки сообщений странице.</p>\n<p>Создаем объект воркера:</p>\n<pre><code class="lang-js">\nconst worker = new Worker(\'get-current-time.js\')\n</code></pre>\n<p>После этого обрабатываем получение сообщений от воркера:</p>\n<pre><code class="lang-js">\n&lt;output>&lt;/output>\n&lt;button>Стоп&lt;/button>\n\nworker\n    .addEventListener(\'message\', event =&gt; document.querySelector(\'output\')\n    .textContent = event.data)\n</code></pre>\n<p>Воркер будет продолжать обрабатывать событие message даже после того, как внешний скрипт выполнит свою работу, поэтому его нужно останавливать принудительно:</p>\n<pre><code class="lang-js">\ndocument.querySelector(\'button\')\n    .addEventListener(\'click\', () =&gt; worker.terminate())\n</code></pre>\n<p>Если присвоить воркеру значение undefined, его можно будет использовать повторно:</p>\n<pre><code class="lang-js">\nworker = undefined\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 50 --\x3e\n<section id="49">\n<h3>49. Назовите ограничения веб-воркеров по работе с DOM</h3>\n<p>Поскольку веб-воркеры создаются в отдельном файле, они не имеют доступа к следующим объектам:</p>\n<ul>\n<li>window</li>\n<li>Document</li>\n<li>Родительский объект - объект, запустивший воркер</li>\n</ul>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 51 --\x3e\n<section id="50">\n<h3>50. Что такое промис (promise)?</h3>\n<p>Промис (общание) - это объект, который либо выполняется с некоторым значением, либо отклоняется с ошибкой. Разрешение промиса происходит либо после истечения определенного времени, либо после возникновения определенного события. Промис может иметь одно из трех состояний: находится в режиме ожидания (pending), выполнен (fulfilled), отклонен (rejected).</p>\n<p>Синтаксис промиса:</p>\n<pre><code class="lang-js">\nconst promise = new Promise((resolve, reject) =&gt; {\n    // код\n})\n\n// или, когда мы уверены, что промис выполнится успешно\nconst promise = Promise.resolve(value)\npromise.then(value =&gt; {\n    // код\n})\n</code></pre>\n<p>Пример использования промиса:</p>\n<pre><code class="lang-js">\nconst promise = new Promise(resolve =&gt; {\n    const timer = setTimeout(() =&gt; {\n        resolve(\'Привет от промиса!\')\n        clearTimeout(timer)\n    }, 5000);\n}, reject =&gt; {\n    reject(\'Что-то пошло не так\')\n})\n\npromise\n    .then(value =&gt; console.log(value))\n    .catch(error =&gt; console.error(error))\n    .finally(() =&gt; console.log(\'Мы закончили\')) // в консоль будет выведено "Привет от промиса!" через 5 секунд и затем "Мы закончили"\n</code></pre>\n<p>Алгоритм разрешения промиса:</p>\n<img src="img/3.png" alt="3">\n<nav>\n<a href="https://learn.javascript.ru/promise-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 52 --\x3e\n<section id="51">\n<h3>51. Зачем нужны промисы?</h3>\n<p>Промисы используются для работы с асинхронным кодом. Они представляют собой альтернативу функциям обратного вызова, позволяя избежать так называемого "ада колбэков", делают код более чистым и читаемым.</p>\n<nav>\n<a href="https://learn.javascript.ru/promise-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 53 --\x3e\n<section id="52">\n<h3>52. Назовите три возможных состояния промиса</h3>\n<p>У промисов существует три состояния:</p>\n<ul>\n<li>Ожидание (pending): стадия перед началом выполнения операции</li>\n<li>Выполнен (fulfilled): успешное завершение операции</li>\n<li>Отклонен (rejected): неудачное выполнение операции. Выбрасывается исключение</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/promise-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 54 --\x3e\n<section id="53">\n<h3>53. Что такое функция обратного вызова (колбэк)?</h3>\n<p>Колбэк - это функция, которая передается другой функции в качестве аргумента. Данная функция (внутренняя) вызывается внутри родительской (внешней) для выполнения операции при возникновении определенного события. Рассмотрим простой пример:</p>\n<pre><code class="lang-js">\nfunction callback(name) {\n    alert(`Привет, &#36;{name}!`)\n}\n\nfunction outer(cb) {\n    const name = prompt(\'Пожалуйста, введите свое имя\')\n    cb(name)\n}\nouter(callback)\n</code></pre>\n<p>В приведенном примере функция outer запрашивает имя пользователя и записывает его в переменную name. Затем данная функция передает name функции callback, которая выводит приветствие с именем пользователя.</p>\n<nav>\n<a href="https://learn.javascript.ru/callbacks" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 55 --\x3e\n<section id="54">\n<h3>54. Зачем нужны колбэки?</h3>\n<p>Колбэки нужны, поскольку JavaScript - язык, управляемый событиями. Это означает, что, например, вместо ожидания получения ответа на запрос или завершения обработки определенного события, JavaScript продолжает реагировать на другие события. Рассмотрим пример, в котором одна функция обращается к интерфейсу, а другая - выводит сообщение в консоль:</p>\n<pre><code class="lang-js">\nfunction first () {\n    // имитируем обращение к API\n    setTimeout(() =&gt; console.log(\'Вызвана первая функция\'), 1000)\n}\n\nfunction second () {\n    console.log(\'Вызвана вторая функция\')\n}\n\nfirst()\nsecond()\n// сначала будет выведено "Вызвана вторая функция", затем "Вызвана первая функция"\n</code></pre>\n<p>Как видите, JavaScript не ожидает завершения первой функции, а продолжает выполнение кода. Поэтому колбэки используются для имитации асинхронности, предотвращая блокировку основного потока выполнения программы.</p>\n<nav>\n<a href="https://learn.javascript.ru/callbacks" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 56 --\x3e\n<section id="55">\n<h3>55. Что такое ад колбэков?</h3>\n<p>Ад колбэков - это антипаттерн, когда множество функций обратного вызова вложены друг в друга для реализации асинхронной логики. Такая структура кода сложна для восприятия и поддержки. Это может выглядеть так:</p>\n<pre><code class="lang-js">\nfunction first () {\n    return function second () {\n        return function third () {\n            return function fourth () {\n                // и т.д.\n            }\n        }\n    }\n}\n</code></pre>\n<p>Такой подход к написанию кода считается плохой практикой, кроме случаев каррирования, частичного применения или композиции функций.</p>\n<nav>\n<a href="https://learn.javascript.ru/callbacks" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 57 --\x3e\n<section id="56">\n<h3>56. Что такое события, отправляемые сервером (server-sent events, SSE)?</h3>\n<p>События, отправляемые сервером - это технология пуш-уведомлений, позволяющая браузерам получать от сервера обновленные данные через HTTP-соединение без отправки запроса. Это один из способов коммуникации клиента и сервера, когда сообщения отправляются только сервером. Данная технология используется для обновления Facebook/Twitter, цен в магазинах, новостных лент и т.д.</p>\n<nav>\n<a href="https://learn.javascript.ru/server-sent-events" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 58 --\x3e\n<section id="57">\n<h3>57. Как получать сообщения (уведомления или события), отправленные сервером?</h3>\n<p>Для этого используется объект EventSource:</p>\n<pre><code class="lang-js">\nif(\'EventSource\' in window) {\n    const source = new EventSource(\'sse.js\')\n    source.addEventListener(\'message\', event =&gt; document.querySelector(\'output\')\n        .textContent = event.data)\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/server-sent-events" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/EventSource" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 59 --\x3e\n<section id="58">\n<h3>58. Как проверить поддержку SSE браузером?</h3>\n<p>Это делается так:</p>\n<pre><code class="lang-js">\nif (typeof EventSource !== \'undefined\') {\n    // код\n} else {\n    // SSE не поддерживается\n}\n\n// или\n(\'EventSource\' in window)\n    ? console.log(\'ok\')\n    : console.warn(\'!не ok\')\n</code></pre>\n<p>По данным <a href="https://caniuse.com/#feat=eventsource" target="_blank">CanIUse</a> на сегодняшний день SSE поддерживается 95% браузеров.</p>\n<nav>\n<a href="https://learn.javascript.ru/server-sent-events" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 60 --\x3e\n<section id="59">\n<h3>59. Какие события возникают при работе с SSE?</h3>\n<p>Вот список этих событий:</p>\n<table>\n<tbody><tr>\n<th>Событие</th>\n<th>Описание</th>\n</tr>\n<tr>\n<td>open</td>\n<td>Возникает при открытии соединения с сервером</td>\n</tr>\n<tr>\n<td>message</td>\n<td>Возникает при получении сообщения от сервера</td>\n</tr>\n<tr>\n<td>error</td>\n<td>Возникает при выбрасывании исключения</td>\n</tr>\n</tbody></table>\n<nav>\n<a href="https://learn.javascript.ru/server-sent-events" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 61 --\x3e\n<section id="60">\n<h3>60. Назовите основные правила работы с промисами</h3>\n<p>Основными правилами работы с промисами является следующее:</p>\n<ul>\n<li>Промис - это объект, содержащий встроенный или стандартный метод then()</li>\n<li>Стадия ожидания промиса, обычно, заканчивается стадией его выполнения или отклонения</li>\n<li>Состояние выполненного или отклоненного промиса не должно меняться после его разрешения</li>\n<li>После разрешения промиса его значение также не должно меняться</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/promise-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 62 --\x3e\n<section id="61">\n<h3>61. Что такое колбэк в колбэке?</h3>\n<p>Вы можете вкладывать колбеки друг в друга с целью последовательного выполнения определенных операций:</p>\n<pre><code class="lang-js">\nloadScript(\'/script1.js\', script =&gt; {\n    console.log(`Скрипт &#36;{script} загружен`)\n\n    loadScript(\'/script2.js\', script =&gt; {\n        console.log(`Скрипт &#36;{script} загружен`)\n\n        loadScript(\'/script3.js\', script =&gt; {\n            console.log(`Скрипт &#36;{script} загружен`)\n        })\n    })\n})\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/callbacks" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 63 --\x3e\n<section id="62">\n<h3>62. Что такое цепочка промисов?</h3>\n<p>Последовательное выполнение нескольких асинхронных задач с помощью промисов называется цепочкой промисов. Рассмотрим пример:</p>\n<pre><code class="lang-js">\nnew Promise((resolve, reject) =&gt; {\n    const id = setTimeout(() =&gt; {\n        resolve(1)\n        clearTimeout(id)\n    }, 1000)\n}).then(result =&gt; {\n    console.log(result) // 1\n    return result * 2\n}).then(result2 =&gt; {\n    console.log(result2) // 2\n    return result2 * 3\n}).then(result3 =&gt; {\n    console.log(result3) // 6\n}).catch(error =&gt; console.error(error))\n</code></pre>\n<p>Алгоритм выполнения:</p>\n<ul>\n<li>Первый промис разрешается со значением 1</li>\n<li>После этого, первый метод then() выводит это значение в консоль и возвращает его, умножая на 2</li>\n<li>Второй then() выводит результат первого then() в консоль (2) и возвращает результат, умножая его на 3</li>\n<li>Последний then() выводит результат второго then() в консоль (6)</li>\n<li>Блок catch служит для обработки ошибок</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/promise-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 64 --\x3e\n<section id="63">\n<h3>63. Что такое Promise.all()?</h3>\n<p>Promise.all() - это промис, принимающий массив других промисов в качестве аргумента и возвращающий результаты выполненных промисов или ошибку при отклонении одного из них. Синтаксис:</p>\n<pre><code class="lang-js">\nPromise.all([Promise1, Promise2, Promise3])\n    .then(results =&gt; console.log(results))\n    .catch(error =&gt; console.error(error))\n</code></pre>\n<p>Помните, что порядок получения результатов зависит от порядка промисов в массиве.</p>\n<nav>\n<a href="https://learn.javascript.ru/promise-api" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 65 --\x3e\n<section id="64">\n<h3>64. Что такое Promise.race()?</h3>\n<p>Promise.race() возвращает результат первого выполненного или отклоненного промиса из переданных ему в виде массива промисов:</p>\n<pre><code class="lang-js">\nconst promise1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 500, \'раз\'))\n\nconst promise2 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 100, \'два\'))\n\nPromise.race([promise1, promise2]).then(value =&gt; console.log(value)) // "два"\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/promise-api" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 66 --\x3e\n<section id="65">\n<h3>65. Что такое строгий режим?</h3>\n<p>Для включения строго режима используется инструкция \'use strict\' (или "use strict") в начале всего кода или отдельной функции. Строгий режим был представлен в ES5. В данном режиме запрещены некоторые действия и выбрасывается больше исключений.</p>\n<nav>\n<a href="https://learn.javascript.ru/strict-mode" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 67 --\x3e\n<section id="66">\n<h3>66. Зачем нужен строгий режим?</h3>\n<p>Строгий режим позволяет писать более безопасный код, предотвращая возникновение многих ошибок. Например, он запрещает случайное создание глобальных переменных (без ключевого слова, variable = value), присваивание значения свойству, доступному только для чтения, свойству, которое можно получить только с помощью геттера, несуществующему свойству и несуществующей переменной или объекту. В нестрогом режиме во всех этих случаях исключение не выбрасывается.</p>\n<nav>\n<a href="https://learn.javascript.ru/strict-mode" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 68 --\x3e\n<section id="67">\n<h3>67. Как включить строгий режим?</h3>\n<p>Строгий режим включается с помощью инструкции \'use strict\' (или "use strict") в начале кода или функции. Обычно, данная инструкция указывается в самом начале скрипта, т.е. в глобальном пространстве имен:</p>\n<pre><code class="lang-js">\n\'use strict\'\nx = 3.14 // ReferenceError: "x" is not defined\n</code></pre>\n<p>Если \'use strict\' указывается в функции, то действие строгого режима распространяется только на эту функцию:</p>\n<pre><code class="lang-js">\nx = 3.14 // все в порядке\nf() // ReferenceError: "y" is not defined\n\nfunction f () {\n    \'use strict\'\n    y = 3.14\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/strict-mode" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 69 --\x3e\n<section id="68">\n<h3>68. Для чего используется двойное отрицание?</h3>\n<p>Двойное отрицание (!!) преобразует значение в логическое. Если значение является ложным, то возвращается false, иначе - true:</p>\n<pre><code class="lang-js">\nconst x = 1\nconsole.log(x) // 1\nconsole.log(!!x) // true\nconst y = \'\'\nconsole.log(y) // \'\'\nconsole.log(!!str) // false\n</code></pre>\n<p>Обратите внимание: !! - это не отдельный оператор, а два оператора !.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_NOT" target="_blank">MDN</a>\n<a href="https://learn.javascript.ru/logical-ops" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 70 --\x3e\n<section id="69">\n<h3>69. Для чего используется оператор delete?</h3>\n<p>Данный оператор служит для удаления свойств объектов и значений этих свойств:</p>\n<pre><code class="lang-js">\n\'use strict\'\nconst user = {\n    name: \'Ванька\',\n    age: 30\n}\n\ndelete user.age\n\nconsole.log(user) // { name: "Ванька" }\n\ndelete user // SyntaxError: Delete of an unqualified identifier in strict mode\n</code></pre>\n<p>Обратите внимание, что в нестрогом режиме попытка удаления объекта тихо завершится ничем.</p>\n<p>Поскольку массив - это тоже объект, применение delete к элементу массива удалит его значение и запишет в него undefined, т.е. индекс удаленного элемента массива сохранится и длина массива не изменится.</p>\n<nav>\n<a href="https://learn.javascript.ru/object#literaly-i-svoystva" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/delete" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 71 --\x3e\n<section id="70">\n<h3>70. Для чего используется оператор typeof?</h3>\n<p>Данный оператор используется для определения типа переменной или выражения:</p>\n<pre><code class="lang-js">\ntypeof 1 // number\ntypeof [] // object\ntypeof \'Ванька\' // string\ntypeof (1 + 2) // number\n\ntypeof null // object\ntypeof NaN // number\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/types#type-typeof" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 72 --\x3e\n<section id="71">\n<h3>71. Что такое undefined?</h3>\n<p>undefined - это неопределенное (но не отсутствующее) стандартное значение (значение по умолчанию) переменной, которой не было присвоено значение, а также необъявленной переменной. Это один из примитивных типов данных:</p>\n<pre><code class="lang-js">\nlet name\nconsole.log(typeof name) // undefined\nconsole.log(typeof age) // undefined\n</code></pre>\n<p>Данное значение может присваиваться переменной явно:</p>\n<pre><code class="lang-js">\nuser = undefined\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/types#znachenie-undefined" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/undefined" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 73 --\x3e\n<section id="72">\n<h3>72. Что такое null?</h3>\n<p>null - значение, представляющее собой отсутствие значения, установленное явно. Это один из примитивных типов данных. С помощью null можно удалить значение переменной:</p>\n<pre><code class="lang-js">\nconst user = null\nconsole.log(typeof user) // object\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/types#znachenie-null" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 74 --\x3e\n<section id="73">\n<h3>73. В чем разница между null и undefined?</h3>\n<p>Основные отличия состоят в следующем:</p>\n<table>\n<tbody><tr>\n<th>Null</th>\n<th>Undefined</th>\n</tr>\n<tr>\n<td>Присваивается в качестве индикатора отсутствия значения</td>\n<td>Является значением по умолчанию для переменных, которым не было присвоено значение, или необъявленных переменных</td>\n</tr>\n<tr>\n<td>Тип - object</td>\n<td>Тип - undefined</td>\n</tr>\n<tr>\n<td>Примитивный тип, означающий нуль, отсутствие значения или ссылки</td>\n<td>Примитивный тип, означающий, что переменной не было присвоено значения</td>\n</tr>\n<tr>\n<td>Указывает на отсутствие значения переменной</td>\n<td>Указывает на отсутствие переменной или неопределенность ее значения</td>\n</tr>\n</tbody></table>\n<nav>\n<a href="https://learn.javascript.ru/types#znachenie-undefined" target="_blank">JSR - undefined</a>\n<a href="https://learn.javascript.ru/types#znachenie-null" target="_blank">JSR - null</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/undefined" target="_blank">MDN - undefined</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank">MDN - null</a>\n</nav>\n</section>\n\n\x3c!-- 75 --\x3e\n<section id="74">\n<h3>74. Что такое eval?</h3>\n<p>Функция eval() вычисляет переданную ей строку. Строка может быть выражением, переменной, одним или несколькими операторами:</p>\n<pre><code class="lang-js">\nconsole.log(eval(\'1 + 2\')) // 3\n\n// пример с каррированием\nconst curryCalc = x =&gt; operator =&gt; y =&gt;\n    new Promise((resolve, reject) =&gt;\n        resolve(eval(`x&#36;{operator}y`))\n    ).then(\n        result =&gt; console.log(result),\n        error =&gt; console.error(\'Некорректная операция!\')\n    )\n\ncurryCalc(1)(\'+\')(2) // 3\ncurryCalc(4)(\'-\')(3) // 1\ncurryCalc(5)(\'x\')(6) // Некорректная операция!\n</code></pre>\n<p>Использовать не рекомендуется.</p>\n<nav>\n<a href="https://learn.javascript.ru/eval" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 77 --\x3e\n<section id="75">\n<h3>75. Как получить доступ к истории браузера?</h3>\n<p>Информацию об истории перемещений между страницами в браузере содержит свойство history объекта window. Для перехода к предыдущей или следующей странице следует использовать методы back(), next() или go():</p>\n<pre><code class="lang-js">\nconst goBack = () =&gt; {\n    history.back()\n    // или\n    history.go(-1)\n}\n\nconst goForward = () =&gt; history.forward()\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/History" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 78 --\x3e\n<section id="76">\n<h3>76. Какие типы данных существуют в JavaScript?</h3>\n<p>В JavaScript есть 8 основных типов:</p>\n<ul>\n<li>number для любых чисел: целочисленных или чисел с плавающей точкой, целочисленные значения ограничены диапазоном ±2<sup>53</sup></li>\n<li>bigint для целых чисел произвольной длины</li>\n<li>string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа</li>\n<li> boolean для true/false</li>\n<li>null для неизвестных значений – отдельный тип, имеющий одно значение null</li>\n<li>undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined</li>\n<li>object для более сложных структур данных</li>\n<li>symbol для уникальных идентификаторов</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/types" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 79 --\x3e\n<section id="77">\n<h3>77. Что делает isNaN()?</h3>\n<p>Функция isNaN() преобразует значение в число и проверяет, является ли оно NaN.</p>\n<pre><code class="lang-js">\nisNaN(\'hello\') // true\nisNaN(100) // false\n</code></pre>\n<p>Более надежной версией данной функции является метод Number.isNaN(), представленный в ES6.</p>\n<nav>\n<a href="https://learn.javascript.ru/number" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isNaN" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 80 --\x3e\n<section id="78">\n<h3>78. В чем разница между необъявленными и неопределенными переменными?</h3>\n<p>Основные отличия заключаются в следующем:</p>\n<table>\n<tbody><tr>\n<th>Необъявленные</th>\n<th>Неопределенные</th>\n</tr>\n<tr>\n<td>Не существуют в программе</td>\n<td>Были объявлены без присвоения значения</td>\n</tr>\n<tr>\n<td>Попытка доступа заканчивается ошибкой</td>\n<td>При попытке получить доступ возвращается undefined</td>\n</tr>\n<tr>\n<td>Поднимается (всплывает) в начало текущей области видимости</td>\n<td>Также поднимается, но без присвоенного значения, т.е. со значением undefined (поднимается только объявление, но не инициализация)</td>\n</tr>\n</tbody></table>\n<nav>\n<a href="https://learn.javascript.ru/variables" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 81 --\x3e\n<section id="79">\n<h3>79. Что такое глобальные переменные?</h3>\n<p>В браузере глобальные функции и переменные, объявленные с помощью ключевого слова "var", или без использованию ключевого слова (в нестрогом режиме), становятся свойствами глобального объекта window (не работает в модулях). Такие переменные доступны из любого места программы. Использовать глобальные переменные не рекомендуется. При необходимости создания глобальной переменной лучше сделать это явно:</p>\n<pre><code class="lang-js">\nwindow.currentUser = {\n    name: \'Ванька\'\n}\n\n// или\nglobalThis.currentUser = {\n    name: \'Ванька\'\n}\n\nconsole.log(currentUser.name) // Ванька\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/global-object" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 82 --\x3e\n<section id="80">\n<h3>80. Какие проблемы влечет за собой создание глобальных переменных?</h3>\n<p>Создание глобальных переменных приводит к загрязнению глобального пространства имен, что может вызвать конфликт между названиями переменных. Это также усложняет отладку и тестирование кода.</p>\n<nav>\n<a href="https://learn.javascript.ru/global-object" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 83 --\x3e\n<section id="81">\n<h3>81. Что такое NaN?</h3>\n<p>Глобальное свойство NaN является значением, представляющим собой не число (Not-a-Number). Точнее, NaN указывает на то, что значение является неправильным, но все-таки числом. Поэтому typeof NaN возвращает number.</p>\n<pre><code class="lang-js">\nparseInt(\'bla\') // NaN\nMath.sqrt(-1) // NaN\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 84 --\x3e\n<section id="82">\n<h3>82. Что делает isFinite()?</h3>\n<p>Глобальная функция isFinite() преобразует аргумент в число и возвращает true, если оно является обычным (конечным) числом, т.е. не NaN, Infinity (положительная бесконечность), -Infinity (отрицательная бесконечность). В противном случае, возвращается false.</p>\n<pre><code class="lang-js">\nisFinite(Infinity) // false\nisFinite(-Infinity) // false\nisFinite(NaN) // false\n\nisFinite(100) // true\n</code></pre>\n<p>Также существует метод Number.isFinite(), который в отличие от isFinite() не преобразует аргумент в число перед проверкой.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isFinite" target="_blank">MDN</a>\n<a href="https://learn.javascript.ru/number" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 85 --\x3e\n<section id="83">\n<h3>83. Что такое поток или рспространение событий (event flow/propagation)?</h3>\n<p>Поток событий (распространение событий) - это порядок, в котором событие возникает на странице. Когда вы кликаете по элементу, вложенному в другие элементы, перед тем как событие достигнет целевого элемента, оно последовательно пройдет через всех его предков, начиная от глобального объекта window. Существует три стадии распространения события:</p>\n<ul>\n<li>Сверху вниз - стадия захвата или погружения</li>\n<li>Целевая стадия</li>\n<li>Снизу вверх - стадия всплытия или поднятия (не путать с поднятием переменных - hoisting)</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/bubbling-and-capturing" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 86 --\x3e\n<section id="84">\n<h3>84. Что такое всплытие события?</h3>\n<p>Всплытие - это стадия распространения события, когда событие сначала регистрируется на целевом элементе, а затем по цепочке из предков данного элемента поднимается до самого верхнего (внешнего) элемента - глобального объекта window.</p>\n<nav>\n<a href="https://learn.javascript.ru/bubbling-and-capturing" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 87 --\x3e\n<section id="85">\n<h3>85. Что такое погружение или захват события?</h3>\n<p>Погружение - это стадия возникновения события, когда оно сначала регистрируется на самом верхнем (внешнем) элементе (глобальном объекте window), а затем спускается вниз по цепочке из предков до целевого элемента.</p>\n<nav>\n<a href="https://learn.javascript.ru/bubbling-and-capturing" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 88 --\x3e\n<section id="86">\n<h3>86. Как отправить форму на обработку?</h3>\n<p>Это можно сделать разными способами:</p>\n<pre><code class="lang-js">\nfunction submitForm() {\n    document.forms[0].submit()\n}\n\nform.onsubmit = function(event) {\n    event.preventDefault()\n    // код\n}\n\nform.addEventListener(\'submit\', event =&gt; {\n    event.preventDefault()\n    // код\n})\n</code></pre>\n<p>Любая кнопка в форме по умолчанию имеет тип submit, т.е. служит для отправки формы.</p>\n<nav>\n<a href="https://learn.javascript.ru/forms-submit" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/HTMLFormElement/submit" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 89 --\x3e\n<section id="87">\n<h3>87. Как получить информацию об операционной системе?</h3>\n<p>Данную информацию содержит глобальный объект navigator. Некоторую часть этой информации можно получить через его свойство platform:</p>\n<pre><code class="lang-js">\nconsole.log(navigator.platform)\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Navigator" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 90 --\x3e\n<section id="88">\n<h3>88. В чем разница между событиями DOMContentLoaded и load?</h3>\n<p>Событие DOMContentLoaded возникает, когда первоначальный HTML документ полностью загружен и разобран без ожидания полной загрузки таблиц стилей, изображений или фреймов. Событие load возникает после полной загрузки страницы, включая все дополнительные ресурсы.</p>\n<nav>\n<a href="https://learn.javascript.ru/onload-ondomcontentloaded" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/DOMContentLoaded_event" target="_blank">MDN - DOMContentLoaded</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/Events/load" target="_blank">MDN - load</a>\n</nav>\n</section>\n\n\x3c!-- 91 --\x3e\n<section id="89">\n<h3>89. В чем разница между нативными, хостовыми (принадлежащими среде выполнения кода) и пользовательскими объектами?</h3>\n<p>Нативные объекты (native objects) являются частью языка и определяются в спецификации ECMAScript. Такими объектами являются, например, Number, String, Function, Object, Math, RegExp, Date и т.д. Хостовые объекты (host objects) предоставляются браузером или другой средой выполнения, например, Node.js. Такими объектами являются, например, window, document (DOM), XMLHttpRequest, Web API (стек вызовов - call stack, очередь задач - task queue) и др. Пользовательскими объектами (user objects) являются любые объекты, создаваемые в коде, например, объект, содержащий информацию о пользователе:</p>\n<pre><code class="lang-js">\nconst user = {\n    name: \'Ванька\',\n    age: 30\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 92 --\x3e\n<section id="90">\n<h3>90. Какие средства используются для откладки кода?</h3>\n<p>Такими средствами являются:</p>\n<ul>\n<li>Инструменты разработчика в браузере, например, Chrome DevTools</li>\n<li>Выражение debugger</li>\n<li>Старый-добрый console.log()</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/debugging-chrome" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger" target="_blank">MDN - debugger</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Console" target="_blank">MDN - Console</a>\n</nav>\n</section>\n\n\x3c!-- 93 --\x3e\n<section id="91">\n<h3>91. В чем заключаются преимущества и недостатки промисов по сравнению с колбэками?</h3>\n<p>Преимущества:</p>\n<ul>\n<li>Предотвращают ад колбэков</li>\n<li>Позволяют выполнять асинхронный код последовательно с помощью then()</li>\n<li>Позволяют выполнять асинхронный код параллельно с помощью Promise.all()</li>\n<li>Решают многие проблемы колбэков (слишком поздний или слишком ранний вызов, несколько вызовов вместо одного, скрытие ошибок)</li>\n</ul>\n<p>Недостатки</p>\n<ul>\n<li>Код становится сложнее писать</li>\n<li>Для обеспечения поддержки старыми браузерами нужен полифил (таких браузеров на сегодняшний день почти не осталось)</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/promise-basics" target="_blank">JSR - Промисы</a>\n<a href="https://learn.javascript.ru/callbacks" target="_blank">JSR - Колбэки</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN - Promise</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0" target="_blank">MDN - Callback</a>\n</nav>\n</section>\n\n\x3c!-- 94 --\x3e\n<section id="92">\n<h3>92. В чем разница между атрибутом и свойством элемента?</h3>\n<p>Когда браузер загружает страницу, он разбирает HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов. Т.е. атрибут элемента указывается в разметке, а его свойство в DOM. Например, для тега body с атрибутом id="page" у DOM-объекта будет свойство body.id="page".</p>\n<pre><code class="lang-js">\n&lt;input type="text" value="Доброе утро!"&gt;\n// данный элемент имеет два атрибута: type и value\n\nconst input = document.querySelector(\'input\')\n// получаем атрибут\nconsole.log(input.getAttribute(\'value\'))\n// получаем свойство\nconsole.log(input.value)\n\n// меняем значение атрибута\ninput.setAttribute(\'value\', \'Добрый вечер!\')\n// меняем значение свойства\ninput.value = \'Добрый вечер!\'\n</code></pre>\n<p>Обратите внимание, что спецификация ECMAScript также определяет атрибуты свойств объекта - [[Value]], [[Writable]], [[Enumerable]] и [[Configurable]].</p>\n<nav>\n<a href="https://learn.javascript.ru/dom-attributes-and-properties" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 95 --\x3e\n<section id="93">\n<h3>93. Что такое политика общего происхождения (same-origin policy, SOP)?</h3>\n<p>Политика общего происхождения (одинакового источника) блокирует доступ к данным из другого источника. Источником является сочетание протокола, хоста и порта. По умолчанию, совместное использование ресурсов (cross-origin resource sharing, CORS) запрещено, т.е. данные предоставляются только в ответ на запрос из того же источника, в котором они находятся. Это поведение можно изменить с помощью специальных HTTP-заголовков.</p>\n<nav>\n<a href="https://learn.javascript.ru/cross-window-communication" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/Security/Same-origin_policy" target="_blank">MDN - SOP</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/HTTP/CORS" target="_blank">MDN - CORS</a>\n</nav>\n</section>\n\n\x3c!-- 96 --\x3e\n<section id="94">\n<h3>94. Что делает void 0?</h3>\n<p>Оператор void вычисляет переданное выражение и возвращает undefined. Обычно, когда мы кликаем по ссылке, браузер загружает новую сраницу или перезагружает текущую. С помощью выражения "void(0)" можно этого избежать:</p>\n<pre><code class="lang-js">\n&lt;a href="javascript:void(0)" onclick="alert(\'Привет!\')"&gt;Нажми на меня!\n&lt;/a&gt;</code></pre>\n<p>Перезагрузку страницы также можно предотвратить с помощью простой заглушки:</p>\n<pre><code class="lang-js">\n&lt;a href="#"&gt;Битая ссылка&lt;/a&gt;\n// в этом случае символ "#" добавляется к URL в адресной строке\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/void" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 97 --\x3e\n<section id="95">\n<h3>95. JavaScript - это компилируемый или интерпретируемый язык программирования?</h3>\n<p>Сам по себе JavaScript - это интерпретируемый язык программирования. Движок (engine) разбирает код, интерпретирует каждую строку и выполняет ее. Однако, в современных браузерах используется технология под названием "компиляция на лету" (just-in-time, JIT compilation), когда код компилируется (оптимизируется) перед выполнением. Это увеличивает время подготовки к выполнению кода, но существенно ускоряет само выполнение. Например, в V8, движке, используемом в Chrome и Node.js, для разбора кода применяется интерпретатор Ignition, а для оптимизации кода - компилятор TurboFan.</p>\n<nav>\n<a href="https://learn.javascript.ru/intro" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 98 --\x3e\n<section id="96">\n<h3>96. Чувствителен ли JavaScript к регистру?</h3>\n<p>Да, JavaScript чувствителен к регистру. Поэтому ключевые слова, названия переменных, функций и объектов должны быть идентичными при их использовании. Например, const somename и const someName - это разные переменные, typeof(1) - number, а typeOf 1 - ReferenceError: typeOf is not defined.</p>\n<nav>\n<a href="https://learn.javascript.ru/intro" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 99 --\x3e\n<section id="97">\n<h3>97. Связаны ли Java и JavaScript?</h3>\n<p>Нет, это два разных языка программирования. Однако, они оба относятся к объектно-ориентированным языкам и, как и множество других языков, используют похожий синтаксис (if, else, for, switch, break, continue и т.д.). По сути, Java в JavaScript - это маркетинговый ход.</p>\n<nav>\n<a href="https://learn.javascript.ru/intro" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 100 --\x3e\n<section id="98">\n<h3>98. Что такое событие (event)?</h3>\n<p>Событие - это реакция браузера на определенное действие. Таким действием может быть действие пользователя, например, нажатие кнопки или ввод текста, загрузка страницы, получение ответа на запрос и т.д. (действия, приводящие к возникновению событий, не обязательно зависят от пользователя). События регистрируются с целью их дальнейшей обработки.</p>\n<pre><code class="lang-js">\nbutton.onclick = () =&gt; alert(\'Привет!\')\n\ninput.addEventListener(\'change\', function() {\n    p.textContent = this.value\n})\n\nwindow.onload = () =&gt; console.log(\'Страница полностью загружена\')\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Event" target="_blank">MDN</a>\n<a href="https://learn.javascript.ru/introduction-browser-events#event-object" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 101 --\x3e\n<section id="99">\n<h3>99. Кто придумал JavaScript?</h3>\n<p>JavaScript был создан <a href="https://twitter.com/BrendanEich" target="_blank">Бренданом Эйхом</a> во время его работы в Netscape Communications. Первоначально язык назывался Mocha, затем был переименован в LiveScript и предназначался как для программирования на стороне клиента, так и для программирования на стороне сервера (там он должен был называться LiveWire).</p>\n<nav>\n<a href="https://learn.javascript.ru/intro" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 102 --\x3e\n<section id="100">\n<h3>100. Для чего используется preventDefault()?</h3>\n<p>Данный метод отключает стандартную обработку событий браузером. Например, с его помощью можно предотвратить отправку формы или открытие новой страницы при клике по ссылке.</p>\n<pre><code class="lang-js">\nlink.addEventListener(\'click\', event =&gt; {\n    event.preventDefault()\n    // код\n})\n</code></pre>\n<p>Обратите внимание: не все события отменяемы.</p>\n<nav>\n<a href="https://learn.javascript.ru/default-browser-action" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Event/preventDefault" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 103 --\x3e\n<section id="101">\n<h3>101. Для чего используется stopPropagation()?</h3>\n<p>Данный метод используется для предотвращения всплытия или поднятия события вверх по цепочке из предков целевого элемента. Другими словами, он прекращает передачу события от целевого элемента к его предкам. Рассмотрим пример:</p>\n<pre><code class="lang-js">\n&lt;div onclick="f2()"&gt;\n    &lt;div onclick="f1()"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\nfunction f1(event) {\n    event.stopPropagation()\n    console.log(\'Внутренний контейнер\')\n}\n\nfunction f2() {\n    console.log(\'Внешний контейнер\')\n}\n</code></pre>\n<p>При клике по вложенному контейнеру в консоль выводится сообщение "Внутренний контейнер". Если убрать event.stopPropagation(), то при клике по вложенному контейнеру, в консоль будут выведены оба сообщения.</p>\n<nav>\n<a href="https://learn.javascript.ru/bubbling-and-capturing" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Event/stopPropagation" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 104 --\x3e\n<section id="102">\n<h3>102. Что делает инструкция return false?</h3>\n<p>Данная инструкция используется в обработчиках событий для:</p>\n<ul>\n<li>Отмены стандартного поведения браузера</li>\n<li>Предотвращения распространения события по DOM</li>\n<li>Остановки выполнения колбэка и возврата управления вызвавшей его функции</li>\n</ul>\n<p>Обратите внимание: без указания возвращаемого значения оператор return возвращает undefined.</p>\n<nav>\n<a href="https://learn.javascript.ru/default-browser-action" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/return" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 105 --\x3e\n<section id="103">\n<h3>103. Что такое BOM?</h3>\n<p>BOM или (Browser Object Model - объектная модель браузера) позволяет JavaScript взаимодействовать с браузером. Данная модель включает в себя такие объекты, как navigator, location, history, screen, XMLHttpRequest и т.п. Другими словами, BOM - это дополнительные объекты, предоставляемые браузером, чтобы работать со всем, кроме документа.</p>\n<p>Обратите внимание: BOM не стандартизирована, поэтому ее реализация может отличаться в разных браузерах.</p>\n<img src="img/4.png" alt="4">\n<nav>\n<a href="https://learn.javascript.ru/browser-environment" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 106 --\x3e\n<section id="104">\n<h3>104. Для чего используется setTimeout()?</h3>\n<p>Данный метод используется для отложенного выполнения задачи. Другими словами, он позволяет запустить выполнение функции или вычисление выражения через определенное время (в миллисекундах). В следующем примере мы выводим сообщение в консоль через 2 секунды:</p>\n<pre><code class="lang-js">\nsetTimeout(() =&gt; console.log(\'Привет!\'), 2000)\n\n// во избежание утечек памяти, рекомендуется делать так\nconst timer = setTimeout(() =&gt; {\n    console.log(\'Привет!\')\n    clearTimeout(timer)\n}, 2000)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/settimeout-setinterval" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 107 --\x3e\n<section id="105">\n<h3>105. Для чего используется setInterval()?</h3>\n<p>Данный метод используется для периодического выполнения задачи. Другим словами, он позволяет запускать выполнение функции или вычисление выражения через определенный промежуток времени (в миллисекундах). В следующем примере мы выводим сообщение в консоль каждые 2 секунды:</p>\n<pre><code class="lang-js">\nsetInterval(() =&gt; console.log(\'Привет!\'), 2000)\n\n// во избежание утечек памяти, не забывайте отключать таймер\n// после достижения поставленной цели\nlet i = 0\nconst timer = setInterval(() =&gt; {\n    console.log(\'Привет!\')\n    i++\n\n    if (i == 2) {\n        clearInterval(timer)\n    }\n}, 2000)\n</code></pre>\n<p>Во втором примере сообщение "Привет!" выведется в консоль два раза, после чего таймер будет остановлен</p>\n<nav>\n<a href="https://learn.javascript.ru/settimeout-setinterval" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 108 --\x3e\n<section id="106">\n<h3>106. Почему JavaScript называют однопоточным (single threated)?</h3>\n<p>JavaScript является однопоточным или синхронным языком программирования. Это означает, что в один момент времени может выполняться только одна задача. Если задача является сложной, ее выполнение может занять продолжительное время и все это время основной поток выполнения кода будет заблокирован. Блокировка потока, в свою очередь, означает отсутствие интерактивности на странице. Браузер перестает реагировать на действия пользователя и другие события. Для решения данной проблемы применяются колбэки, промисы, async/await, воркеры и другие инструменты для работы с асинхронным кодом. В JavaScript в отличие, например, от Java, Go или C++ нет возможности создавать дополнительные потоки или процессы.</p>\n<nav>\n<a href="https://learn.javascript.ru/intro" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript" target="_blank">MDN</a>\n</nav>\n</section>\n\n<section id="107">\n<h3>107. Что такое делегирование событий (event delegation)?</h3>\n<p>Делегирование событий - это техника, при которой событие регистрируется на родительском элементе для обработки событий, вызываемых дочерними элементами.</p>\n<p>Часто применяется для обработки нажатия кнопок в группирующем контейнере или изменения полей для ввода текста в формах, например:</p>\n<pre><code class="lang-js">\n&lt;form>\n    &lt;input type="text" class="first-input">\n    &lt;input type="text" class="second-input">\n&lt;/form>\n\n&lt;div>\n    &lt;button class="first-button">click&lt;/button>\n    &lt;button class="second-button">click&lt;/button>\n&lt;/div>\n\nconst form = document.querySelector(\'form\')\nconst buttons = document.querySelector(\'div\')\n\nform.addEventListener(\'input\', event =&gt; {\n    console.log(event.target.className)\n})\n\nbuttons.addEventListener(\'click\', event =&gt; {\n    console.log(event.target.className)\n})\n</code></pre>\n<p>В приведенном примере вместо регистрации обработчиков на дочерних элементах, мы регистрируем их на родительских элементах. Ввод текста в поле или нажатие кнопки приводят к выводу названия класса соответствующего элемента в консоль.</p>\n<nav>\n<a href="https://learn.javascript.ru/event-delegation" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 110 --\x3e\n<section id="108">\n<h3>108. Что такое ECMAScript?</h3>\n<p>ECMAScript - это язык программирования, лежащий в основе JavaScript. Это своего рода шаблон или схема, по которой "строится" JavaScript. ECMAScript стандартизирован в спецификации ECMA-262 организацией по стандартам Ecma International.</p>\n<nav>\n<a href="https://learn.javascript.ru/manuals-specifications" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Language_Resources" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 111 --\x3e\n<section id="109">\n<h3>109. Назовите особенности синтаксиса JSON</h3>\n<p>Синтаксис JSON имеет следующие особенности:</p>\n<ul>\n<li>Данные представляют собой пары ключ/значение</li>\n<li>Ключ и значение оборачиваются в двойные кавычки, кроме случаев, когда значение является числом ("key": "value")</li>\n<li>Данные разделяются запятыми</li>\n<li>Объекты оборачиваются в фигурные скобки</li>\n<li>Массивы - в квадратные</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/json" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 112 --\x3e\n<section id="110">\n<h3>110. Что делает JSON.stringify()?</h3>\n<p>При отправке данных на сервер, они должны иметь специальный строковый формат. Для преобразования объекта в строку в формате JSON используется метод JSON.stringify():</p>\n<pre><code class="lang-js">\nconst user = { name: \'Ванька\', age: 30 }\nconst str = JSON.stringify(user)\nconsole.log(str) // {"name":"Ванька","age":30}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/json" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 113 --\x3e\n<section id="111">\n<h3>111. Что делает JSON.parse()?</h3>\n<p>При получении данных от сервера, они имеют специальный строковый формат. Для преобразования этих данных в JavaScript объект используется метод JSON.parse():</p>\n<pre><code class="lang-js">\nconst str = { "name":"Ванька","age":30 }\nconst user = JSON.parse(str)\nconsole.log(user) // {name: "Ванька", age: 30}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/json" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 114 --\x3e\n<section id="112">\n<h3>112. Зачем нужен JSON?</h3>\n<p>При обмене данными между клиентом и сервером, эти данные могут быть только строками. Поскольку JSON - это текст, он прекрасно для этого подходит. Также он может использоваться как формат для данных любым языком программирования, наряду с другими форматами, такими как XML или Protobuf.</p>\n<nav>\n<a href="https://learn.javascript.ru/json" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 115 --\x3e\n<section id="113">\n<h3>113. Что такое PWA (Progressive Web Application - прогрессивное веб-приложение)?</h3>\n<p>Если кратко, то PWA - это веб-сайты, которые ведут себя подобно нативным приложениям. Они могут быть установлены на телефон или компьютер, а также, как правило, работают в оффлайне. Для последнего используются сервис-воркеры и интерфейс кэширования. Преимуществом PWA перед мобильными приложениями является их размер и относительная легкость разработки. Также не нужно тратить ресурсы на создание двух приложений для одного сайта - веб и мобильного. При этом сохраняется хороший пользовательский опыт.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/Progressive_web_apps" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 116 --\x3e\n<section id="114">\n<h3>114. Для чего используется clearTimeout()?</h3>\n<p>Данный метод используется для остановки таймера, запущенного с помощью setTimeout(). Для этого идентификатор таймера записывается в переменную, которая затем передается clearTimeout() в качестве аргумента.</p>\n<pre><code class="lang-js">\nconst timer = setTimeout(() =&gt; {\n    console.log(\'Привет!\')\n    clearTimeout(timer)\n}, 2000)\n</code></pre>\n<p>В приведенном примере через две секунды в консоль выводится сообщение "Привет!", после чего таймер останавливается. Это делается для того, чтобы сборщик мусора мог удалить выполненный таймер.</p>\n<nav>\n<a href="https://learn.javascript.ru/settimeout-setinterval" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 117 --\x3e\n<section id="115">\n<h3>115. Для чего используется clearInterval()?</h3>\n<p>Данный метод используется для остановки таймера, запущенного с помощью setInterval(). Для этого идентификатор таймера записывается в переменную, которая затем передается clearInterval() в качестве аргумента.</p>\n<pre><code class="lang-js">\nlet i = 1\nconst timer = setInterval(() =&gt; {\n    console.log(i)\n    i++\n\n    if (i === 3) clearInterval(timer)\n}, 1000)\n</code></pre>\n<p>В приведенном примере в консоль каждую секунду выводится значение переменной i, которое каждый раз увеличивается на 1 (1, 2). Когда значение i становится равным 3, таймер останавливается.</p>\n<nav>\n<a href="https://learn.javascript.ru/settimeout-setinterval" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 118 --\x3e\n<section id="116">\n<h3>116. Как выполнить перенаправление?</h3>\n<p>Для этого можно использовать свойство location объекта window:</p>\n<pre><code class="lang-js">\nlocation.href = \'newPage.html\'\n// или\nlocation.replace(\'newPage.html\')\n// или\nlocation.assign(\'newPage.html\')\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Location" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 119 --\x3e\n<section id="117">\n<h3>117. Как проверить, существует ли подстрока в строке?</h3>\n<p>Существует, как минимум, три способа это сделать.</p>\n<p>String.prototype.includes()</p>\n<pre><code class="lang-js">\nconst mainStr = \'hello\'\nconst subStr = \'hel\'\nmainStr.includes(subStr) // true\n</code></pre>\n<p>String.prototype.indexOf()</p>\n<pre><code class="lang-js">\nconst mainStr = \'hello\'\nconst subStr = \'hel\'\nmainStr.indexOf(subStr) !== -1 // true\n</code></pre>\n<p>RegExp</p>\n<pre><code class="lang-js">\nconst mainStr = \'hello\'\nconst regex = /hel/\nregex.test(mainStr) // true\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/string" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank">MDN - includes</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf" target="_blank">MDN - indexOf</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank">MDN - test</a>\n</nav>\n</section>\n\n\x3c!-- 120 --\x3e\n<section id="118">\n<h3>118. Как проверить корректность адреса электронной почты?</h3>\n<p>Это можно сделать средствами HTML, установив тип поля для ввода в значение email (&lt;input type="email"&gt;). Однако, данный способ считается не очень надежным. Поэтому, обычно, email валидируется с помощью регулярного выражения. Это рекомендуется делать на стороне сервера, поскольку на клиенте может быть отключен JavaScript:</p>\n<pre><code class="lang-js">\nconst validateEmail = email =&gt;\n    /S+@S+.S+/\n        .test(email.toString()\n        .toLowerCase())\nconst email = \'myemail@example.com\'\nvalidateEmail(email) // true\n</code></pre>\n<p>В приведенном примере используется одно из самых простых регулярных выражений для валидации адреса электронной почты. Более надежное выражение выглядит так (RFC 2822): [a-z0-9!#&#36;%&amp;\'*+/=?^_`{|}~-]+(?:.[a-z0-9!#&#36;%&amp;\'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?</p>\n</section>\n\n\x3c!-- 121 --\x3e\n<section id="119">\n<h3>119. Как получить текущий URL?</h3>\n<p>Для этого можно использовать свойство location объекта window или свойство URL объекта document:</p>\n<pre><code class="lang-js">\nconsole.log(\'Текущий URL\', location.href)\nconsole.log(\'Текущий URL\', document.URL) // в Chrome в пустой вкладке получаем "Текущий URL chrome-search://local-ntp/local-ntp.html"\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Location" target="_blank">MDN - location</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/URL" target="_blank">MDN - document.URL</a>\n</nav>\n</section>\n\n\x3c!-- 122 --\x3e\n<section id="120">\n<h3>120. Какие свойства имеет объект location?</h3>\n<p>Свойства объекта location могут использоваться для получения частей URL текущей страницы:</p>\n<ul>\n<li>href - полный URL</li>\n<li>origin - протокол, хост и порт (источник, используется в Политике общего происхождения (SOP) и Совместном использовании ресурсов (CORS))</li>\n<li>protocol</li>\n<li>host - хост и порт</li>\n<li>hostname - хост</li>\n<li>port</li>\n<li>pathname - путь</li>\n<li>search - строка запроса после ?</li>\n<li>hash - строка запроса после # (якоря)</li>\n<li>username - имя пользователя перед доменом</li>\n<li>password - пароль перед доменом</li>\n</ul>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Location" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 123 --\x3e\n<section id="121">\n<h3>121. Как получить строку запроса?</h3>\n<p>Для этого можно использовать конструктор URL:</p>\n<pre><code class="lang-js">\nconst url = new URL(\'https://example.com?foo=1&amp;bar=2\')\nconsole.log(url.search) // ?foo=1&amp;bar=2\nconsole.log(url.searchParams.get(\'foo\')) // 1\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Document/URL" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 124 --\x3e\n<section id="122">\n<h3>122. Как проверить, существует ли свойство в объекте?</h3>\n<p>Для этого существует, как минимум, три способа.</p>\n<p>Оператор in</p>\n<pre><code class="lang-js">\nconst user = { name: \'Ванька\' }\nconsole.log(\'name\' in user) // true\nconsole.log(!(\'age\' in user)) // true\n</code></pre>\n<p>Метод hasOwnProperty()</p>\n<pre><code class="lang-js">\nconst user = { name: \'Ванька\' }\nconsole.log(user.hasOwnProperty(\'name\')) // true\nconsole.log(!user.hasOwnProperty(\'age\')) // true\n</code></pre>\n<p>Сравнение с undefined</p>\n<pre><code class="lang-js">\nconst user = { name: \'Ванька\' }\nconsole.log(user.name !== undefined) // true\nconsole.log(user.age === undefined) // true\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank">MDN - for...in</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank">MDN - hasOwnProperty</a>\n</nav>\n</section>\n\n\x3c!-- 125 --\x3e\n<section id="123">\n<h3>123. Как перебрать перечисляемые свойства объекта?</h3>\n<p>Для этого можно использовать цикл for...in совместно с методом hasOwnProperty() для исключения унаследованных свойств.</p>\n<pre><code class="lang-js">\nconst user = {\n    name: \'Ванька\',\n    age: 30\n}\n\nfor (key in user) {\n    if (user.hasOwnProperty(key)) {\n        console.log(`&#36;{key}: &#36;{user[key]}`) // name: Ванька age: 30\n    }\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 126 --\x3e\n<section id="124">\n<h3>124. Как проверить, что объект является пустым?</h3>\n<p>Для этого существует, как минимум, три способа.</p>\n<p>Метод Object.entries()</p>\n<pre><code class="lang-js">\nconst obj = {}\nconsole.log(Object.entries(obj).length === 0) // true\n// для исключения из проверки объекта Date\nconst obj2 = new Date()\nconsole.log(Object.entries(obj2).length === 0 &amp;&amp; obj2.constructor === Object) // false\n</code></pre>\n<p>Метод Object.keys()</p>\n<pre><code class="lang-js">\nconst obj = {}\nconsole.log(Object.keys(obj).length === 0) // true\n// для исключения из проверки объекта Date\nconst obj2 = new Date()\nconsole.log(Object.keys(obj2).length === 0 &amp;&amp; obj2.constructor === Object) // false\n</code></pre>\n<p>Цикл for...in и метод Object.hasOwnProperty()</p>\n<pre><code class="lang-js">\nconst obj = {}\nconst obj2 = {key: \'value\'}\n\nconst isEmpty = obj =&gt; {\n    for (key in obj) {\n        if (obj.hasOwnProperty(key)) return false\n    }\n    return true\n}\n\nconsole.log(isEmpty(obj)) // true\nconsole.log(isEmpty(obj2)) // false\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR - Объекты</a>\n<a href="https://learn.javascript.ru/keys-values-entries" target="_blank">JSR - Object.keys, values, entries</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">MDN - Object.entries</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">MDN - Object.keys</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank">MDN - for...in</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank">MDN - Object.hasOwnProperty</a>\n</nav>\n</section>\n\n\x3c!-- 127 --\x3e\n<section id="125">\n<h3>125. Что такое объект arguments?</h3>\n<p>arguments - это массивоподобный объект (псевдомассив), содержащий переданные функции аргументы:</p>\n<pre><code class="lang-js">\nfunction sum () {\n    let total = 0\n    for (let i = 0; i &lt; arguments.length; i++) {\n        total += arguments[i]\n    }\n    return total\n\n    // или\n    let total = 0\n    for (const i of arguments) {\n        total += i\n    }\n    return total\n\n    // или\n    return Array.from(arguments).reduce((acc, cur) =&gt; acc + cur)\n\n}\n\nsum(1, 2, 3) // 6\n</code></pre>\n<p>Обратите внимание, что стрелочные функции не имеют arguments. Вместо arguments рекомендуется использовать оператор rest ... (прочие параметры), который работает как в обычных, так и в стрелочных функциях:</p>\n<pre><code class="lang-js">\nconst sum = (...rest) =&gt; rest.reduce((acc, cur) =&gt; acc + cur)\n\nsum(1, 2, 3) // 6\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/arguments-pseudoarray" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 128 --\x3e\n<section id="126">\n<h3>126. Как сделать первую букву строки заглавной?</h3>\n<p>Это можно сделать с помощью методов charAt(), toUpperCase() и slice():</p>\n<pre><code class="lang-js">\nString.prototype.capitilize = function () {\n    return this.charAt(0).toUpperCase() + this.slice(1)\n}\n\nconsole.log(\'hello\'.capitilize()) // Hello\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/string" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/charAt" target="_blank">MDN - charAt</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase" target="_blank">MDN - toUpperCase</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/slice" target="_blank">MDN - slice</a>\n</nav>\n</section>\n\n\x3c!-- 129 --\x3e\n<section id="127">\n<h3>127. Как получить текущую дату?</h3>\n<p>Это можно сделать с помощью объекта Date или конструктора Intl.DateTimeFormat:</p>\n<pre><code class="lang-js">\nconsole.log(new Date().toLocaleDateString()) // 02.09.2020\n\nconsole.log(new Intl.DateTimeFormat(\n    \'ru-Ru\',\n    {\n        weekday: \'long\',\n        day: \'numeric\',\n        month: \'long\',\n        year: \'numeric\'\n    }\n).format(new Date())) // среда, 2 сентября 2020 г.\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/date" target="_blank">JSR - Date</a>\n<a href="https://learn.javascript.ru/intl" target="_blank">JSR = Intl</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank">MDN - Date</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">MDN - Intl.DateTimeFormat</a>\n</nav>\n</section>\n\n\x3c!-- 130 --\x3e\n<section id="128">\n<h3>128. Как сравнить два объекта Date?</h3>\n<p>Для этого следует сравнивать не сами объекты, а, например, значения, возвращаемые методом getTime():</p>\n<pre><code class="lang-js">\nconst d1 = new Date()\nconst d2 = new Date(d1)\n\nconsole.log(d1.getTime() === d2.getTime()) // true\nconsole.log(d1 === d2) // false\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/date" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 131 --\x3e\n<section id="129">\n<h3>129. Как проверить, что строка начинается с другой строки?</h3>\n<p>Для этого можно использовать встроенный метод startsWith():</p>\n<pre><code class="lang-js">\nconsole.log(\'Good morning\'.startsWith(\'Good\')) // true\nconsole.log(\'Good morning\'.startsWith(\'morning\')) // false\n</code></pre>\n<p>По данным <a href="https://caniuse.com/#feat=mdn-javascript_builtins_string_startswith" target="_blank">CanIUse</a> данный метод поддерживает почти 94% браузеров</p>\n<nav>\n<a href="https://learn.javascript.ru/string" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 132 --\x3e\n<section id="130">\n<h3>130. Как удалить проблемы в строке?</h3>\n<p>Для этого можно использовать встроенные методы trimStart() (начало строки), trimEnd() (конец строки) и trim() (начало и конец строки):</p>\n<pre><code class="lang-js">\nconsole.log(\'  hello world   \'.trim()) // hello world\n</code></pre>\n<p>trim не работает для пробелов между словами. В этом случае можно воспользоваться методом replace() и регулярным выражением:</p>\n<pre><code class="lang-js">\nconsole.log(\'hello   world\'.replace(/s+/, \' \')) // hello world\n// можно уточнить количество пробелов\nconsole.log(\'hello   world\'.replace(/s{2,}/, \' \')) // hello world\nconsole.log(\'key   value\'.replace(/s{2,}/, \' -&gt; \')) // key -&gt; value\n</code></pre>\n<p>По данным <a href="https://caniuse.com/#feat=mdn-javascript_builtins_string_trimstart" target="_blank">CanIUse</a> методы trimStart() и trimEnd() поддерживает 93% браузеров.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 133 --\x3e\n<section id="131">\n<h3>131. Как добавить новое свойство в объект?</h3>\n<p>Существует два способа это сделать. Предположим, что у нас есть такой объект:</p>\n<pre><code class="lang-js">\nconst obj = {\n    name: \'Ванька\',\n    age: 30\n}\n</code></pre>\n<p>Мы можем добавить в него новое свойство, использую либо точечную, либо скобочную нотацию:</p>\n<pre><code class="lang-js">\nobj.job = \'разработчик\'\nobj[\'job\'] = \'разработчик\'\n</code></pre>\n<p>Одним из отличий указанных методов является то, что при использовании скобочной нотации добавляемый ключ может быть числом:</p>\n<pre><code class="lang-js">\nconst obj = {}\nobj[1] = \'один\'\nconsole.log(obj) // { 1: \'один\' }\nobj.2 = \'два\' // SyntaxError: Unexpected number\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 134 --\x3e\n<section id="132">\n<h3>132. Является ли выражение !-- специальным оператором?</h3>\n<p>Нет, не является. Это комбинация двух операторов: оператора ! (логическое не) и оператора -- (декремент). Если использовать указанное выражение с каким-либо значением, то сначала это значение будет уменьшено на единицу, затем преобразовано в логический тип и инвертировано:</p>\n<pre><code class="lang-js">\nconst fun = val =&gt; !--val\nconst a = 1\nconst b = 2\nconsole.log(fun(a)) // !0 -&gt; not false -&gt; true\nconsole.log(fun(b)) // !1 -&gt; not true -&gt; false\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/operators" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_NOT" target="_blank">MDN - Logical NOT</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Decrement" target="_blank">MDN - Decrement</a>\n</nav>\n</section>\n\n\x3c!-- 135 --\x3e\n<section id="133">\n<h3>133. Как присвоить переменной значение по умолчанию?</h3>\n<p>Для этого можно использовать оператор || (логическое или):</p>\n<pre><code class="lang-js">\nconst a = b || \'default\'\n</code></pre>\n<p>В данном случае переменной a будет присвоено значение default в случае, если значение переменной b будет ложным (false, undefined, null, NaN, 0, \'\').</p>\n<p>Если речь идет о стандартных значениях параметров функции, то их можно присвоить следующим образом:</p>\n<pre><code class="lang-js">\nconst greet = (name = \'незнакомец\') =&gt; `Привет, &#36;{name}!`\nconsole.log(greet(\'Ванька\')) // Привет, Ванька!\nconsole.log(greet()) // Привет, незнакомец!\n</code></pre>\n<p>Более того, последующие параметры могут использовать значения предыдущих в качестве стандартных значений:</p>\n<pre><code class="lang-js">\nconst sum = (a = 1, b = a + 2) =&gt; a + b\nconsole.log(sum()) // 4\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/operators" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_OR" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 136 --\x3e\n<section id="134">\n<h3>134. Как создать многострочную строку?</h3>\n<p>Раньше это делали примерно так (конкатенация и управляющие символы переноса строки):</p>\n<pre><code class="lang-js">\nconst str =\n    \'Аз есмь\' + \' \' +\n    \'очень длинная\' + \' \' +\n    \'строка!\'\n\n// или\nconst str = \'Аз есмь a\n очень длинная\n строка!\'\nconsole.log(str)\n/*\n    Аз есмь\n    очень длинная\n    строка!\n*/\n</code></pre>\n<p>Сейчас это делают так (шаблонный литерал):</p>\n<pre><code class="lang-js">\nconst str =\n    `Аз есмь\n    очень длинная\n    строка!`\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/string" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/template_strings" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 137 --\x3e\n<section id="135">\n<h3>135. Можем ли мы добавлять свойства функциям?</h3>\n<p>Поскольку функции - это тоже объекты, мы вполне можем добавлять им свойства. Значением свойства функции может быть другая функция:</p>\n<pre><code class="lang-js">\nfunction someFun () {}\nsomeFun.somePropName = \'somePropValue\'\n\nconsole.log(someFun.somePropName) // somePropValue\n// дефолтное свойство\nconsole.log(someFun.name) // someFun\n\nconst sum = (x, y) =&gt; x + y\nconsole.log(sum(1, 2)) // 3\n\nsum.curry = x =&gt; y =&gt; x + y\nconsole.log(sum.curry(1)(2)) // 3\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/function-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 138 --\x3e\n<section id="136">\n<h3>136. Как узнать, сколько аргументов ожидает получить функция?</h3>\n<p>Для этого можно использовать свойство length:</p>\n<pre><code class="lang-js">\nconst sum = (a, b, c) =&gt; +a + +b + +c\nconsole.log(sum(1, \'1\', true)) // 3\nconsole.log(sum(0, \'\', [])) // 0\n\nconsole.log(sum.length) // 3\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/length" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 139 --\x3e\n<section id="137">\n<h3>137. Что такое полифил (polyfill)?</h3>\n<p>Полифилы используются для обеспечения работы современного JavaScript-кода в старых браузерах. Это делается за счет реализации новых возможностей языка на старом синтаксисе. Сам процесс преобразования нового кода в старый называется транспиляцией. Самым популярным транспилятором JavaScript-кода является Babel.</p>\n<p>Например, одной из последних возможностей JavaScript является метод Promise.allSettled(), который, в отличие от Promise.all(), не завершается при отклонении любого из переданных ему промисов.</p>\n<p>Однако, на сегодняшний день его поддержка браузерами по данным <a href="https://caniuse.com/#feat=mdn-javascript_builtins_promise_allsettled" target="_blank">CanIUse</a> составляет 80%, поэтому нужен полифил:</p>\n<pre><code class="lang-js">\nconst promise1 = Promise.resolve(\'promise1\')\nconst promise2 = Promise.reject(\'promise2\')\nconst promise3 = Promise.resolve(\'promise3\')\n\n// вот как выглядит встроенный Promise.allSettled()\nPromise\n    .allSettled([promise1, promise2, promise3])\n    .then(console.log)\n/*\n    [\n        {status: "fulfilled", value: "promise1"},\n        {status: "rejected", reason: "promise2"},\n        {status: "fulfilled", value: "promise3"},\n    ]\n*/\n\n// а вот его полифил\n// поддержка Promise.all() = 94%\nconst allSettled = promises =&gt; {\n    const wrappedPromises = promises\n        .map(p =&gt; Promise.resolve(p)\n        .then(\n            val =&gt; ({\n                status: \'fulfilled\',\n                value: val\n            }),\n            err =&gt; ({\n                status: \'rejected\',\n                reason: err\n            })))\n    return Promise.all(wrappedPromises)\n}\nallSettled([promise1,promise2,promise3])\n    .then(console.log)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/polyfills" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Glossary/Polyfill" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 140 --\x3e\n<section id="138">\n<h3>138. Для чего используются операторы continue и break?</h3>\n<p>Оператор break используется для выхода из цикла. После остановки итерации код выполняется дальше:</p>\n<pre><code class="lang-js">\nconst obj = {\n    1: \'Everything\',\n    2: \'is\',\n    3: \'impossible\'\n}\n\nfor (key in obj) {\n    if (obj[key] === \'impossible\') break\n\n    console.log(obj[key]) // Everything is\n}\n\nconsole.log(\'possible\') // possible\n</code></pre>\n<p>Оператор continue используется для пропуска итерации:</p>\n<pre><code class="lang-js">\nconst obj = {\n    1: \'Everything\',\n    2: \'is\',\n    3: \'impossible\',\n    4: \'possible\'\n}\n\nfor (key in obj) {\n    if (obj[key] === \'impossible\') continue\n\n    console.log(obj[key]) // Everything is possible\n}\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/break" target="_blank">MDN - break</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/continue" target="_blank">MDN - continue</a>\n</nav>\n</section>\n\n\x3c!-- 141 --\x3e\n<section id="139">\n<h3>139. Что такое метка (label)?</h3>\n<p>Метки позволяют именовать циклы и блоки кода. Они могут использоваться, например, для выхода из цикла или в качестве условия выполнения кода:</p>\n<pre><code class="lang-js">\nloop1:\nfor (let i = 0; i &lt; 3; i++) {\n    loop2:\n    for (let j = 0; j &lt; 3; j++) {\n        if (i === j) continue loop1\n\n        console.log(`i = &#36;{i}, j = &#36;{j}`)\n    }\n}\n\n/*\n    i = 1, j = 0\n    i = 2, j = 0\n    i = 2, j = 1\n*/\n</code></pre>\n<p>Использование меток считается плохой практикой.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/label" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 142 --\x3e\n<section id="140">\n<h3>140. В чем заключаются преимущества объявления переменных в начале кода?</h3>\n<p>Рекомендуется объявлять переменные в начала каждого скрипта или фукнции. Это дает следующие преимущества:</p>\n<ul>\n<li>Делает код чистым</li>\n<li>Все переменные находятся в одном месте</li>\n<li>Позволяет избежать случайного создания глобальных переменных</li>\n<li>Предотвращает нежелательное переопределение переменных</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/variables" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 143 --\x3e\n<section id="141">\n<h3>141. В чем заключаются преимущества инициализации переменной при объявлении?</h3>\n<p>Рекомендуется инициализировать все переменные в момент объявления. Это дает следующие преимущества:</p>\n<ul>\n<li>Делает код чистым</li>\n<li>Переменные и их значения находятся в одном месте</li>\n<li>Предотвращает присвоение неинициализированным переменным значения undefined</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/variables" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 144 --\x3e\n<section id="142">\n<h3>142. Назовите основные рекомендации по созданию объекта</h3>\n<p>Для создания объекта вместо конструктора объекта new Object() рекмондуется использовать скобочную нотацию {}. Также в зависимости от типа значения, рекомендуется использовать следующее:</p>\n<ul>\n<li>строку, например, \'\' вместо new String()</li>\n<li>число, например, 0 вместо new Number()</li>\n<li>логическое значение, например, false вместо new Boolean()</li>\n<li>[] вместо new Array()</li>\n<li>// вместо new RegExp()</li>\n<li>function (){} вместо new Function()</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 145 --\x3e\n<section id="143">\n<h3>143. Как определить массив в формате JSON?</h3>\n<p>JSON-массив представляет собой массив JSON-объектов, например:</p>\n<pre><code class="lang-js">\n[\n    { "name": "Ванька", "age": 30 },\n    { "name": "Петька", "age": 20 }\n]\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/json" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 146 --\x3e\n<section id="144">\n<h3>144. Как реализовать функцию, возвращающую случайное целое число в заданном диапазоне?</h3>\n<p>Такую функцию можно реализовать с помощью методов Math.random() и Math.floor() объекта Math:</p>\n<pre><code class="lang-js">\nconst getRandomInteger = (min, max) =&gt; Math.floor(min + Math.random() * (max + 1 - min))\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/number" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/random" target="_blank">MDN - Math.random()</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/floor" target="_blank">MDN - Math.floor()</a>\n</nav>\n</section>\n\n\x3c!-- 147 --\x3e\n<section id="145">\n<h3>145. Что такое tree shaking (встряхивание дерева)?</h3>\n<p>Tree shaking - это удаление кода неиспользуемых модулей. Такие модули не включаются в окончательную сборку (бандл). Для того, чтобы сборщик модулей (бандлер) мог определить, какие модули используются, а какие нет, структура программы должна быть основана на ES6 модулях. Данная техника была популяризована бандлером Rollup.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Glossary/Tree_shaking" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 148 --\x3e\n<section id="146">\n<h3>146. Для чего используется tree shaking (встряхивание дерева)?</h3>\n<p>Tree shaking может существенно уменьшить размер сборки (бандла) за счет удаления из нее кода неиспользуемых модулей. Чем меньше размер сборки, тем выше производительность приложения. Tree shaking реализован в таких сборщиках модулей, как Rollup и Webpack.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Glossary/Tree_shaking" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 150 --\x3e\n<section id="147">\n<h3>147. Что такое регулярное выражение?</h3>\n<p>Регулярное выражение - это последовательность символов, формирующая поисковый шаблон. Этот шаблон может использоваться для поиска данных в тексте, например, подстроки в строке. Регулярные выражения широко используются многими языками программирования для операций поиска и замены текста. Общий шаблон регулярного выражения выглядит так:</p>\n<pre><code class="lang-js">\n/шаблон/модификатор\n</code></pre>\n<p>Пример:</p>\n<pre><code class="lang-js">\nconst regex = /java/i\nconst str = \'JavaScript\'\nconsole.log(regex.test(str)) // true\n</code></pre>\n<p>Также для создания регулярного выражения можно использовать конструктор RegExp:</p>\n<pre><code class="lang-js">\nconst regex = new RegExp(\'java\', \'i\')\nconst str = \'JavaScript\'\nconsole.log(regex.test(str)) // true\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/regexp-methods" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 151 --\x3e\n<section id="148">\n<h3>148. Какие методы используются в регулярных выражениях?</h3>\n<p>В регулярных выражениях используется два основных метода: exec() и test().</p>\n<p>Метод exec() ищет совпадение с регулярным выражением в переданной ему в качестве аргумента строке. Поведение данного метода зависит от того, имеет ли регулярное выражение флаг g. Если нет, то возвращается первое совпадение. Если флаг g есть, то:</p>\n<ul>\n<li>Вызов exec() возвращает первое совпадение и запоминает позицию после него в свойстве lastIndex.</li>\n<li>Следующий такой вызов начинает поиск с позиции lastIndex, возвращает следующее совпадение и запоминает позицию после него в lastIndex.</li>\n<li>Если совпадений больше нет, то exec() возвращает null, а для lastIndex устанавливается значение 0.</li>\n</ul>\n<pre><code class="lang-js">\nconst str = \'Java и JavaScript - разные языки программирования\'\nconst regex = /Java/g\n\nlet result\nwhile (result = regex.exec(str)) {\n    console.log(\n        `Найдено &#36;{result[0]} на позиции &#36;{result.index}`\n    )\n}\n/*\n    Найдено Java на позиции 0\n    Найдено Java на позиции 7\n*/\n</code></pre>\n<p>Метод test() возвращает логическое значение в зависимости от того, найдено ли совпадение в строке:</p>\n<pre><code class="lang-js">\nconst str = \'Я люблю JavaScript\'\n\nconsole.log(\n    /Я люблю/.test(str) // true\n)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/regexp-methods" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 152 --\x3e\n<section id="149">\n<h3>149. Какие флаги используются в регулярных выражениях?</h3>\n<table>\n<tbody><tr>\n    <th>Флаг</th>\n    <th>Описание</th>\n</tr>\n<tr>\n    <td>g</td>\n    <td>глобальное сопоставление</td>\n</tr>\n<tr>\n    <td>i</td>\n    <td>игнорирование регистра при сопоставлении</td>\n</tr>\n<tr>\n    <td>m</td>\n    <td>сопоставление по нескольким строкам</td>\n</tr>\n</tbody></table>\n<pre><code class="lang-js">\nconst regex = /([а-яё]+)s([а-яё]+)/i\nconst str = \'Иван Иванов\'\nconst newStr = str.replace(regex, \'&#36;2 &#36;1\')\nconsole.log(newStr) // Иванов Иван\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/regexp-methods" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 153 --\x3e\n<section id="150">\n<h3>150. Какие специальные символы используются в регулярных выражениях?</h3>\n<p>Специальные символы, используемые в регулярных выражениях, можно разделить на несколько групп.</p>\n<p>Основные символьные классы:</p>\n<table>\n<tbody><tr>\n    <th>Символ</th>\n    <th>Значение</th>\n</tr>\n<tr>\n    <td>\\.</td>\n    <td>любой символ, за некоторым исключением</td>\n</tr>\n<tr>\n    <td>\\d</td>\n    <td>цифра</td>\n</tr>\n<tr>\n    <td>\\D</td>\n    <td>не цифра</td>\n</tr>\n<tr>\n    <td>\\w</td>\n    <td>символ латиницы и нижнее подчеркивание</td>\n</tr>\n<tr>\n    <td>\\W</td>\n    <td>не символ латиницы и нижнее подчеркивание</td>\n</tr>\n<tr>\n    <td>\\s</td>\n    <td>пробельный символ</td>\n</tr>\n<tr>\n    <td>\\S</td>\n    <td>не пробельный символ</td>\n</tr>\n<tr>\n    <td>\\</td>\n    <td>экранирование, например, \\. - это точка</td>\n</tr>\n</tbody></table>\n<p>Наборы символов:</p>\n<table>\n<tbody><tr>\n    <th>Символ</th>\n    <th>Значение</th>\n</tr>\n<tr>\n    <td>[а-яёА-ЯЁ]</td>\n    <td>любая буква русского алфавита</td>\n</tr>\n<tr>\n    <td>[^а-яёА-ЯЁ]</td>\n    <td>любой символ, кроме букв русского алфавита</td>\n</tr>\n</tbody></table>\n<p>Границы:</p>\n<table>\n<tbody><tr>\n    <th>Символ</th>\n    <th>Значение</th>\n</tr>\n<tr>\n    <td>^</td>\n    <td>начало строки</td>\n</tr>\n<tr>\n    <td>&#36;</td>\n    <td>конец строки</td>\n</tr>\n<tr>\n    <td>\\b</td>\n    <td>граница слова нулевой ширины</td>\n</tr>\n<tr>\n    <td>\\B</td>\n    <td>граница слова ненулевой ширины</td>\n</tr>\n</tbody></table>\n<p>Группировка:</p>\n<table>\n<tbody><tr>\n    <th>Символ</th>\n    <th>Значение</th>\n</tr>\n<tr>\n    <td>(x)</td>\n    <td>сопоставляется с x, сопоставление запоминается</td>\n</tr>\n<tr>\n    <td>(?:x)</td>\n    <td>сопоставляется с x, сопоставление не запоминается</td>\n</tr>\n</tbody></table>\n<p>Квантификаторы:</p>\n<table>\n<tbody><tr>\n    <th>Символ</th>\n    <th>Значение</th>\n</tr>\n<tr>\n    <td>*</td>\n    <td>ноль и более символов</td>\n</tr>\n<tr>\n    <td>+</td>\n    <td>один и более символов</td>\n</tr>\n<tr>\n    <td>*? и +?</td>\n    <td>аналогично * и +, но ищется минимальное совпадение</td>\n</tr>\n<tr>\n    <td>?</td>\n    <td>ноль или один символ</td>\n</tr>\n<tr>\n    <td>x(?=y)</td>\n    <td>сопоставляется с x, если за x следует y</td>\n</tr>\n<tr>\n    <td>x(?!y)</td>\n    <td>сопоставляется с x, если за x не следует y</td>\n</tr>\n<tr>\n    <td>(?&lt;=y)x</td>\n    <td>сопоставляется с x, если x предшествует y</td>\n</tr>\n<tr>\n    <td>(?!y)x</td>\n    <td>сопоставляется с x, если x не предшествует y</td>\n</tr>\n<tr>\n    <td>x|y</td>\n    <td>x или y</td>\n</tr>\n<tr>\n    <td>x{n}</td>\n    <td>n - точное количество x</td>\n</tr>\n<tr>\n    <td>x{n,}</td>\n    <td>n - минимальное количество x</td>\n</tr>\n<tr>\n    <td>x{n,m}</td>\n    <td>n - минимальное количество x, m - максимальное (от, до)</td>\n</tr>\n</tbody></table>\n<nav>\n<a href="https://learn.javascript.ru/regexp-methods" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 154 --\x3e\n<section id="151">\n<h3>151. Как изменить стили HTML-элемента?</h3>\n<p>Это можно сделать либо с помощью свойства style, либо присвоив элементу соответствующий класс:</p>\n<pre><code class="lang-js">\ndocument\n    .querySelector(selector)\n    .style.property = value\ndocument\n    .querySelector(\'title\')\n    .fontSize = \'2rem\'\n\ndocument.querySelector(selector)\n    .className = \'class-name\'\ndocument.querySelector(selector)\n    .classList.add(\'class-name\')\ndocument.querySelector(\'button\')\n    .classList.add(\'active\')\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/styles-and-classes" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/HTML/Global_attributes/style" target="_blank">MDN - style</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Element/className" target="_blank">MDN - className</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Element/classList" target="_blank">MDN - classList</a>\n</nav>\n</section>\n\n\x3c!-- 155 --\x3e\n<section id="152">\n<h3>152. Что такое debugger (отладчик)?</h3>\n<p>Выражение debugger открывает доступ к любому доступному в конкретном окружении отладочному функционалу, например, к установке контрольных точек (точек останова, брекпойнтов). Если функционал отладки в среде выполнения недоступен, данное выражение не будет иметь никакого эффекта:</p>\n<pre><code class="lang-js">\nconst fun = () =&gt; {\n    // магия\n    debugger // в этом месте выполнение функции будет приостановлено\n    // магия\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/debugging-chrome" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 156 --\x3e\n<section id="153">\n<h3>153. Для чего используются контрольные точки debugger (отладчика)?</h3>\n<p>Контрольные точки используются для приостановки выполнения функции или другого кода в определенном месте с целью выяснения причин неправильной работы программы. После остановки выполнение функции может быть продолжено.</p>\n<nav>\n<a href="https://learn.javascript.ru/debugging-chrome" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 157 --\x3e\n<section id="154">\n<h3>154. Можно ли использовать зарезервированные слова в качестве идентификаторов?</h3>\n<p>Нет, использовать зарезервированные слова в качестве названий переменных, меток, функций или объектов нельзя:</p>\n<pre><code class="lang-js">\nconst class = \'Первый раз в первый класс\' // SyntaxError: Unexpected token \'class\'\n</code></pre>\n</section>\n\n\x3c!-- 158 --\x3e\n<section id="155">\n<h3>155. Как определить ширину и высоту изображения?</h3>\n<p>Это можно сделать разными способами. Вот один из них:</p>\n<pre><code class="lang-js">\nconst getImgSize = src =&gt; {\n    const img = new Image()\n    img.src = src\n    img.addEventListener(\'load\', () =&gt; console.log(`&#36;{img.width} x &#36;{img.height}`)) // 276 x 110\n    document.body.append(img)\n}\ngetImgSize(\'http://www.google.com/ intl/en_ALL/images/logo.gif\')\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/HTMLImageElement/Image" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 159 --\x3e\n<section id="156">\n<h3>156. Как отправить синхронный HTTP-запрос?</h3>\n<p>Для этого можно использовать объект XMLHttpRequest, передав его методу open() третий опциональный аргумент со значением false:</p>\n<pre><code class="lang-js">\nconst getUsers = url =&gt; {\n    const xhr = new XMLHttpRequest()\n    xhr.open(\'GET\', url, false)\n    xhr.send()\n    console.table(xhr.response)\n\n    const response = JSON.parse(xhr.response)\n    const template = `\n        &lt;table&gt;\n            &#36;{response.reduce((html, user) =&gt; html += `\n                &lt;tr&gt;\n                    &lt;td&gt;&#36;{user.name}&lt;/td&gt;\n                    &lt;td&gt;&#36;{user.username}&lt;/td&gt;\n                    &lt;td&gt;&#36;{user.email}&lt;/td&gt;\n                &lt;/tr&gt;`, \'\')}\n        &lt;table&gt;\n    `\n    document.body\n        .insertAdjacentHTML(\'beforeend\', template)\n}\n\ngetUsers(\'https://jsonplaceholder. typicode.com/users\')\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/xmlhttprequest" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/XHR_(XMLHttpRequest)" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 160 --\x3e\n<section id="157">\n<h3>157. Как сделать асинхронный HTTP-запрос?</h3>\n<p>Для этого можно использовать метод fetch():</p>\n<pre><code class="lang-js">\nconst getUsers = async url =&gt; {\n    const response = await fetch(url)\n    const data = await response.json()\n    console.table(data)\n\n    const template = `\n        &lt;table&gt;\n            &#36;{data.reduce((html, user) =&gt; html += `\n                &lt;tr&gt;\n                    &lt;td&gt;&#36;{user.name}&lt;/td&gt;\n                    &lt;td&gt;&#36;{user.username}&lt;/td&gt;\n                    &lt;td&gt;&#36;{user.email}&lt;/td&gt;\n                &lt;/tr&gt;`, \'\')}\n        &lt;table&gt;\n    `\n    document.body.insertAdjacentHTML(\'beforeend\', template)\n}\n\ngetUsers(\'https://jsonplaceholder. typicode.com/users\')\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/fetch" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Fetch_API" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 161 --\x3e\n<section id="158">\n<h3>158. Как получить дату в нужном формате?</h3>\n<p>Для этого можно использовать метод toLocaleString():</p>\n<pre><code class="lang-js">\nconsole.log(\n    new Date().toLocaleString(\'ru-Ru\', {\n        weekday: \'long\',\n        year: \'numeric\',\n        month: \'long\',\n        day: \'numeric\'\n    })\n) // воскресенье, 6 сентября 2020 г.\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 162 --\x3e\n<section id="159">\n<h3>159. Как получить максимальные размеры страницы?</h3>\n<p>Для этого нужно найти максимальные значения свойств scrollWidth, offsetWidth, clientWidth и scrollHeight, offsetHeight, clientHeight объектов document.body и document.documentElement:</p>\n<pre><code class="lang-js">\nconst pageWidth = Math.max(\n    document.body.scrollWidth, document.documentElement.scrollWidth,\n    document.body.offsetWidth, document.documentElement.offsetWidth,\n    document.body.clientWidth, document.documentElement.clientWidth\n)\nconst pageHeight = Math.max(\n    document.body.scrollHeight, document.documentElement.scrollHeight,\n    document.body.offsetHeight, document.documentElement.offsetHeight,\n    document.body.clientHeight, document.documentElement.clientHeight\n)\nconst pageSize = {\n    width: pageWidth,\n    heigth: pageHeight\n}\nconsole.log(pageSize)\n\nconst pageCenter = {\n    centerX: pageWidth / 2,\n    centerY: pageHeight / 2\n}\nconsole.log(pageCenter)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/size-and-scroll" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 163 --\x3e\n<section id="160">\n<h3>160. Что такое условный или тернарный оператор?</h3>\n<p>Тернарный оператор является сокращенным способом записи блока if...else:</p>\n<pre><code class="lang-js">\nlet accesAllowed\nconst age = propmt(\'Сколько вам лет?\')\n\n// if...else\nif (age &gt; 18) {\n    accesAllowed = true\n} else {\n    accessAllowed = false\n}\n\n// тернарный оператор\n(age &gt; 18)\n    ? accesAllowed = true\n    : accessAllowed = false\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/ifelse" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 164 --\x3e\n<section id="161">\n<h3>161. Можно ли использовать цепочку из тернарных операторов?</h3>\n<p>Да, в этом случае тернарный оператор является альтернативой блока if...else if...else:</p>\n<pre><code class="lang-js">\nlet accessAllowed\nconst getAge = () =&gt; prompt(\'Сколько вам лет?\')\n\n// это всего лишь пример - не надо так делать\n// if...else if...else\nconst checkAge = (age = getAge()) =&gt; {\n    console.log(age)\n    if (isNaN(age)) {\n        Promise.resolve(alert(\'Возраст должен быть числом\')).then(accessAllowed = false).then(checkAge)\n    } else if (age === null || age === \'\') {\n        Promise.resolve(alert(\'Введите ваш возраст\')).then(accessAllowed = false).then(checkAge)\n    } else if (age &lt; 0) {\n        Promise.resolve(alert(\'Возраст не может быть меньше 0\')).then(accessAllowed = false).then(checkAge)\n    } else if (age &gt; 100) {\n        Promise.resolve(alert(\'Возраст не может быть больше 100\')).then(accessAllowed = false).then(checkAge)\n    } else if (age &lt; 18) {\n        Promise.resolve(alert(\'Извините, вы слишком молоды\')).then(accessAllowed = false)\n    } else {\n        Promise.resolve(alert(\'Добро пожаловать!\')).then(accessAllowed = true)\n    }\n    console.log(accessAllowed)\n}\n\n// тернарный оператор\nconst checkAge = (age = getAge()) =&gt; {\n    isNaN(age)\n        ? Promise.resolve(alert(\'Возраст должен быть числом\')).then(accessAllowed = false).then(checkAge)\n        : (age === null || age === \'\')\n          ? Promise.resolve(alert(\'Введите ваш возраст\')).then(accessAllowed = false).then(checkAge)\n          : (age &lt; 0)\n            ? Promise.resolve(alert(\'Возраст не может быть меньше 0\')).then(accessAllowed = false).then(checkAge)\n            : (age &gt; 100)\n            ? Promise.resolve(alert(\'Возраст не может быть больше 100\')).then(accessAllowed = false).then(checkAge)\n            : (age &lt; 18)\n                ? Promise.resolve(alert(\'Извините, вы слишком молоды\')).then(accessAllowed = false)\n                : Promise.resolve(alert(\'Добро пожаловать!\')).then(accessAllowed = true)\n    console.log(accessAllowed)\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/ifelse" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 165 --\x3e\n<section id="162">\n<h3>162. Как начать выполнение кода после полной загрузки страницы?</h3>\n<p>Это можно сделать несколькими способами.</p>\n<p>Разместить тег script перед закрывающим тегом body или добавить ему атрибут defer:</p>\n<pre><code class="lang-js">\n&lt;body&gt;\n    ...\n    &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n\x3c!-- или --\x3e\n&lt;head&gt;\n    ...\n    &lt;script src="script.js" defer&gt;&lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>Если ваш скрипт - это модуль, то вместо атрибута defer, нужно указать атрибут type со значением module:</p>\n<pre><code class="lang-js">\n&lt;script src="script.js" type="module"&gt;&lt;/script&gt;\n</code></pre>\n<p>Добавить тегу body атрибут onload:</p>\n<pre><code class="lang-js">\n&lt;body onload="script()"&gt;&lt;/body&gt;\n</code></pre>\n<p>Добавить код в качестве обработчика события load объекта window:</p>\n<pre><code class="lang-js">\nwindow.onload = () =&gt; console.log(\'Страница полностью загружена\')\n\n// или\nwindow.addEventListener(\'load\', () =&gt; console.log(\'Страница полностью загружена\'))\n</code></pre>\n<p>Сделать тоже самое для document.body:</p>\n<pre><code class="lang-js">\ndocument.body.onload = () =&gt; console.log(\'Страница полностью загружена\')\n</code></pre>\n</section>\n\n\x3c!-- 166 --\x3e\n<section id="163">\n<h3>163. В чем разница между __proto__ и prototype?</h3>\n<p>Свойство __proto__ (внутреннее скрытое свойство [[Prototype]]) - это объект, от которого экземпляр наследует поля и методы. А prototype - это объект, который используется для создания __proto__ при создании экземпляра с помощью ключевого слова new:</p>\n<pre><code class="lang-js">\nclass Person {\n    constructor(firstName, secondName) {\n        this.firstName = firstName\n        this.secondName = secondName\n    }\n    getFullName() {\n        return `&#36;{this.firstName} &#36;{this.secondName}`\n    }\n\n}\n\nconst user = new Person(\'Иван\', \'Иванов\')\nconsole.log(user.getFullName()) // Иван Иванов\nconsole.log(user.__proto__.getFullName === Person.prototype.getFullName) // true\nconsole.log(Person.prototype) // {constructor: ƒ, getFullName: ƒ}\nconsole.log(user.prototype === undefined) // true\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/prototype-inheritance" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 167 --\x3e\n<section id="164">\n<h3>164. Приведите пример обязательного использования точки с запятой</h3>\n<p>Одним из случаев обязательного использования точки запятой является использование IIFE (Immediately Invoked Fuction Expression - немедленно вызываемого функционального выражения):</p>\n<p>Например, следующий код:</p>\n<pre><code class="lang-js">\ntry {\n    const x = \'Быть\'\n\n    (() =&gt; {\n        console.log(x)\n    })()\n} catch {\n    console.log(\'Не быть\')\n}\n</code></pre>\n<p>Будет интерпретирован так:</p>\n<pre><code class="lang-js">\ntry {\n    const x = \'Быть\'(() =&gt; {\n        console.log(x)\n    })()\n} catch {\n    console.log(\'Не быть\')\n}\n</code></pre>\n<p>Поэтому в блоке try мы получаем ошибку TypeError: "Быть" is not a function, управление передается блоку catch, и в консоль выводится "Не быть".</p>\n<p>Для того, чтобы код работал, как ожидается, он должен выглядеть так:</p>\n<pre><code class="lang-js">\ntry {\n    // точку с запятой нужно поставить либо здесь\n    const x = \'Быть\';\n    // либо здесь\n    ;(() =&gt; {\n        console.log(x)\n    })()\n} catch {\n    console.log(\'Не быть\')\n}\n</code></pre>\n<p>Также не забывайте про случаи автоматического расставления точек с запятой.</p>\n</section>\n\n\x3c!-- 168 --\x3e\n<section id="165">\n<h3>165. Для чего используется метод freeze()?</h3>\n<p>Данный метод, как следует из его названия, служит для "замораживания" объекта. Замороженный объект является неизменяемым (иммутабельным). Это означает, что в такой объект нельзя добавлять новые свойства, удалять или изменять существующие. Также этот метод устанавливает configurable: false и writable: false для существующих свойств. Метод возвращает замороженный объект.</p>\n<pre><code class="lang-js">\n\'use strict\'\nconst obj = {\n    mission: \'possible\'\n}\n\nObject.freeze(obj)\nobj.mission = \'impossible\' // TypeError: Cannot assign to read only property \'mission\' of object \'#&lt;Object&gt;\'\n\ndelete obj.mission // TypeError: Cannot delete property \'mission\' of #&lt;Object&gt;\n</code></pre>\n<p>Обратите внимание, что в нестрогом режиме исключение не выбрасывается, код просто не выполняется.</p>\n<nav>\n<a href="https://learn.javascript.ru/property-descriptors" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 169 --\x3e\n<section id="166">\n<h3>166. Зачем нужен метод freeze()?</h3>\n<p>Парадигма объектно-ориентированного программирования гласит, что интерфейс, содержащий определенное количество элементов, должен быть иммутабельным, т.е. должна быть исключена возможность его расширения, модификации или использования элементов за пределами текущего контекста. Данный метод является алиасом ключевого слова final в некоторых других языках программирования.</p>\n<nav>\n<a href="https://learn.javascript.ru/property-descriptors" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 170 --\x3e\n<section id="167">\n<h3>167. Как сделать первую букву каждого слова в строке заглавной?</h3>\n<p>Одним из способов это сделать является следующий:</p>\n<pre><code class="lang-js">\nconst capitilize = str =&gt; str.replace(\n    /[а-яё]S+/gi,\n    txt =&gt; txt[0].toUpperCase() + txt.slice(1).toLowerCase()\n)\n\nconsole.log(capitilize(\'аПтека, улИца, фонАрь\')) // Аптека, Улица, Фонарь\n</code></pre>\n</section>\n\n\x3c!-- 171 --\x3e\n<section id="168">\n<h3>168. Как узнать, что на странице отключен JavaScript?</h3>\n<p>Для этого можно использовать тег noscript. Код внутри этого тега будет выполнен только в случае, если на странице отключен JavaScript:</p>\n<pre><code class="lang-js">\n    console.log(\'JavaScript включен\')\n\n&lt;noscript&gt;\n    &lt;p&gt;Включите JavaScript, или ничего не получится&lt;/p&gt;\n&lt;/noscript&gt;\n</code></pre>\n<p>Для того, чтобы отключить JavaScript в Chrome, заходим в настройки -&gt; раздел "Конфиденциальность и безопасность" -&gt; Настройки сайтов -&gt; раздел "Контент" -&gt; JavaScript.</p>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/noscript" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 172 --\x3e\n<section id="169">\n<h3>169. Какие операторы поддерживаются JavaScript?</h3>\n<p>Операторы служат для работы со значениями или операндами. JavaScript поддерживает следующие операторы:</p>\n<ul>\n<li>Арифметические: + (сложение, приведение к числу, конкатенация), - (вычитание), * (умножение), / (деление), % (деление по модулю, с остатком), ++ (инкремент), -- (декремент), ** (возведение в степень)</li>\n<li>операторы сравнения: == (абстрактное, нестрогое равенство), != (абстрактное неравенство), === (строгое равенство, проверка на идентичность), !== (строгое неравенство), &gt;, &gt;=, &lt;, &lt;=</li>\n<li>логические: &amp;&amp; (и), || (или), ! (не) (!! (двойное отрицание) не является отдельным оператором)</li>\n<li>операторы присваивания: =, +=, -=, *=, /=, %=</li>\n<li>тернарный: ?...: (if...else)</li>\n<li>оператор typeof: определяет тип операнда</li>\n<li>побитовые: &amp; (и), | (или), ^ (исключающее или), ~ (не), &lt;&lt; (левый сдвиг), &gt;&gt; (правый сдвиг), &gt;&gt;&gt; (правый сдвиг с заполнением нулями)</li>\n<li>новые: ?. (опциональная цепочка), ?? (слияние с null)</li>\n</ul>\n<pre><code class="lang-js">\n// опциональная цепочка\nconst obj = {\n    foo: {\n        baz: {\n            qux: \'bar\'\n        }\n    }\n}\n\n// тогда\nconsole.log(obj.foo.bar.baz.qux) // TypeError: Cannot read property \'baz\' of undefined\n\nif (\n    obj.foo !== undefined &amp;&amp;\n    obj.foo.bar !== undefined &amp;&amp;\n    obj.foo.bar.baz !== undefined\n) {\n    console.log(obj.foo.bar.baz.qux) // ошибки не будет\n}\n\n// сейчас\nconsole.log(obj?.foo?.bar?.baz?.qux) // undefined\n\n// слияние с null\nconsole.log(\n    0 || \'default null\', // \'default null\'\n    0 ?? \'default null\', // 0\n    \'\' || \'default string\', // default string\n    \'\' ?? \'default string\', // \'\'\n)\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/operators" target="_blank">JSR - Операторы</a>\n<a href="https://learn.javascript.ru/logical-operators" target="_blank">JSR - Логические операторы</a>\n<a href="https://learn.javascript.ru/comparison" target="_blank">JSR - Операторы сравнения</a>\n<a href="https://learn.javascript.ru/ifelse" target="_blank">JSR - Условные операторы</a>\n<a href="https://learn.javascript.ru/bitwise-operators" target="_blank">JSR - Побитовые операторы</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining" target="_blank">MDN - Оператор опциональной последовательности</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_Coalescing_Operator" target="_blank">MDN - Оператор нулевого слияния</a>\n</nav>\n</section>\n\n\x3c!-- 173 --\x3e\n<section id="170">\n<h3>170. Для чего используется оператор rest ... (прочие параметры)?</h3>\n<p>Оператор rest является альтернативой объекта arguments и возвращает массив из переданных функции аргументов:</p>\n<pre><code class="lang-js">\nconst sum = (...rest) =&gt; rest.reduce((acc, cur) =&gt; acc + cur)\n\nconsole.log(sum(1, 2, 3)) // 6\n</code></pre>\n<p>Обратите внимание, что оператор rest должен передаваться в качестве последнего аргумента:</p>\n<pre><code class="lang-js">\nconst fun = (x, ...rest, y) =&gt; console.log(rest) // SyntaxError: Rest parameter must be last formal parameter\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/destructuring-assignment" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 174 --\x3e\n<section id="171">\n<h3>171. Для чего используется оператор spread ... (оператор распространения)?</h3>\n<p>Оператор spread используется для расширения (распаковки, разворачивания) итерируемых сущностей (массивов, строк). Распаковка означает преобразование, например, массива из чисел в набор простых значений:</p>\n<pre><code class="lang-js">\nconst sum = (x, y, z) =&gt; x + y + z\n\nconst nums = [1, 2, 3]\n\nconsole.log(sum(...nums)) // 6\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/destructuring-assignment" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 175 --\x3e\n<section id="172">\n<h3>172. Как определить, заморожен ли объект?</h3>\n<p>Для того, чтобы определить, заморожен ли объект, т.е. является ли он неизменяемым (иммутабельным), используется метод isFrozen():</p>\n<pre><code class="lang-js">\nconst obj = {\n    prop: \'Добро пожаловать в мир JavaScript!\'\n}\n\nObject.freeze(obj)\n\nconsole.log(Object.isFrozen(obj)) // true\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 176 --\x3e\n<section id="173">\n<h3>173. Как определить равенство значений, используя объект?</h3>\n<p>Для этого можно использовать метод is():</p>\n<pre><code class="lang-js">\nObject.is(\'двое из ларца\', \'двое из ларца\') // true\nObject.is(0.1 + 0.2, 0.3) // false\nObject.is(window, window) // true\nObject.is(+0, -0) // false\n\nconst objA = {}\nconst objB = objA\nObject.is(objA, objB) // true\nObject.is({}, {}) // false\n</code></pre>\n<p>Значения являются равными, если:</p>\n<ul>\n<li>оба являются undefined</li>\n<li>оба являются null</li>\n<li>оба являются true или false</li>\n<li>оба являются строками одинаковой длины с одинаковыми символами</li>\n<li>оба ссылаются на один объект</li>\n<li>оба являются числами, +0, -0 или NaN</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 177 --\x3e\n<section id="174">\n<h3>174. Как создать копию объекта?</h3>\n<p>Одним из самых надежных способов это сделать является использование метода assign():</p>\n<pre><code class="lang-js">\nconst objA = {a: 1, b: 2}\nconst objB = Object.assign(objA)\n\nconsole.log(objB) // {a: 1, b: 2}\n\nconsole.log(objA === objB) // true\n</code></pre>\n<p>Также данный метод позволяет объединять объекты, исключая дубликаты:</p>\n<pre><code class="lang-js">\nconst objA = {a: 1, b: 2}\nconst objB = {b: 2, c: 3}\n\nconst objC = Object.assign(objA, objB)\nconsole.log(objC) {a: 1, b: 2, c: 3}\n</code></pre>\n<p>Для копирования простых объектов можно использовать связку JSON.parse-JSON.stringify:</p>\n<pre><code class="lang-js">\nconst objA = {a: 1, b: 2}\n\nconst objB = JSON.parse(JSON.stringify(objA))\n\nconsole.log(objB) // {a: 1, b: 2}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/object" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 178 --\x3e\n<section id="175">\n<h3>175. Что такое прокси?</h3>\n<p>Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие.</p>\n<pre><code class="lang-js">\nconst handler = {\n    get: (obj, prop) =&gt; prop in obj\n        ? obj[prop]\n        : 0\n}\n\n// new Proxy(цель, обработчик)\nconst p = new Proxy({}, handler)\n\np.a = 1\np.b = true\n\nconsole.log(p.a, p.b) // 1 true\nconsole.log( \'c\' in p, p.c) // false 0\n</code></pre>\n</section>\n\n\x3c!-- 179 --\x3e\n<section id="176">\n<h3>176. Для чего используется метод seal()?</h3>\n<p>Данный метод "запечатывает" объект, запрещая добавлять/удалять свойства. Он также устанавливает configurable: false для всех существующих свойств. Однако, значения свойств такого объекта можно менять. Для проверки, является ли объект запечатанным, используется метод isSealed().</p>\n<pre><code class="lang-js">\n\'use strict\'\nconst obj = {\n    prop: \'Добро пожаловать в мир JavaScript!\'\n}\n\nObject.seal(obj)\n\nobj.prop = \'Оставь надежду, всяк сюда входящий\'\nconsole.log(Object.isSealed(obj)) // true\ndelete obj.prop // TypeError: Cannot delete property \'prop\' of #&lt;Object&gt;\nconsole.log(obj.prop) // Оставь надежду, всяк сюда входящий\n</code></pre>\n<p>Обратите внимание, что в нестрогом режиме попытка удаления свойства запечатанного объекта тихо завершится ничем.</p>\n<nav>\n<a href="https://learn.javascript.ru/property-descriptors" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 180 --\x3e\n<section id="177">\n<h3>177. В чем разница между методами freeze() и seal()?</h3>\n<p>Метод Object.seal() в отличие от метода Object.freeze() позволяет изменять существующие свойства объекта.</p>\n<pre><code class="lang-js">\n\'use strict\'\nconst objA = {\n    prop: \'Быть\'\n}\nObject.freeze(objA)\nobjA.prop = \'Не быть\' // TypeError: Cannot assign to read only property \'prop\' of object \'#&lt;Object&gt;\'\n\nconst objB = {\n    prop: \'Не быть\'\n}\nObject.seal(objB)\nobjB.prop = \'Быть\'\nconsole.log(objB.prop) // Быть\n</code></pre>\n</section>\n\n\x3c!-- 181 --\x3e\n<section id="178">\n<h3>178. Как получить перечисляемые пары ключ/значение объекта?</h3>\n<p>Метод Object.entries() возвращает массив из перечисляемых пар ключ/значение объекта в виде подмассивов в том же порядке, что и цикл for...in:</p>\n<pre><code class="lang-js">\nconst obj = {\n    x: 1,\n    y: 2\n}\n\nconsole.log(Object.entries(obj)) // [["x", 1], ["y", 2]]\n\nfor (let [key, value] of Object.entries(obj)) {\n    console.log(`&#36;{key}: &#36;{value}`) // x: 1 y: 2\n}\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/keys-values-entries" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 182 --\x3e\n<section id="179">\n<h3>179. В чем главное отличие методов Object.keys(), Object.values() и Object.entries()?</h3>\n<p>Метод Object.keys() возвращает ключи объекта, метод Object.values() - значения его свойств, а Object.entries() массив из пар ключ/значение:</p>\n<pre><code class="lang-js">\nconst user = {\n    name: \'Ванька\',\n    age: 30\n}\n\nconsole.log(Object.keys(user)) // ["name", "age"]\nconsole.log(Object.values(user)) // ["Ванька", 30]\nconsole.log(Object.entries(user)) // [["name", "Ванька"], ["age", 30]]\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/keys-values-entries" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">MDN - Object.keys()</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">MDN - Object.values()</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">MDN - Object.entries()</a>\n</nav>\n</section>\n\n\x3c!-- 183 --\x3e\n<section id="180">\n<h3>180. Как создать объект с определенным прототипом, не используя функцию-конструктор и классы?</h3>\n<p>Для этого можно использовать метод Object.create():</p>\n<pre><code class="lang-js">\nconst firstUser = {\n    name: \'Ванька\',\n    sayHi() {\n        console.log(`Привет, меня зовут &#36;{this.name}!`)\n    }\n}\n\nconst secondUser = Object.create(firstUser)\n\nsecondUser.name = \'Петька\'\nsecondUser.sayHi() // Привет, меня зовут Петька!\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/prototype-inheritance" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 184 --\x3e\n<section id="181">\n<h3>181. Для чего используется WeakSet?</h3>\n<p>WeakSet используется для хранения коллекции объектов со слабыми ссылками. Другими словами, он служит дополнительным хранилищем объектов, используемых другим кодом. Такие объекты автоматически удаляются сборщиком мусора, когда становятся недостижимыми (неиспользуемыми), т.е. когда от объекта остается только ключ в WeakSet.</p>\n<pre><code class="lang-js">\nconst ws = new WeakSet()\nlet user = {}\n\nws.add(user)\nconsole.log(ws.has(user)) // true\n\nuser = null\nconsole.log(ws.has(user)) // false, структура была очищена автоматически\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/weakmap-weakset" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 185 --\x3e\n<section id="182">\n<h3>182. В чем разница между Set и WeakSet?</h3>\n<p>Их основным отличием является то, что объекты, хранящиеся в WeakSet, имеют слабые ссылки, т.е. автоматически удаляются, как только становятся недостижимыми. Другие отличия состоят в следующем:</p>\n<ul>\n<li>В Set могут храниться любые значения, а в WeakSet - только объекты</li>\n<li>WeakSet не имеет свойства size</li>\n<li>WeakSet не имеет методов clear(), keys(), values(), forEach()</li>\n<li>WeakSet не является итерируемой сущностью</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/weakmap-weakset" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 186 --\x3e\n<section id="183">\n<h3>183. Какие методы доступны в WeakSet?</h3>\n<p>WeakSet обладает следующими методами:</p>\n<ul>\n<li>add(): добавляет объект в коллекцию</li>\n<li>delete(): удаляет объект из коллекции</li>\n<li>has(): определяет наличие объекта в коллекции</li>\n<li>length(): возвращает длину коллекции</li>\n</ul>\n<pre><code class="lang-js">\nconst ws = new WeakSet()\nconst objA = {}\nconst objB = {}\n\nws.add(objA)\nws.add(objB)\nconsole.log(ws.has(objA)) // true\nconsole.log(ws.lenghth()) // 2\nws.delete(objA)\nconsole.log(ws.has(objA)) // false\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/weakmap-weakset" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 187 --\x3e\n<section id="184">\n<h3>184. Для чего используется WeakMap?</h3>\n<p>WeakMap используется для хранения пар ключ/значение, в которых ключи имеют слабые ссылки. Другими словами, он служит дополнительным хранилищем ключей, используемых другим кодом. Такие ключи автоматически удаляются сборщиком мусора, когда становятся недостижимыми (неиспользуемыми), т.е. когда от них остается только ключ в WeakMap.</p>\n<pre><code class="lang-js">\nconst wm = new WeakMap()\nlet user = {}\nwm.set(user, \'user\')\nconsole.log(wm.has(user)) // true\nuser = null\nconsole.log(wm.has(user)) // false, структура была очищена автоматически\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/weakmap-weakset" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 188 --\x3e\n<section id="185">\n<h3>185. В чем разница между Map и WeakMap?</h3>\n<p>Их основным отличием является то, что ключи, хранящиеся в WeakMap, имеют слабые ссылки, т.е. автоматически удаляются как только становятся недостижимыми. Другие отличия состоят в следующем:</p>\n<ul>\n<li>В Map в качестве ключей могут использоваться любые значения, а в WeakMap - только объекты</li>\n<li>WeakMap не имеет свойства size</li>\n<li>WeakMap не имеет методов clear(), keys(), values(), entries(), forEach()</li>\n<li>WeakMap не является итерируемой сущностью</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/weakmap-weakset" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 189 --\x3e\n<section id="186">\n<h3>186. Какие методы доступны в WeakMap?</h3>\n<p>WeakMap обладает следующими методами:</p>\n<ul>\n<li>set(): добавляет пару ключ/значение в объект</li>\n<li>delete(): удаляет значение по ключу</li>\n<li>has(): определяет наличие значения по ключу</li>\n<li>get(): возвращает значение по ключу</li>\n</ul>\n<pre><code class="lang-js">\nconst wm = new WeakMap()\nconst firstUser = {}\nconst secondUser = {}\n\nwm.set(firstUser, \'Ванька\')\nwm.set(secondUser, \'Петька\')\nconsole.log(wm.has(firstUser)) // true\nconsole.log(wm.get(firstUser)) // Ванька\nwm.delete(secondUser)\nconsole.log(wm.has(secondUser)) // false\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/weakmap-weakset" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 190 --\x3e\n<section id="187">\n<h3>187. Как закодировать URL?</h3>\n<p>Для этого можно использовать метод encodeURI(). Данный метод преобразует все специальные символы, кроме , / ? : @ = + &#36; #</p>\n<pre><code class="lang-js">\nconst url = \'https://ru.wikipedia.org/wiki/Лермонтов,_Михаил_Юрьевич\'\nconst encoded = encodeURI(url)\nconsole.log(encoded) // https://ru.wikipedia.org/wiki/%D0%9B%D0...\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/url" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/encodeURI" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 191 --\x3e\n<section id="188">\n<h3>188. Как раскодировать URL?</h3>\n<p>Для этого можно использовать метод decodeURI():</p>\n<pre><code class="lang-js">\nconst url = \'https://ru.wikipedia.org/wiki/%D0%9B%D0...\'\nconst decoded = decodeURI(url)\nconsole.log(decoded) // https://ru.wikipedia.org/wiki/Лермонтов,_Михаил_Юрьевич\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/url" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/decodeURI" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 192 --\x3e\n<section id="189">\n<h3>189. Как вывести содержимое страницы на печать?</h3>\n<p>Для этого можно использовать глобальный метод print(). Данный метод открывает специальное диалоговое окно с настройками печати:</p>\n<pre><code class="lang-js">\n&lt;button&gt;Печать&lt;/button&gt;\n\ndocument.querySelector(\'button\')\n    .addEventListener(\'click\', () =&gt; print())\n</code></pre>\n<nav>\n<a href="https://developer.mozilla.org/ru/docs/Web/API/Window/print" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 193 --\x3e\n<section id="190">\n<h3>190. Что такое анонимная функция?</h3>\n<p>Анонимная функция - это функция без названия. Такие функции часто присваиваются переменным, а также используются в качестве колбэков:</p>\n<pre><code class="lang-js">\nconst sayHi = function () {\n    console.log(\'Привет\')\n}\nsayHi() // Привет\n// или\nconst sayBye = () =&gt; console.log(\'Пока\')\nsayBye() // Пока\n\nwindow.addEventListener(\'click\', function () {\n    console.log(\'Не буди лихо, пока оно тихо\')\n})\n// или\nwindow.addEventListener(\'contextmenu\', e =&gt; {\n    e.preventDefault()\n    console.log(\'Контекстное меню - детям не игрушка\')\n})\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/function-basics" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 194 --\x3e\n<section id="191">\n<h3>191. Каков приоритет использования локальных и глобальных переменных?</h3>\n<p>Локальные переменные имеют приоритет над одноименными глобальными переменными:</p>\n<pre><code class="lang-js">\nlet question = \'Не быть\'\n\nfunction toBe () {\n    question = \'Быть\'\n    console.log(question)\n}\ntoBe() // Быть\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/variables" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 195 --\x3e\n<section id="192">\n<h3>192. Что такое аксессоры?</h3>\n<p>Аксессоры или вычисляемые свойства - это геттеры и сеттеры. Геттеры используются для получения значений свойств объекта, а сеттеры - для их установки:</p>\n<pre><code class="lang-js">\nclass User {\n    constructor (name, age) {\n        this.name = name\n        this.age = age\n    }\n\n    #access = false\n\n    get access () {\n        return this.#access\n    }\n\n    set access (bool) {\n        this.#access = bool\n    }\n}\n\nconst user = new User(\'Ванька\', 30)\nconsole.log(user.#access) // SyntaxError: Private field \'#access\' must be declared in an enclosing class\n\nconsole.log(user.access) // false\nuser.access = true\nconsole.log(user.access) // true\n</code></pre>\n<p>Геттеры и сеттеры - это свойства, а методы - функции:</p>\n<pre><code class="lang-js">\nclass User {\n    constructor (name, age) {\n        this.name = name\n        this.age = age\n    }\n\n    #access = false\n\n    getAccess () {\n        return this.#access\n    }\n\n    setAccess(bool) {\n        this.#access = bool\n    }\n}\n\nconst user = new User(\'Ванька\', 30)\nconsole.log(user.#access) // SyntaxError: Private field \'#access\' must be declared in an enclosing class\n\nconsole.log(user.getAccess()) // false\nuser.setAccess(true)\nconsole.log(user.getAccess()) // true\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/property-accessors" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 196 --\x3e\n<section id="193">\n<h3>193. Как определить свойство в конструкторе объекта?</h3>\n<p>Для этого можно использовать метод Object.defineProperty(). Данный метод позволяет добавлять новые свойства к объекту и модифицировать существующие, а также изменять настройки доступа к объекту:</p>\n<pre><code class="lang-js">\n\'use strict\'\nconst obj = {}\n\nObject.defineProperty(obj, \'prop\', {\n    value: 1,\n    writable: false\n})\n\nconsole.log(obj.prop) // 1\nobj.prop = 2 // TypeError: Cannot assign to read only property \'prop\' of object \'#&lt;Object&gt;\'\n</code></pre>\n<p>В нестрогом режиме попытка изменить свойство только для чтения тихо завершится ничем.</p>\n<nav>\n<a href="https://learn.javascript.ru/property-descriptors" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 197 --\x3e\n<section id="194">\n<h3>194. В чем заключаются особенности геттеров и сеттеров?</h3>\n<p>Основными особенностями геттеров и сеттеров является следующее:</p>\n<ul>\n<li>Они имеют более простой по сравнению с методами синтаксис</li>\n<li>Используются для определения вычисляемых свойств - аксессоров</li>\n<li>Позволяют обеспечить одинаковые отношения между свойствами и методами</li>\n<li>Могут обеспечивать более высокое качество данных</li>\n<li>Позволяют выполнять задачи за сценой, когда речь идет об инкапсуляции</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/property-accessors" target="_blank">JSR</a>\n</nav>\n</section>\n\n\x3c!-- 198 --\x3e\n<section id="195">\n<h3>195. Можно ли добавить к объекту геттеры и сеттеры с помощью метода Object.defineProperty()?</h3>\n<p>Вполне:</p>\n<pre><code class="lang-js">\nconst obj = {counter: 0}\n\nObject.defineProperty(obj, \'increment\', {\n    get() {return ++this.counter}\n})\nObject.defineProperty(obj, \'decrement\', {\n    get() {return --this.counter}\n})\n\nObject.defineProperty(obj, \'sum\', {\n    set(val) {return this.counter += val}\n})\nObject.defineProperty(obj, \'sub\', {\n    set(val) {return this.counter -= val}\n})\n\nobj.sum = 10\nobj.sub = 5\nconsole.log(obj) // {counter: 5}\nconsole.log(obj.increment) // 6\nconsole.log(obj.decrement) // 5\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/property-descriptors" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 199 --\x3e\n<section id="196">\n<h3>196. Для чего используется switch...case?</h3>\n<p>switch...case является альтернативой if...else и представляет собой более наглядный способ выполнения кода в зависимости от переданного условия:</p>\n<pre><code class="lang-js">\nconst calc = (x, y, operator) =&gt; {\n    let result\n\n    try {\n        switch (operator) {\n            case \'+\':\n                result = x + y\n                break\n            case \'-\':\n                result = x - y\n                break\n            case \'*\':\n                result = x * y\n                break\n            case \'/\':\n                result = x / y\n                break\n            default:\n                throw new Error(\'Некорректная операция\')\n        }\n\n        if (isNaN(result)) {\n            throw new Error(\'Операнды должны быть числами\')\n        }\n\n        console.log(result)\n        return result\n    } catch (e) {\n        console.error(e.message)\n    }\n}\n\ncalc(1, 2, \'+\') // 3\ncalc(3, 4, \'*\') // 12\ncalc(\'a\', 1, \'-\') // Операнды должны быть числами\ncalc(5, 6, \'x\') // Некорректная операция\n</code></pre>\n<nav>\n<a href="https://learn.javascript.ru/switch" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 200 --\x3e\n<section id="197">\n<h3>197. Назовите правила использования switch...case</h3>\n<p>При использовании конструкции switch...case необходимо придерживаться следующих правил:</p>\n<ul>\n<li>условие может быть числом или строкой</li>\n<li>не допускается дублирование значений</li>\n<li>инструкция default является опциональной. Если ни для одного блока case не найдено совпадения, выполняется блок default</li>\n<li>break используется для остановки цикла</li>\n<li>break также является опциональным, но без него выполнение цикла продолжится</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/switch" target="_blank">JSR</a>\n<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch" target="_blank">MDN</a>\n</nav>\n</section>\n\n\x3c!-- 201 --\x3e\n<section id="198">\n<h3>198. Назовите примитивные типы данных.</h3>\n<p>Примитивными типами данных ("примитивами") в JavaScript являются следующие значения:</p>\n<ul>\n<li>number для любых чисел: целочисленных или чисел с плавающей точкой, целочисленные значения ограничены диапазоном ±2<sup>53</sup></li>\n<li>bigint для целых чисел произвольной длины</li>\n<li>string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа</li>\n<li>boolean для true/false</li>\n<li>null для неизвестных значений – отдельный тип, имеющий одно значение null</li>\n<li>undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined</li>\n<li>symbol для уникальных идентификаторов</li>\n</ul>\n<nav>\n<a href="https://learn.javascript.ru/types" target="_blank"></a>\n<a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Type" target="_blank">MDN</a>\n</nav>\n</section>\n<section id="article">\n<h3>Дополнительная литература</h3>\n<nav>\n<a href="https://habr.com/ru/company/ruvds/blog/482472/" target="_blank">Habr - Из чего сделан JavaScript?</a>\n<a href="https://habr.com/ru/company/ruvds/blog/477284/" target="_blank">Habr - Зачем в JavaScript нужен строгий режим?</a>\n<a href="https://medium.com/devschacht/javascript-coercions-9a36505c1370" target="_blank">Насколько JavaScript сильный?</a>\n<a href="https://medium.com/nmc-techblog/advanced-javascript-es6-temporal-dead-zone-default-parameters-and-let-vs-var-deep-dive-ca588fcde21b" target="_blank">Medium - Advanced JavaScript ES6 — Temporal Dead Zone, Default Parameters And Let vs Var — Deep dive!</a>\n<a href="https://habr.com/ru/post/517338/" target="_blank">JavaScript: область видимости простыми словами</a>\n<a href="https://medium.com/@stasonmars/%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86-%D0%B2-javascript-d91cbdd8916a" target="_blank">Делегирование событий в JavaScript</a>\n<a href="https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898" target="_blank">Medium - Понимаем замыкания в JavaScript. Раз и навсегда</a>\n<a href="https://habr.com/ru/company/ruvds/blog/513764/" target="_blank">Habr - Дэн Абрамов о замыканиях в JavaScript</a>\n<a href="https://medium.com/madhash/understanding-prototypes-in-javascript-e466244da086" target="_blank">Medium - Understanding Prototypes in JavaScript</a>\n<a href="https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D1%85-apply-call-%D0%B8-bind-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC%D1%83-javascript-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D1%83-ddd5f9b06290" target="_blank">Medium - Подробно о методах apply(), call() и bind(), необходимых каждому JavaScript разработчику</a>\n<a href="https://habr.com/ru/post/518386/" target="_blank">JavaScript: полное руководство по классам</a>\n<a href="https://medium.com/javascript-in-plain-english/javascript-classes-an-in-depth-look-part-1-47d8f4e77cbd" target="_blank">Medium - JavaScript Classes: An In-Depth look (Part 1)</a>\n<a href="https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D1%83%D1%82%D0%B0%D0%BD%D0%B8%D1%86%D0%B5%D0%B9-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-javascript-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D0%BC%D0%B8-slice-splice-%D0%B8-split-6e72363baf1d" target="_blank">Medium - Разбираемся с путаницей между JavaScript методами slice(), splice() и split()</a>\n<a href="https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff" target="_blank">Копирование объектов в JavaScript</a>\n<a href="https://habr.com/ru/company/ruvds/blog/480354/" target="_blank">Начало работы с методами JavaScript-массивов .map(), .filter() и .reduce()</a>\n<a href="https://medium.com/@stasonmars/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-reduce-%D0%B2-javascript-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D1%82%D1%8C-%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BA%D1%80%D1%83%D1%82%D1%8B%D0%B5-%D0%B2%D0%B5%D1%89%D0%B8-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%81-%D0%BD%D0%B8%D0%BC-b650c397bee6" target="_blank">Как работает reduce() в JavaScript</a>\n<a href="https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC-%D1%81-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B8%CC%86-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B5%D0%B8%CC%86-%D0%B2-ecmascript-2019-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-for-of-cc0baa81cdd8" target="_blank">Работаем с асинхронной итерацией в ECMAScript 2019, используя for-of</a>\n<a href="https://habr.com/ru/company/ruvds/blog/504586/" target="_blank">Новшества ES2020, которые мне очень нравятся</a>\n<a href="https://www.digitalocean.com/community/tutorials/understanding-map-and-set-objects-in-javascript-ru" target="_blank">DigitalOcean - Знакомство с объектами map и set в JavaScript</a>\n<a href="https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%BA%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-javascript-5ec4a1d88827" target="_blank">Medium - Понимаем каррирование в JavaScript</a>\n<a href="https://medium.com/@mike_wong/what-is-memoization-in-javascript-5c6cdef49ad2" target="_blank">Medium - What is Memoization in Javascript?</a>\n<a href="https://redd.one/blog/debounce-vs-throttle" target="_blank">Redd - Debounce vs Throttle: Definitive Visual Guide</a>\n<a href="https://habr.com/ru/company/ruvds/blog/511590/" target="_blank">Путь к пониманию шаблонных литералов в JavaScript</a>\n<a href="https://habr.com/ru/post/491252/" target="_blank">Habr - 5 малоизвестных возможностей JSON.stringify()</a>\n<a href="https://habr.com/ru/post/501198/" target="_blank">Habr - Понимание (всех) «модульных» форматов и инструментов JavaScript</a>\n<a href="https://habr.com/ru/company/ruvds/blog/466537/" target="_blank">Habr - Использование JavaScript-модулей в продакшне: современное состояние дел. Часть 1</a>\n<a href="https://habr.com/ru/post/491840/" target="_blank">Habr - Визуализация работы сервис-воркеров</a>\n<a href="https://developers.google.com/web/fundamentals/primers/service-workers" target="_blank">GoogleDevelopers - Service Workers: an Introduction</a>\n<a href="https://habr.com/ru/post/500834/" target="_blank">Habr - Хранилище для веба</a>\n<a href="https://webdevblog.ru/izuchaem-indexeddb/" target="_blank">WebDevBlog - Изучаем IndexedDB</a>\n<a href="https://developers.google.com/web/ilt/pwa/working-with-indexeddb" target="_blank">GoogleDevelopers - Working with IndexedDB</a>\n<a href="https://habr.com/ru/post/496348/" target="_blank">Habr - Web Storage API: примеры использования</a>\n<a href="https://habr.com/ru/company/ruvds/blog/479268/" target="_blank">Habr - Прослушиватели событий и веб-воркеры</a>\n<a href="https://medium.com/young-coder/a-simple-introduction-to-web-workers-in-javascript-b3504f9d9d1c" target="_blank"> Medium - A Simple Introduction to Web Workers in JavaScript</a>\n<a href="https://habr.com/ru/post/484466/" target="_blank">Habr - Распространенные ошибки при работе с промисами в JavaScript, о которых должен знать каждый</a>\n<a href="https://habr.com/ru/post/501702/" target="_blank">Habr - Визуализация промисов и Async/Await</a>\n<a href="https://habr.com/ru/post/514684/" target="_blank">Habr - Политика общего происхождения и CORS: визуальное руководство</a>\n</nav>\n</section>\n';
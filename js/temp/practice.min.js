export default'\n<h3>Что будет выведено в консоль?</h3>\n<div class="btn-box">\n<button data-name="game">Игра</button>\n</div>\n<a href="#bonus">Бонус</a><section id="1"><h3>Вопрос № 1</h3>\n<pre><code class="lang-js">\nfunction sayHi() {\n    console.log(name);\n    console.log(age);\n    var name = "Lydia";\n    let age = 21;\n}\n\nsayHi();\n</code></pre>\n<ul>\n<li>A: Lydia и undefined</li><li>B: Lydia и ReferenceError</li><li>C: ReferenceError и 21</li><li>D: undefined и ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nВ функции мы сначала определяем переменную name с помощью ключевого слова var. Это означает, что name поднимется в начало функции. Name будет иметь значение undefined до тех пор, пока выполнение кода не дойдет до строки, где ей присваивается значение Lydia. Мы не определили значение name, когда пытаемся вывести ее в консоль, поэтому будет выведено undefined. Переменные, определенные с помощью ключевого слова let (и const), также поднимаются, но в отличие от var, не инициализируются. Доступ к ним до инициализации невозможен. Это называется "временной мертвой зоной". Когда мы пытаемся обратиться к переменным до их определения, JavaScript выбрасывает исключение ReferenceError.\n</p>\n</article>\n</details>\n</section><section id="2"><h3>Вопрос № 2</h3>\n<pre><code class="lang-js">\nfor (var i = 0; i &lt; 3; i++) {\n    setTimeout(() =&gt; console.log(i), 1);\n}\n\nfor (let i = 0; i &lt; 3; i++) {\n    setTimeout(() =&gt; console.log(i), 1);\n}\n</code></pre>\n<ul>\n<li>A: 0 1 2 и 0 1 2</li><li>B: 0 1 2 и 3 3 3</li><li>C: 3 3 3 и 0 1 2</li><li>D: 3 3 3 и 3 3 3</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nИз-за очереди событий в JavaScript функция setTimeout вызывается после завершения цикла. Так как переменная i в первом цикле определяется с помощью ключевого слова var, она является глобальной. В цикле мы каждый раз увеличиваем значение i на 1, используя оператор ++. К моменту выполнения setTimeout в первом примере значение i равняется 3. Во втором цикле i определяется с помощью let. Такие переменные (а также переменные, объявленные с помощью const) имеют блочную область видимости (блок - это код внутри {}). На каждой итерации i будет иметь новое значение, и это значение будет замкнуто в области видимости внутри цикла.\n</p>\n</article>\n</details>\n</section><section id="3"><h3>Вопрос № 3</h3>\n<pre><code class="lang-js">\nconst shape = {\n    radius: 10,\n    diameter() {\n        return this.radius * 2;\n    },\n    perimeter: () =&gt; 2 * Math.PI * this.radius\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());\n</code></pre>\n<ul>\n<li>A: 20 и 62.83185307179586</li><li>B: 20 и NaN</li><li>C: 20 и 63</li><li>D: NaN и 63</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nОбратите внимание, что diameter - это обычная функция, а perimeter - стрелочная. У стрелочных функций, в отличие от обычных, значение this указывает на лексическое окружение. Это значит, что при вызове perimeter ее this указывает не на объект shape, а на внешнюю область видимости (объект window). У этого объекта нет свойства radius, поэтому возвращается undefined.\n</p>\n</article>\n</details>\n</section><section id="4"><h3>Вопрос № 4</h3>\n<pre><code class="lang-js">\nconsole.log(+true);\nconsole.log(!"Lydia");\n</code></pre>\n<ul>\n<li>A: 1 и false</li><li>B: 0 и true</li><li>C: false и NaN</li><li>D: false и false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nУнарный плюс приводит операнд к числу. true - это 1, а false - 0. Строка \'Lydia\' - это истинное значение. Мы спрашиваем, является ли это истинное значение ложным? Ответ: false.\n</p>\n</article>\n</details>\n</section><section id="5"><h3>Вопрос № 5</h3>\n<pre><code class="lang-js">\nlet c = { greeting: "Hey!" };\nlet d;\n\nd = c;\nc.greeting = "Hello";\nconsole.log(d.greeting);\n</code></pre>\n<ul>\n<li>A: Hello</li><li>B: Hey!</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nВ JavaScript все объекты являются "ссылочными" типами данных, т.е. значения объектов передаются по ссылке. Сначала в переменной "c" создается ссылка на объект. Затем мы указываем переменной "d" ссылаться на тот же объект, что и "c". При изменении объекта меняются значения всех указывающих на него ссылок.\n</p>\n</article>\n</details>\n</section><section id="6"><h3>Вопрос № 6</h3>\n<pre><code class="lang-js">\nlet a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n</code></pre>\n<ul>\n<li>A: true false true</li><li>B: false false true</li><li>C: true false false</li><li>D: false true true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nnew Number() - это встроенный конструктор функции. И хотя он выглядит как число, это не настоящее число: у него есть ряд дополнительных возможностей, это объект. Оператор == разрешает приведение типов, он проверяет равенство значений. Оба значения равны 3, поэтому возвращается true. При использовании оператора === значение и тип должны совпадать. В данном случае это не так: new Number() это не число, а объект. Поэтому два последних сравнения возвращают false.\n</p>\n</article>\n</details>\n</section><section id="7"><h3>Вопрос № 7</h3>\n<pre><code class="lang-js">\nclass Chameleon {\n    static colorChange(newColor) {\n        this.newColor = newColor;\n        return this.newColor;\n    }\n\n    constructor({ newColor = "green" } = {}) {\n            this.newColor = newColor;\n        }\n    }\n\nconst freddie = new Chameleon({ newColor: "purple" });\nfreddie.colorChange("orange");\n</code></pre>\n<ul>\n<li>A: orange</li><li>B: purple</li><li>C: green</li><li>D: TypeError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nФункция colorChange() является статичной. Статичные методы не имеют доступа к экземплярам класса. Так как freddie - это экземпляр, статичный метод в нем не доступен. Поэтому выбрасывается исключение TypeError.\n</p>\n</article>\n</details>\n</section><section id="8"><h3>Вопрос № 8</h3>\n<pre><code class="lang-js">\nlet greeting;\ngreetign = {}; // опечатка\nconsole.log(greetign);\n</code></pre>\n<ul>\n<li>A: {}</li><li>B: ReferenceError: greetign is not defined</li><li>C: undefined</li><li>D: ""</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nС помощью greetign = {} мы создаем новый глобальный пустой объект, который и выводится в консоль. Когда мы вместо greeting написали greetign, компилятор выполнил global.greetign = {} в Node.js (или window.greetign = {} в браузере). В строгом режиме (\'use strict\') будет выброшено исключение ReferenceError: greetign is not defined.\n</p>\n</article>\n</details>\n</section><section id="9"><h3>Вопрос № 9</h3>\n<pre><code class="lang-js">\nfunction bark() {\n    console.log("Woof!");\n}\n\nbark.animal = "dog";\n\nconsole.log(bark.animal);\n</code></pre>\n<ul>\n<li>A: \'dog\'</li><li>B: SyntaxError</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nВ JavaScript такое возможно, т.к. функции - это объекты. Точнее, функция — это специальный тип объекта, который можно вызывать. Кроме того, функция — это объект со свойствами. Свойства такого объекта нельзя вызывать, поскольку они не являются функциями.\n</p>\n</article>\n</details>\n</section><section id="10"><h3>Вопрос № 10</h3>\n<pre><code class="lang-js">\nfunction Person(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\nconst member = new Person("Lydia", "Hallie");\nPerson.getFullName = function () {\n    return `&#36;{this.firstName} &#36;{this.lastName}`;\n}\n\nconsole.log(member.getFullName());\n</code></pre>\n<ul>\n<li>A: TypeError</li><li>B: SyntaxError</li><li>C: Lydia Hallie</li><li>D: undefined undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nНельзя добавлять свойства к конструктору как к обычному объекту. Если необходимо добавить свойство или метод всем экземплярам, то следует использовать прототипы. В данном случае Person.prototype.getFullName = function () { return `&#36;{this.firstName} &#36;{this.lastName}` } сделает метод member.getFullName() рабочим. В чем тут преимущество? Предположим, что мы добавили этот метод к конструктору. Возможно, не каждому экземпляру Person нужен этот метод. Это приведет к большим потерям памяти, т.к. все экземпляры будут иметь указанное свойство. Напротив, если мы добавим данный метод к прототипу, у нас будет только одно место в памяти, к которому смогут обращаться все экземпляры.\n</p>\n</article>\n</details>\n</section><section id="11"><h3>Вопрос № 11</h3>\n<pre><code class="lang-js">\nfunction Person(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\nconst lydia = new Person("Lydia", "Hallie");\nconst sarah = Person("Sarah", "Smith");\n\nconsole.log(lydia);\nconsole.log(sarah);\n</code></pre>\n<ul>\n<li>A: Person {firstName: "Lydia", lastName: "Hallie"} и undefined</li><li>B: Person {firstName: "Lydia", lastName: "Hallie"} и Person {firstName: "Sarah", lastName: "Smith"}</li><li>C: Person {firstName: "Lydia", lastName: "Hallie"} и {}</li><li>D: Person {firstName: "Lydia", lastName: "Hallie"} и ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nМы создаем объект sarah без ключевого слова new. Использование new приводит к созданию нового объекта (экземпляра). Без new создается глобальный объект. Мы указали, что this.firstName равняется "Sarah" и this.lastName - "Smith". На самом деле, мы определили global.firstName = \'Sarah\' и global.lastName = \'Smith\'. sarah = undefined, поскольку мы не возвращаем значение из Person.\n</p>\n</article>\n</details>\n</section><section id="12"><h3>Вопрос № 12</h3>\n<pre><code class="lang-js">\nfunction sum(a, b) {\n    return a + b;\n}\n\nconsole.log(sum(1, "2"));\n</code></pre>\n<ul>\n<li>A: NaN</li><li>B: TypeError</li><li>C: "12"</li><li>D: 3</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nJavaScript - это динамически типизированный язык (язык со слабой типизацией): мы не определяем тип данных. Значения переменных могут быть автоматически преобразованы из одного типа в другой без нашего участия, что называется неявным приведением типов. Приведение - это преобразование данных из одного типа в другой. В примере JavaScript конвертировал число 1 в строку, чтобы операция в функции имела смысл и вернула хоть какое-то значение. Во время сложения числа (1) и строки ("2") число преобразовывается в строку. Мы можем конкатенировать (объединять) строки так: "Hello" + "World". Таким образом, 1 + "2" возвращает "12".\n</p>\n</article>\n</details>\n</section><section id="13"><h3>Вопрос № 13</h3>\n<pre><code class="lang-js">\nlet number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);\n</code></pre>\n<ul>\n<li>A: 1 1 2</li><li>B: 1 2 2</li><li>C: 0 2 2</li><li>D: 0 1 2</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nПостфиксный оператор ++:<br>\nВозвращает значение (0)<br>\nИнкрементирует (увеличивает) значение (теперь number = 1)<br>\nПрефиксный оператор ++:<br>\nИнкрементирует значение (теперь number = 2)<br>\nВозвращает значение (2)<br>\nРезультат: 0 2 2.\n</p>\n</article>\n</details>\n</section><section id="14"><h3>Вопрос № 14</h3>\n<pre><code class="lang-js">\nfunction getPersonInfo(one, two, three) {\n    console.log(one);\n    console.log(two);\n    console.log(three);\n}\n\nconst person = "Lydia";\nconst age = 21;\n\ngetPersonInfo`&#36;{person} is &#36;{age} years old`;\n</code></pre>\n<ul>\n<li>A: "Lydia" 21 ["", " is ", " years old"]</li><li>B: ["", " is ", " years old"] "Lydia" 21</li><li>C: "Lydia" ["", " is ", " years old"] 21</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nПри использовании тегированных шаблонных (строковых) литералов первым аргументом является массив строковых значений. Прочими аргументами являются переданные значения.\n</p>\n</article>\n</details>\n</section><section id="15"><h3>Вопрос № 15</h3>\n<pre><code class="lang-js">\nfunction checkAge(data) {\n    if (data === { age: 18 }) {\n        console.log("Ты взрослый!");\n    } else if (data == { age: 18 }) {\n        console.log("Ты по-прежнему взрослый.");\n    } else {\n        console.log("Хм... Кажется, у тебя нет возраста.");\n    }\n}\n\ncheckAge({ age: 18 });\n</code></pre>\n<ul>\n<li>A: Ты взрослый!</li><li>B: Ты по-прежнему взрослый.</li><li>C: Хм... Кажется, у тебя нет возраста.</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nВ операциях сравнения примитивы сравниваются по значениям, а объекты - по ссылкам. JavaScript проверяет, чтобы объекты указывали на одну и ту же область памяти. Сравниваемые объекты в примере не такие: объект, переданный в качестве параметра, указывает на другую область памяти, нежели объекты, используемые в сравнениях. Поэтому { age: 18 } === { age: 18 } и { age: 18 } == { age: 18 } возвращают false.\n</p>\n</article>\n</details>\n</section><section id="16"><h3>Вопрос № 16</h3>\n<pre><code class="lang-js">\nfunction getAge(...args) {\n    console.log(typeof args);\n}\n\ngetAge(21);\n</code></pre>\n<ul>\n<li>A: "number"</li><li>B: "array"</li><li>C: "object"</li><li>D: "NaN"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОператор распространения (spread) ...args возвращает массив с аргументами. Массив - это объект, поэтому typeof args возвращает "object".\n</p>\n</article>\n</details>\n</section><section id="17"><h3>Вопрос № 17</h3>\n<pre><code class="lang-js">\nfunction getAge() {\n    "use strict";\n    age = 21;\n    console.log(age);\n}\n\ngetAge();\n</code></pre>\n<ul>\n<li>A: 21</li><li>B: undefined</li><li>C: ReferenceError</li><li>D: TypeError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\n"use strict" позволяет избежать случайного объявления глобальных переменных. Мы не объявляли переменную age, поэтому в строгом режиме выбрасывается исключение ReferenceError. В нестрогом режиме ошибки не возникнет, а переменная age станет свойством глобального объекта.\n</p>\n</article>\n</details>\n</section><section id="18"><h3>Вопрос № 18</h3>\n<pre><code class="lang-js">\nconst sum = eval("10*10+5");\n\nconsole.log(sum);\n</code></pre>\n<ul>\n<li>A: 105</li><li>B: "105"</li><li>C: TypeError</li><li>D: "10*10+5"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\neval выполняет код, переданный в виде строки. Если это выражение (как в данном случае), то оно вычисляется (оценивается). Выражение 10 * 10 + 5 возвращает число 105. Использовать eval в настоящее время не рекомендуется.\n</p>\n</article>\n</details>\n</section><section id="19"><h3>Вопрос № 19</h3>\n<pre><code class="lang-js">\nvar num = 8;\nvar num = 10;\n\nconsole.log(num);\n</code></pre>\n<ul>\n<li>A: 8</li><li>B: 10</li><li>C: SyntaxError</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью ключевого слова var можно определять любое количество одноименных переменных. Переменная будет хранить последнее присвоенное значение. Но такой трюк нельзя проделать с let и const, т.к. они имеют блочную область видимости.\n</p>\n</article>\n</details>\n</section><section id="20"><h3>Вопрос № 20</h3>\n<pre><code class="lang-js">\nconst obj = { 1: "a", 2: "b", 3: "c" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nconsole.log(obj.hasOwnProperty("1"));\nconsole.log(obj.hasOwnProperty(1));\nconsole.log(set.has("1"));\nconsole.log(set.has(1));\n</code></pre>\n<ul>\n<li>A: false true false true</li><li>B: false true true true</li><li>C: true true false true</li><li>D: true true true true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nКлючи объектов (кроме Symbol) являются строками, даже если заданы не в виде строк. Поэтому obj.hasOwnProperty(\'1\') также возвращает true. Однако, это не работает применительно к set. Значение \'1\' отсутствует в set: set.has(\'1\') возвращает false, а set.has(1) = true.\n</p>\n</article>\n</details>\n</section><section id="21"><h3>Вопрос № 21</h3>\n<pre><code class="lang-js">\nconst obj = { a: "one", b: "two", a: "three" };\nconsole.log(obj);\n</code></pre>\n<ul>\n<li>A: { a: "one", b: "two" }</li><li>B: { b: "two", a: "three" }</li><li>C: { a: "three", b: "two" }</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nЕсли имеется два ключа с одинаковым именем, то ключ перезаписывается. Его позиция сохраняется, но значением является последнее из присвоенных.\n</p>\n</article>\n</details>\n</section><section id="22"><h3>Вопрос № 22</h3>\n<pre><code class="lang-js">\nfor (let i = 1; i &lt; 5; i++) {\n    if (i === 3) continue;\n    console.log(i);\n}\n</code></pre>\n<ul>\n<li>A: 1 2</li><li>B: 1 2 3</li><li>C: 1 2 4</li><li>D: 1 3 4</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОператор continue пропускает итерацию, если условие является истинным.\n</p>\n</article>\n</details>\n</section><section id="23"><h3>Вопрос № 23</h3>\n<pre><code class="lang-js">\nString.prototype.giveLydiaPizza = () =&gt; {\n    return "Just give Lydia pizza already!";\n};\n\nconst name = "Lydia";\n\nconsole.log(name.giveLydiaPizza());\n</code></pre>\n<ul>\n<li>A: "Just give Lydia pizza already!"</li><li>B: TypeError: name.giveLydiaPizza is not a function</li><li>C: SyntaxError</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nString - это встроенный конструктор, к которому можно добавлять свойства. Мы добавили метод к его прототипу. Строки-примитивы автоматически конвертируются (преобразуются) в строки-объекты. Поэтому все строки (объекты) имеют доступ к указанному методу.\n</p>\n</article>\n</details>\n</section><section id="24"><h3>Вопрос № 24</h3>\n<pre><code class="lang-js">\nconst a = {};\nconst b = { key: "b" };\nconst c = { key: "c" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n</code></pre>\n<ul>\n<li>A: 123</li><li>B: 456</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nКлючи объекта автоматически преобразуются в строки. Мы пытаемся добавить объект в качестве ключа к объекту "a" со значением 123. Однако, когда мы приводим объект к строке, он превращается в "[object Object]". Таким образом, мы говорим, что a["object Object"] = 123. Затем мы повторяем процедуру. "c" - это другой объект, который мы неявно приводим к строке. Поэтому a["object Object"] = 456. Наконец, когда мы выводим a[b] в консоль, мы на самом деле выводим a["object Object"]. Поэтому в консоль выводится 456.\n</p>\n</article>\n</details>\n</section><section id="25"><h3>Вопрос № 25</h3>\n<pre><code class="lang-js">\nconst foo = () =&gt; console.log("First");\nconst bar = () =&gt; setTimeout(() =&gt; console.log("Second"));\nconst baz = () =&gt; console.log("Third");\n\nbar();\nfoo();\nbaz();\n</code></pre>\n<ul>\n<li>A: First Second Third</li><li>B: First Third Second</li><li>C: Second First Third</li><li>D: Second Third First</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nСначала мы вызываем функцию setTimeout. Однако, она выводится в консоль последней. Это происходит из-за того, что в браузерах у нас есть не только движок для запуска (выполнения) кода, но и WebAPI. WebAPI предоставляет нам функцию setTimeout и множество других возможностей. Например, DOM. После того, как колбек отправляется в WebAPI, функция setTimeout (но не колбек!) удаляется из стека вызовов (call stack). После этого вызывается foo, и "First" выводится в консоль. foo удаляется из стека и вызывается baz. "Third" выводится в консоль. WebAPI отправляет функцию обратного вызова в очередь событий (event loop). Event loop проверяет стек вызовов и очередь (макро)задач. Если стек является пустым, то в него помещается первый элемент из очереди. Вызывается bar и в консоль выводится "Second".\n</p>\n</article>\n</details>\n</section><section id="26"><h3>Вопрос № 26</h3>\n<pre><code class="lang-js">\n&lt;div onclick="console.log(\'div\')"&gt;\n    &lt;p onclick="console.log(\'p\')"&gt;\n        Нажми на меня!\n    &lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<ul>\n<li>A: p div</li><li>B: div p</li><li>C: p</li><li>D: div</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nПосле клика по "p" в консоль будет выведено "p" и "div". Цикл события имеет три фазы: захват, цель и всплытие. По умолчанию обработчики событий выполняются на фазе всплытия (если не установлен useCapture: true). Всплытие идет от самого глубоко вложенного элемента до самого внешнего.\n</p>\n</article>\n</details>\n</section><section id="27"><h3>Вопрос № 27</h3>\n<pre><code class="lang-js">\nconst person = { name: "Lydia" };\n\nfunction sayHi(age) {\n    console.log(`&#36;{this.name} is &#36;{age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);\n</code></pre>\n<ul>\n<li>A: undefined is 21 Lydia is 21</li><li>B: function function</li><li>C: Lydia is 21 Lydia is 21</li><li>D: Lydia is 21 function</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nВ обоих случаях мы передаем объект, на который будет указывать this. Но call() выполняется сразу, а bind() возвращает копию функции с привязанным контекстом. Ее следует вызывать отдельно или можно сделать так: sayHi.bind(person, 21)().\n</p>\n</article>\n</details>\n</section><section id="28"><h3>Вопрос № 28</h3>\n<pre><code class="lang-js">\nfunction sayHi() {\n    return (() =&gt; 0)();\n}\n\nconsole.log(typeof sayHi());\n</code></pre>\n<ul>\n<li>A: "object"</li><li>B: "number"</li><li>C: "function"</li><li>D: "undefined"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nФункция sayHi возвращает значение немедленно вызываемого функционального выражения (IIFE). Результатом является 0 типа number. Для информации: в JS имеется 8 встроенных типов данных: null, undefined, boolean, number, string, object, symbol и bigint. function не является отдельным типом, функции - это объекты.\n</p>\n</article>\n</details>\n</section><section id="29"><h3>Вопрос № 29</h3>\n<pre><code class="lang-js">\nconsole.log(typeof typeof 1);\n</code></pre>\n<ul>\n<li>A: "number"</li><li>B: "string"</li><li>C: "object"</li><li>D: "undefined"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\ntypeof 1 возвращает "number". typeof "number" возвращает "string".\n</p>\n</article>\n</details>\n</section><section id="30"><h3>Вопрос № 30</h3>\n<pre><code class="lang-js">\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n</code></pre>\n<ul>\n<li>A: [1, 2, 3, 7 x null, 11]</li><li>B: [1, 2, 3, 11]</li><li>C: [1, 2, 3, 7 x empty, 11]</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nКогда в массив добавляется значение, которое выходит за пределы длины массива, JavaScript создает "пустые ячейки". На самом деле они имеют значения undefined, но в консоль выводятся как [1, 2, 3, 7 x empty, 11] (в браузере, зависит от среды выполнения кода).\n</p>\n</article>\n</details>\n</section><section id="31"><h3>Вопрос № 31</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    let x, y;\n    try {\n        throw new Error();\n    } catch (x) {\n        (x = 1), (y = 2);\n        console.log(x);\n    }\n    console.log(x);\n    console.log(y);\n})();\n</code></pre>\n<ul>\n<li>A: 1 undefined 2</li><li>B: undefined undefined undefined</li><li>C: 1 1 2</li><li>D: 1 undefined undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nБлок catch получает аргумент "x". Это не тот "x", который объявлен перед try. Затем мы присваиваем этому аргументу значение 1 и присваиваем значение переменной "y". После этого выводим в консоль значение "x", т.е. 1. За пределами catch "x" все еще имеет значение undefined, а y = 2. Когда мы вызываем console.log(x) за пределами catch, возвращается undefined, а console.log(y) = 2.\n</p>\n</article>\n</details>\n</section><section id="32"><h3>Вопрос № 32</h3>\n<pre><code class="lang-js">\nconst result =\n    [[0, 1], [2, 3]].reduce(\n        (acc, cur) =&gt; {\n            return acc.concat(cur);\n        },\n        [1, 2]\n    );\n\nconsole.log(result);\n</code></pre>\n<ul>\n<li>A: [0, 1, 2, 3, 1, 2]</li><li>B: [6, 1, 2]</li><li>C: [1, 2, 0, 1, 2, 3]</li><li>D: [1, 2, 6]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\n[1, 2] - начальное значение переменной acc. После первого прохода acc равняется [1, 2], а cur - [0, 1]. После конкатенации acc равняется [1, 2, 0, 1], а cur - [2, 3]. После их объединения мы получаем [1, 2, 0, 1, 2, 3].\n</p>\n</article>\n</details>\n</section><section id="33"><h3>Вопрос № 33</h3>\n<pre><code class="lang-js">\nconsole.log(!!null);\nconsole.log(!!"");\nconsole.log(!!1);\n</code></pre>\n<ul>\n<li>A: false true false</li><li>B: false false true</li><li>C: false true true</li><li>D: true true false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nnull - false. !null возвращает true. !true возвращает false.<br>\n"" - false. !"" возвращает true. !true возвращает false.\n1 - true. !1 возвращает false. !false возвращает true.\n</p>\n</article>\n</details>\n</section><section id="34"><h3>Вопрос № 34</h3>\n<pre><code class="lang-js">\nconsole.log([..."Lydia"]);\n</code></pre>\n<ul>\n<li>A: ["L", "y", "d", "i", "a"]</li><li>B: ["Lydia"]</li><li>C: [[], "Lydia"]</li><li>D: [["L", "y", "d", "i", "a"]]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nСтрока является итерируемой сущностью. Оператор распространения (spread) ... преобразует строку в массив, состоящий из символов этой строки.\n</p>\n</article>\n</details>\n</section><section id="35"><h3>Вопрос № 35</h3>\n<pre><code class="lang-js">\nfunction* generator(i) {\n    yield i;\n    yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);\n</code></pre>\n<ul>\n<li>A: [0, 10], [10, 20]</li><li>B: 20, 20</li><li>C: 10, 20</li><li>D: 0, 10 and 10, 20</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nВыполнение обычных функций не может быть остановлено после их запуска. Однако, генераторы можно останавливать в процессе выполнения, а затем продолжать с места остановки. Каждый раз, когда в функции-генераторе встречается ключевое слово yield, функция возвращает значение, указанное после него. Обратите внимание, что в генераторе вместо return используется yield.<br>\nСначала мы инициализируем генератор с i равным 10. Мы вызываем генератор, используя метод next(). Когда мы в первый раз вызываем генератор, i равно 10. Движок JavaScript встречает первое ключевое слово yield, возвращая значение i. После этого выполнение функции приостанавливается, и 10 выводится в консоль. Затем мы снова вызываем функцию посредством next(). Она запускается с того места, где остановилась, с i = 10. Компилятор встречает следующее ключевое слово yield и возвращает i * 2. i равно 10, поэтому возвращается 10 * 2, т.е. 20.\n</p>\n</article>\n</details>\n</section><section id="36"><h3>Вопрос № 36</h3>\n<pre><code class="lang-js">\nconst firstPromise = new Promise((res, rej) =&gt; {\n    setTimeout(res, 500, "один");\n});\n\nconst secondPromise = new Promise((res, rej) =&gt; {\n    setTimeout(res, 100, "два");\n});\n\nPromise.race([firstPromise, secondPromise]).then(res =&gt; console.log(res));\n</code></pre>\n<ul>\n<li>A: "один"</li><li>B: "два"</li><li>C: "два" "один"</li><li>D: "один" "два"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nКогда мы передаем несколько промисов методу Promise.race(), он возвращает первый разрешенный/отклоненный промис. В метод setTimeout мы передаем таймер: 500 мс для первого промиса и 100 мс для второго. Это означает, что secondPromise разрешается первым со значением \'два\'. res имеет значение \'два\', которое и выводиться в консоль.\n</p>\n</article>\n</details>\n</section><section id="37"><h3>Вопрос № 37</h3>\n<pre><code class="lang-js">\nlet person = { name: "Lydia" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);\n</code></pre>\n<ul>\n<li>A: null</li><li>B: [null]</li><li>C: [{}]</li><li>D: [{ name: "Lydia" }]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nСначала мы объявляем переменную person со значением объекта со свойством name. Затем мы объявляем переменную members. Мы делаем первый элемент этого массива равным person. Объекты взаимодействуют посредством ссылок при установке их равными друг другу. Когда вы назначаете ссылку из одной переменной в другую, вы создаете копию этой ссылки (обратите внимание, что у этих переменных не одинаковые ссылки). Затем мы присваиваем переменной person значение null. Мы изменили только значение person, а не первый элемент массива, поскольку этот элемент имеет другую (скопированную) ссылку на объект. Первый элемент в members по-прежнему содержит ссылку на исходный объект. Когда мы выводим в консоль массив members, первый элемент содержит значение объекта, который и выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="38"><h3>Вопрос № 38</h3>\n<pre><code class="lang-js">\nconst person = {\n    name: "Lydia",\n    age: 21\n};\n\nfor (const item in person) {\n    console.log(item);\n}\n</code></pre>\n<ul>\n<li>A: { name: "Lydia" }, { age: 21 }</li><li>B: "name", "age"</li><li>C: "Lydia", 21</li><li>D: ["name", "Lydia"], ["age", 21]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью цикла for-in мы перебираем ключи объекта, в данном случае name и age. Под катом ключи объекта являются строками (если они не являются Symbol). В каждом цикле мы устанавливаем значение item равным текущему ключу, по которому он перебирается. Сначала item равен name, и выводится в консоль. Затем item равен age, что также выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="39"><h3>Вопрос № 39</h3>\n<pre><code class="lang-js">\nconsole.log(3 + 4 + "5");\n</code></pre>\n<ul>\n<li>A: "345"</li><li>B: "75"</li><li>C: 12</li><li>D: "12"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nАссоциативность операторов - это порядок оценивания выражения компилятором, слева направо или справа налево. Это происходит только в том случае, если все операторы имеют одинаковый приоритет. У нас есть только один тип оператора: +. Ассоциативность - слева направо. 3 + 4 оценивается первым. Это приводит к числу 7. 7 + \'5\' приводит к \'75\' из-за неявного приведения типов. JavaScript преобразует число 7 в строку. Мы можем объединить (конкатенировать) две строки, используя оператор +. "7" + "5" = "75".\n</p>\n</article>\n</details>\n</section><section id="40"><h3>Вопрос № 40</h3>\n<pre><code class="lang-js">\nconst num = parseInt("7*6", 10);\n\nconsole.log(num);\n</code></pre>\n<ul>\n<li>A: 42</li><li>B: "42"</li><li>C: 7</li><li>D: NaN</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nParseInt проверяет, являются ли символы в строке допустимыми с точки зрения используемой системы счисления (второй аргумент). Как только он встречает недопустимый символ, синтаксический анализ строки прекращается и последующие символы игнорируются. * не является допустимым числом. Поэтому parseInt прекращает разбор строки и возвращает 7.\n</p>\n</article>\n</details>\n</section><section id="41"><h3>Вопрос № 41</h3>\n<pre><code class="lang-js">\nconst result =\n    [1, 2, 3].map(num =&gt; {\n        if (typeof num === "number") return;\n        return num * 2;\n    });\n\nconsole.log(result)\n</code></pre>\n<ul>\n<li>A: []</li><li>B: [null, null, null]</li><li>C: [undefined, undefined, undefined]</li><li>D: [ 3 x empty ]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nМетод map возвращает новый массив с обработанными каким-либо образом с помощью функции обратного вызова элементами исходного массива. В данном случае элементы исходного массива являются числами, поэтому условие if typeof num === "number" является истинным. После этого выполнение функции останавливается, в новый массив попадает значение num, равное undefined.\n</p>\n</article>\n</details>\n</section><section id="42"><h3>Вопрос № 42</h3>\n<pre><code class="lang-js">\nfunction getInfo(member, year) {\n    member.name = "Lydia";\n    year = 1998;\n}\n\nconst person = { name: "Sarah" };\nconst birthYear = "1997";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);\n</code></pre>\n<ul>\n<li>A: { name: "Lydia" }, "1997"</li><li>B: { name: "Sarah" }, "1998"</li><li>C: { name: "Lydia" }, "1998"</li><li>D: { name: "Sarah" }, "1997"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nАргументы передаются по значению. Если значение аргумента является объектом, то он передается по ссылке. birthYear передается по значению, поскольку это строка, а не объект. Когда мы передаем аргументы по значению, создается копия этого значения. Переменная birthYear ссылается на значение "1997". Аргумент year также ссылается на значение "1997", но это не то значение, на которое ссылается birthYear. Когда мы обновляем значение year, устанавливая year равным "1998", мы обновляем только значение year. birthYear по-прежнему равняется "1997". Значение person является объектом. Аргумент member имеет скопированную ссылку на этот объект. Когда мы изменяем свойство объекта, на который ссылается member, значение person также меняется, поскольку они ссылаются на один и тот же объект. Свойство name объекта person становится равным значению "Lydia".\n</p>\n</article>\n</details>\n</section><section id="43"><h3>Вопрос № 43</h3>\n<pre><code class="lang-js">\nfunction greeting() {\n    throw "Hello world!";\n}\n\nfunction sayHi() {\n    try {\n        const data = greeting();\n        console.log("Работает!", data);\n    } catch (e) {\n        console.log("Ошибка:", e);\n    }\n}\n\nsayHi();\n</code></pre>\n<ul>\n<li>A: Работает! Hello world!</li><li>B: Ошибка: undefined</li><li>C: SyntaxError: can only throw Error objects</li><li>D: Ошибка: Hello world!</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nС помощью оператора throw мы можем создавать собственные ошибки. Мы можем генерировать пользовательские исключения. Исключением может быть строка, число, логическое значение или объект. В данном случае исключением является строка \'Hello world\'. С помощью оператора catch мы можем указать, что делать, если в блоке try возникнет ошибка. Исключение - \'Hello world\'. \'e\' равняется этой строке. Это приводит к \'Ошибка: Hello world\'.\n</p>\n</article>\n</details>\n</section><section id="44"><h3>Вопрос № 44</h3>\n<pre><code class="lang-js">\nfunction Car() {\n    this.make = "Lamborghini";\n    return { make: "Maserati" };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);\n</code></pre>\n<ul>\n<li>A: "Lamborghini"</li><li>B: "Maserati"</li><li>C: ReferenceError</li><li>D: TypeError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nКогда возвращается свойство, его значение равняется возвращаемому значению, а не значению, установленному в конструкторе функции. Мы возвращаем строку "Maserati", поэтому значением myCar.make является "Maserati".\n</p>\n</article>\n</details>\n</section><section id="45"><h3>Вопрос № 45</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\n</code></pre>\n<ul>\n<li>A: "undefined", "number"</li><li>B: "number", "number"</li><li>C: "object", "number"</li><li>D: "number", "undefined"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nlet x = y = 10 на самом деле является сокращением для:\n</p><pre><code class="lang-js">\ny = 10;\nlet x = y;\n</code></pre>\nКогда мы устанавливаем y равным 10, мы фактически добавляем свойство "y" к глобальному объекту (window в браузере, global в Node.js). В браузере window.y теперь равняется 10. Затем мы объявляем переменную "x" со значением "y". Переменные, объявленные с помощью ключевого слова let, имеют блочную область видимости, они определены только в блоке, в котором объявлены; таким блоком в данном случае является немедленно вызываемое функциональное выражение (IIFE). Когда мы используем оператор typeof, операнд "x" не определен: мы пытаемся получить доступ к "x" вне блока, в котором он объявлен. Это означает, что x = undefined. Переменные, которым не присвоено значение, имеют значение undefined. console.log(typeof x) возвращает undefined. Однако, мы создали глобальную переменную "y", присвоив ей значение 10. Это значение доступно в любом месте кода. "y" определена и содержит значение типа number. console.log(typeof y) возвращает number.\n<p></p>\n</article>\n</details>\n</section><section id="46"><h3>Вопрос № 46</h3>\n<pre><code class="lang-js">\nclass Dog {\n    constructor(name) {\n      this.name = name;\n    }\n}\n\nDog.prototype.bark = function() {\n    console.log(`Woof I am &#36;{this.name}`);\n};\n\nconst pet = new Dog("Mara");\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();\n</code></pre>\n<ul>\n<li>A: "Woof I am Mara", TypeError</li><li>B: "Woof I am Mara", "Woof I am Mara"</li><li>C: "Woof I am Mara", undefined</li><li>D: TypeError, TypeError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nМы можем удалять свойства объектов с помощью ключевого слова delete, включая свойства прототипов. Удаленное свойство прототипа становится недоступным в цепочке прототипов. Другими словами, функция bark больше не доступна в прототипе после delete Dog.prototype.bark, однако мы пытаемся получить к ней доступ. Когда мы пытаемся вызвать нечто, не являющееся функцией, выбрасывается исключение TypeError. В данном случае TypeError: pet.bark is not a function, поскольку значением pet.bark является undefined.\n</p>\n</article>\n</details>\n</section><section id="47"><h3>Вопрос № 47</h3>\n<pre><code class="lang-js">\nconst set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);\n</code></pre>\n<ul>\n<li>A: [1, 1, 2, 3, 4]</li><li>B: [1, 2, 3, 4]</li><li>C: {1, 1, 2, 3, 4}</li><li>D: {1, 2, 3, 4}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОбъект Set является коллекцией уникальных значений. Мы передаем массив [1, 1, 2, 3, 4] с повторяющимся значением 1. Поскольку в наборе не может быть двух одинаковых значений, одно из них удаляется. Это приводит к {1, 2, 3, 4}.\n</p>\n</article>\n</details>\n</section><section id="48"><h3>Вопрос № 48</h3>\n<pre><code class="lang-js">\n// counter.js\nlet counter = 10;\nexport default counter;\n\n// index.js\nimport myCounter from "./counter";\n\nmyCounter += 1;\n\nconsole.log(myCounter);\n</code></pre>\n<ul>\n<li>A: 10</li><li>B: 11</li><li>C: Error</li><li>D: NaN</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nИмпортированный модуль доступен только для чтения: мы не можем его изменить. Это можно сделать только при экпорте. Когда мы пытаемся увеличить значение myCounter, возникает ошибка: myCounter доступен только для чтения и не может быть изменен.\n</p>\n</article>\n</details>\n</section><section id="49"><h3>Вопрос № 49</h3>\n<pre><code class="lang-js">\nconst name = "Lydia";\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);\n</code></pre>\n<ul>\n<li>A: false, true</li><li>B: "Lydia", 21</li><li>C: true, true</li><li>D: undefined, undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nОператор delete возвращает логическое значение: true при успешном удалении, иначе false. Однако переменные, объявленные с помощью ключевого слова var, const или let, не могут быть удалены с помощью delete. Переменная name была объявлена ​​с помощью ключевого слова const, поэтому возвращается false. Когда мы устанавливаем age равным 21, мы фактически добавляем свойство с именем age к глобальному объекту (window.age в браузере, global.age в Node.js). Свойства объектов, включая глобальный, удалять можно, поэтому delete age возвращает true.\n</p>\n</article>\n</details>\n</section><section id="50"><h3>Вопрос № 50</h3>\n<pre><code class="lang-js">\nconst numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);\n</code></pre>\n<ul>\n<li>A: [[1, 2, 3, 4, 5]]</li><li>B: [1, 2, 3, 4, 5]</li><li>C: 1</li><li>D: [1]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nМы можем распаковывать элементы из массивов или свойства из объектов путем деструктуризации. Например:<br>\n[a, b] = [1, 2];<br>\nЗначение a теперь равно 1, а значение b - 2. Что мы на самом деле сделали в примере, так это:<br>\n[y] = [1, 2, 3, 4, 5];<br>\nЭто означает, что значение "y" равняется первому значению массива, которое является числом 1. Поэтому в консоль выводится 1.\n</p>\n</article>\n</details>\n</section><section id="51"><h3>Вопрос № 51</h3>\n<pre><code class="lang-js">\nconst user = { name: "Lydia", age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);\n</code></pre>\n<ul>\n<li>A: { admin: true, user: { name: "Lydia", age: 21 } }</li><li>B: { admin: true, name: "Lydia", age: 21 }</li><li>C: { admin: true, user: ["Lydia", 21] }</li><li>D: { admin: true }</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью оператора распространения (spread) ... можно объединять объекты. Это позволяет создавать копии пар ключ/значение одного объекта и добавлять их в другой объект. В данном случае мы создаем копию объекта user и добавляем ее в объект admin. Объект admin содержит скопированные пары ключ/значение, что приводит к {admin: true, name: "Lydia", age: 21}.\n</p>\n</article>\n</details>\n</section><section id="52"><h3>Вопрос № 52</h3>\n<pre><code class="lang-js">\nconst person = { name: "Lydia" };\n\nObject.defineProperty(person, "age", { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));\n</code></pre>\n<ul>\n<li>A: { name: "Lydia", age: 21 }, ["name", "age"]</li><li>B: { name: "Lydia", age: 21 }, ["name"]</li><li>C: { name: "Lydia"}, ["name", "age"]</li><li>D: { name: "Lydia"}, ["age"]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью метода defineProperty() мы добавляем новые свойства к объекту или изменяем существующие. Когда мы добавляем свойство к объекту с помощью defineProperty(), они по умолчанию являются не перечисляемыми. Метод Object.keys() возвращает все перечисляемые свойства объекта, в данном случае только "name". Свойства, добавленные с помощью defineProperty(), по умолчанию также иммутабельны (неизменяемы). Это поведение можно переопределить, используя свойства writable, configurable и enumerable. Таким образом, метод defineProperty() дает нам гораздо больший контроль над свойствами, добавляемыми к объекту.\n</p>\n</article>\n</details>\n</section><section id="53"><h3>Вопрос № 53</h3>\n<pre><code class="lang-js">\nconst settings = {\n    username: "lydiahallie",\n    level: 19,\n    health: 90\n};\n\nconst data = JSON.stringify(settings, ["level", "health"]);\nconsole.log(data);\n</code></pre>\n<ul>\n<li>A: "{"level": 19, "health": 90}"</li><li>B: "{"username": "lydiahallie"}"</li><li>C: "["level", "health"]"</li><li>D: "{"username": "lydiahallie", "level":19, "health":90}"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nВторой аргумент JSON.stringify() - это replacer (заменитель). Заменитель может быть либо функцией, либо массивом, и позволяет контролировать, что и как должно быть преобразовано в значения. Если заменитель является массивом, только свойства, указанные в нем, будут добавлены в JSON-строку. В данном случае в строку включаются только свойства "level" и "health", "username" исключается. data равняется "{"level": 19, "health": 90}". Если заменитель является функцией, она вызывается для каждого свойства объекта. Значение функции будет значением свойства при добавлении в строку. Если значением свойства является undefined, такое свойство исключается из строки.\n</p>\n</article>\n</details>\n</section><section id="54"><h3>Вопрос № 54</h3>\n<pre><code class="lang-js">\nlet num = 10;\n\nconst increaseNumber = () =&gt; num++;\nconst increasePassedNumber = number =&gt; number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);\n</code></pre>\n<ul>\n<li>A: 10, 10</li><li>B: 10, 11</li><li>C: 11, 11</li><li>D: 11, 12</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nПостфиксный оператор ++ сначала возвращает значение операнда, затем увеличивает его. Значение num1 равняется 10, так как функция сначала возвращает значение num, и только после этого увеличивает его на 1. num2 - это 10, так как мы передали num1 в increasePassedNumber(). number равняется 10. Снова ++ возвращает значение операнда, а затем увеличивает его. number = 10, поэтому num2 также равняется 10.\n</p>\n</article>\n</details>\n</section><section id="55"><h3>Вопрос № 55</h3>\n<pre><code class="lang-js">\nconst value = { number: 10 };\n\nconst multiply = (x = { ...value }) =&gt; {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);\n</code></pre>\n<ul>\n<li>A: 20, 40, 80, 160</li><li>B: 20, 40, 20, 40</li><li>C: 20, 20, 20, 40</li><li>D: NaN, NaN, 20, 40</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nВ ES6 мы можем инициализировать параметры со значениями по умолчанию. Параметр будет иметь значение по умолчанию, если другое значение не было передано функции, или если значением параметра является undefined. В данном случае мы распространяем свойства объекта value на новый объект, поэтому значение "x" по умолчанию равняется {number: 10}. Аргумент по умолчанию реализуется в момент вызова функции. Каждый раз, когда мы вызываем функцию, создается новый объект. Мы вызываем функцию multiply() первые два раза, не передавая значений: "x" имеет значение {number: 10}. Затем мы умножаем это значение на 2, получаем 20. В третий раз, когда мы вызываем multiply(), мы передаем ей аргумент - объект value. Оператор *= на самом деле является сокращением для x.number = x.number * 2: мы меняем значение x.number, теперь оно равняется 20. В четвертый раз мы снова передаем multiply() объект value. x.number = 20, поэтому x.number *= 2 равняется 40.\n</p>\n</article>\n</details>\n</section><section id="56"><h3>Вопрос № 56</h3>\n<pre><code class="lang-js">\n[1, 2, 3, 4].reduce((x, y) =&gt; console.log(x, y));\n</code></pre>\n<ul>\n<li>A: 1 2, 3 3 и 6 4</li><li>B: 1 2, 2 3 и 3 4</li><li>C: 1 undefined, 2 undefined, 3 undefined и 4 undefined</li><li>D: 1 2, undefined 3 и undefined 4</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nПервый агрумент метода reduce - аккумулятор, в данном случае "x". Второй аргумент - текущее значение, "y". С помощью reduce мы выполняем функцию обратного вызова для каждого элемента массива, что может привести к единственному значению. В примере мы не возвращаем значений, а просто регистрируем значения аккумулятора и текущее значение. Значение аккумулятора равняется ранее возвращенному значению колбека. Если вы не передадите необязательный аргумент initialValue методу reduce, аккумулятор будет равен первому элементу при первом вызове. При первом вызове аккумулятор (x) = 1, а текущее значение (y) = 2. Мы не выходим из функции, а регистрируем аккумулятор и текущее значение: 1 и 2 регистрируются. Если вы не возвращаете значение из функции, она возвращает undefined. При следующем вызове аккумулятор = undefined, а текущее значение = 3. undefined и 3 регистрируются. При четвертом вызове мы снова не возвращаем значение из функции. Аккумулятор = undefined, а текущее значение = 4: undefined и 4 выводятся в консоль.\n</p>\n</article>\n</details>\n</section><section id="57"><h3>Вопрос № 57</h3>\n<pre><code class="lang-js">\n// index.js\nconsole.log(\'running index.js\');\nimport { sum } from \'./sum.js\';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log(\'running sum.js\');\nexport const sum = (a, b) =&gt; a + b;\n</code></pre>\n<ul>\n<li>A: running index.js, running sum.js, 3</li><li>B: running sum.js, running index.js, 3</li><li>C: running sum.js, 3, running index.js</li><li>D: running index.js, undefined, running sum.js</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nПри импорте модулей с помощью ключевого слова import, они являются прераспарсенными (предварительно разобранными). Это означает, что модули запускаются первыми, а код в файле, который импортирует модуль, выполняется позже. В этом разница между require() в CommonJS и import. С помощью require() мы можем загружать зависимости динамически во время выполнения кода. При использовании require() вместо import в консоль будет выведено running index.js, running sum.js, 3.\n</p>\n</article>\n</details>\n</section><section id="58"><h3>Вопрос № 58</h3>\n<pre><code class="lang-js">\nconsole.log(Number(2) === Number(2))\nconsole.log(Boolean(false) === Boolean(false))\nconsole.log(Symbol(\'foo\') === Symbol(\'foo\'))\n</code></pre>\n<ul>\n<li>A: true, true, false</li><li>B: false, true, false</li><li>C: true, false, true</li><li>D: true, true, true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nКаждый Symbol уникален. Цель аргумента, переданного Symbol, состоит в том, чтобы дать Symbol описание. Значение Symbol не зависит от переданного аргумента. Когда мы проверяем равенство, мы создаем два разных Symbol: первый Symbol(\'foo\') и второй Symbol(\'foo\'). Эти значения уникальны и не равны друг другу, Symbol(\'foo\') === Symbol(\'foo\') возвращает false.\n</p>\n</article>\n</details>\n</section><section id="59"><h3>Вопрос № 59</h3>\n<pre><code class="lang-js">\nconst name = "Lydia Hallie"\nconsole.log(name.padStart(13))\nconsole.log(name.padStart(2))\n</code></pre>\n<ul>\n<li>A: "Lydia Hallie", "Lydia Hallie"</li><li>B: " Lydia Hallie", " Lydia Hallie" ("[13x whitespace]Lydia Hallie", "[2x whitespace]Lydia Hallie")</li><li>C: " Lydia Hallie", "Lydia Hallie" ("[1x whitespace]Lydia Hallie", "Lydia Hallie")</li><li>D: "Lydia Hallie", "Lyd",</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nС помощью метода padStart мы добавляем отступы в начало строки. Значение, передаваемое этому методу, представляет собой общую длину строки вместе с отступом. Строка "Lydia Hallie" имеет длину равную 12. name.padStart(13) вставляет 1 пробел в начало строки, потому что 12 + 1 равно 13. Если аргумент, переданный методу padStart, меньше длины строки, заполнение не выполняется.\n</p>\n</article>\n</details>\n</section><section id="60"><h3>Вопрос № 60</h3>\n<pre><code class="lang-js">\nconsole.log("📱" + "💻");\n</code></pre>\n<ul>\n<li>A: "📱💻"</li><li>B: 257548</li><li>C: Строка, содержащая кодовые обозначения</li><li>D: Error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nС помощью оператора + мы можем объединять строки (это называется конкатенацией). В данном случае мы объединяем строку "📱" со строкой "💻", что приводит к "📱💻".\n</p>\n</article>\n</details>\n</section><section id="61"><h3>Вопрос № 61</h3>\n<pre><code class="lang-js">\nfunction* startGame() {\n    const answer = yield "Ты любишь JavaScript?";\n    if (answer !== "Да") {\n        return "Как интересно... В таком случае что ты здесь делаешь?";\n    }\n    return "JavaScript тоже тебя любит ❤️";\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Ты любишь JavaScript?\nconsole.log(/* 2 */); // JavaScript тоже тебя любит ❤️\n</code></pre>\n<ul>\n<li>A: game.next("Да").value и game.next().value</li><li>B: game.next.value("Да") и game.next.value()</li><li>C: game.next().value и game.next("Да").value</li><li>D: game.next.value() и game.next.value("Да")</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nФункция-генератор "приостанавливает" выполнение, когда встречает ключевое слово yield. Во-первых, мы должны позволить функции выдать строку "Ты любишь JavaScript?", что можно сделать, вызвав game.next().value. Код выполняется последовательно до тех пор, пока не встречается ключевое слово yield. В первой строке функции есть ключевое слово yield: выполнение останавливается с первым результатом. Это означает, что переменная answer еще не определена. Когда мы вызываем game.next("Да").value, предыдущий yield заменяется значением параметров, переданных функции next(), в данном случае "Да". Значение переменной answer теперь равняется "Да". Условие if возвращает false, и "JavaScript тоже тебя любит ❤️" выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="62"><h3>Вопрос № 62</h3>\n<pre><code class="lang-js">\nconsole.log(String.raw`Hello\nworld`);\n</code></pre>\n<ul>\n<li>A: Hello world!</li><li>B: Hello (на следующей строке) world</li><li>C: Hello\nworld</li><li>D: Hello\n (на следующей строке) world</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nString.raw() возвращает строку, в которой обратные последовательности (\n, \v, \t и т.д.) игнорируются. Обратная косая черта может стать проблемой, например:<br>\nconst path = `C:DocumentsProjects\table.html`\nЭто приведет к:<br>\n"C:DocumentsProjects able.html"<br>\nС String.raw() управляющие символы будут проигнорированы:<br>\nC:DocumentsProjects\table.html\n</p>\n</article>\n</details>\n</section><section id="63"><h3>Вопрос № 63</h3>\n<pre><code class="lang-js">\nasync function getData() {\n    return await Promise.resolve("Я сделал это!");\n}\n\nconst data = getData();\nconsole.log(data);\n</code></pre>\n<ul>\n<li>A: "Я сделал это!"</li><li>B: Promise {<resolved>: "Я сделал это!"}</resolved></li><li>C: Promise {<pending>}</pending></li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nАсинхронная функция возвращает промис. await ожидает разрешения промиса: промис возвращается, когда мы вызываем getData(), чтобы установить data равным ему. Если бы мы хотели получить доступ к разрешенному значению "Я сделал это!", мы могли бы использовать метод .then() для data: data.then(res =&gt; console.log(res)). Тогда бы в консоль было выведено "Я сделал это!"\n</p>\n</article>\n</details>\n</section><section id="64"><h3>Вопрос № 64</h3>\n<pre><code class="lang-js">\nfunction addToList(item, list) {\n    return list.push(item);\n}\n\nconst result = addToList("apple", ["banana"]);\nconsole.log(result);\n</code></pre>\n<ul>\n<li>A: [\'apple\', \'banana\']</li><li>B: 2</li><li>C: true</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nМетод push возвращает длину нового массива. Ранее массив содержал только один элемент (строку "banana") и имел длину 1. После добавления в массив строки "apple", длина массива увеличивается до 2. Это значение возвращается из функции addToList(). Метод push изменяет исходный массив. Если мы хотим вернуть массив, а не его длину, необходимо вернуть list после добавления item.\n</p>\n</article>\n</details>\n</section><section id="65"><h3>Вопрос № 65</h3>\n<pre><code class="lang-js">\nconst box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);\n</code></pre>\n<ul>\n<li>A: { x: 100, y: 20 }</li><li>B: { x: 10, y: 20 }</li><li>C: { x: 100 }</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nObject.freeze делает невозможным добавление, удаление или изменение свойств объекта (если только значение свойства не является другим объектом). Когда мы создаем переменную shape и устанавливаем ее равной замороженному объекту box, shape ссылается на этот объект. Вы можете проверить, заморожен ли объект, используя Object.isFrozen(). В даном случае Object.isFrozen(shape) возвращает true, поскольку переменная shape ссылается на замороженный объект. Поскольку shape заморожен, а значение "x" не является объектом, мы не можем менять свойство "x". "x" по-прежнему равняется 10, и {x: 10, y: 20} выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="66"><h3>Вопрос № 66</h3>\n<pre><code class="lang-js">\nconst { name: myName } = { name: "Lydia" };\n\nconsole.log(name);\n</code></pre>\n<ul>\n<li>A: "Lydia"</li><li>B: "myName"</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nКогда мы распаковываем свойство name из правого объекта, мы присваиваем значение "Lydia" переменной myName. С помощью {name: myName} мы сообщаем JavaScript, что хотим создать новую переменную с именем myName и со значением свойства name из правой части. Поскольку мы пытаемся вывести в консоль name, переменную, которая не определена, выбрасывается исключение ReferenceError.\n</p>\n</article>\n</details>\n</section><section id="67"><h3>Вопрос № 67</h3>\n<pre><code class="lang-js">\nconst add = () =&gt; {\n    const cache = {};\n    return num =&gt; {\n        if (num in cache) {\n            return `Из кэша! &#36;{cache[num]}`;\n        } else {\n            const result = num + 10;\n            cache[num] = result;\n            return `Вычислено! &#36;{result}`;\n        }\n    };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));\n</code></pre>\n<ul>\n<li>A: Вычислено! 20 Вычислено! 20 Вычислено! 20</li><li>B: Вычислено! 20 Из кэша! 20 Вычислено! 20</li><li>C: Вычислено! 20 Из кэша! 20 Из кэша! 20</li><li>D: Вычислено! 20 Из кэша! 20 Error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nФункция add() является функцией запоминания (мемоизации). С помощью запоминания мы можем кэшировать результаты вызова функции, чтобы ускорить ее повторное выполнение. В данном случае мы создаем объект cache, в котором хранятся ранее возвращенные значения. Если мы повторно вызываем функцию addFunction() с тем же аргументом, она сначала проверяет, имеется ли соответствующее значение в кэше. Если значение имеется, оно возвращается, что экономит время на выполнение функции. Иначе, если значение в кэше отсутствует, оно вычисляется и сохраняется. Мы вызываем функцию addFunction() три раза с одним и тем же аргументом: при первом вызове значение функции, когда num = 10, еще не кэшировано. Условие if num in cache возвращает false, и выполняется блок else: Вычислено! 20 выводится в консоль, и результат добавляется в объект cache. cache теперь выглядит как {10: 20}. При повторном вызове значение для аргумента 10 возвращается из кэша. Условие if num in cache возвращает true, а \'Из кэша! 20\' выводится в консоль. В третий раз мы передаем в функцию 5 * 2, что оценивается как 10. Объект cache содержит значение для аргумента 10. Условие if num in cache возвращает true, а \'Из кэша! 20\' выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="68"><h3>Вопрос № 68</h3>\n<pre><code class="lang-js">\nconst myLifeSummedUp = ["☕", "💻", "🍷", "🍫"]\n\nfor (let item in myLifeSummedUp) {\n  console.log(item)\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item)\n}\n</code></pre>\n<ul>\n<li>A: 0 1 2 3 и "☕" "💻" "🍷" "🍫"</li><li>B: "☕" "💻" "🍷" "🍫" и "☕" "💻" "🍷" "🍫"</li><li>C: "☕" "💻" "🍷" "🍫" и 0 1 2 3</li><li>D: 0 1 2 3 и {0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nС помощью цикла for-in мы перебираем перечисляемые свойства. В массиве перечисляемые свойства являются "ключами" элементов массива, которые фактически являются их индексами. Вы можете представить массив как: <br>\n{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"} <br>\nгде ключи - перечисляемые свойства. 0 1 2 3 выводится в консоль. С помощью for-of мы выполняем итерацию итераций. Массив является итеративным. Когда мы выполняем итерацию по массиву, переменная "item" равна итерируемому элементу, "☕" "💻" "🍷" "🍫" выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="69"><h3>Вопрос № 69</h3>\n<pre><code class="lang-js">\nconst list = [1 + 2, 1 * 2, 1 / 2]\nconsole.log(list)\n</code></pre>\n<ul>\n<li>A: ["1 + 2", "1 * 2", "1 / 2"]</li><li>B: ["12", 2, 0.5]</li><li>C: [3, 2, 0.5]</li><li>D: [1, 1, 1]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nЭлементами массива могут быть любые типы данных. Числа, строки, объекты, другие массивы, null, логические значения, undefined и др., например, даты, функции и выражения. Элемент будет равен возвращаемому значению. 1 + 2 возвращает 3, 1 * 2 - 2, а 1 / 2 - 0.5.\n</p>\n</article>\n</details>\n</section><section id="70"><h3>Вопрос № 70</h3>\n<pre><code class="lang-js">\nfunction sayHi(name) {\n    return `Привет, &#36;{name}`\n}\n\nconsole.log(sayHi())\n</code></pre>\n<ul>\n<li>A: Привет,</li><li>B: Привет, undefined</li><li>C: Привет, null</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nПо умолчанию аргументы имеют значение undefined, если значение не было передано функции. В данном случае мы не передаем значения для аргумента name. name = undefined. В ES6 мы можем перезаписать undefined параметрами по умолчанию. Например: <br>\nfunction sayHi(name = "Lydia") { ... } <br>\nВ данном случае, если мы не передали значение или если мы передали undefined, name будет иметь значение Lydia.\n</p>\n</article>\n</details>\n</section><section id="71"><h3>Вопрос № 71</h3>\n<pre><code class="lang-js">\nvar status = "😎"\n\nsetTimeout(() =&gt; {\n  const status = "😍"\n\n  const data = {\n    status: "😉",\n    getStatus() {\n      return this.status\n    }\n  }\n\n  console.log(data.getStatus())\n  console.log(data.getStatus.call(this))\n}, 0)\n</code></pre>\n<ul>\n<li>A: "😉" и "😍"</li><li>B: "😉" и "😎"</li><li>C: "😍" и "😎"</li><li>D: "😎" и "😎"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nЗначение ключевого слова this зависит от того, где оно используется. В методе getStatus() this указывает на объект, которому принадлежит метод. Метод принадлежит объекту data, поэтому this относится к объекту data. Когда мы выводим в консоль this.status, выводится свойство status объекта data или "😉". С помощью метода call мы можем изменить объект, на который ссылается this. В функциях ключевое слово this относится к объекту, которому принадлежит функция. Мы объявили функцию setTimeout для объекта global, поэтому в функции setTimeout ключевое слово this ссылается на объект global. В глобальном объекте есть переменная status со значением "😎". В консоль выводится "😎".\n</p>\n</article>\n</details>\n</section><section id="72"><h3>Вопрос № 72</h3>\n<pre><code class="lang-js">\nconst person = {\n    name: "Lydia",\n    age: 21\n}\n\nlet city = person.city\ncity = "Amsterdam"\n\nconsole.log(person)\n</code></pre>\n<ul>\n<li>A: { name: "Lydia", age: 21 }</li><li>B: { name: "Lydia", age: 21, city: "Amsterdam" }</li><li>C: { name: "Lydia", age: 21, city: undefined }</li><li>D: "Amsterdam"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nМы устанавливаем переменную city равной значению свойства city объекта person. У этого объекта нет свойства city, поэтому переменная city имеет значение undefined. Обратите внимание, что мы не ссылаемся на person. Мы просто устанавливаем переменную city равной текущему значению свойства city объекта person. Затем мы устанавливаем city равным строке "Amsterdam". Это не меняет person.\n</p>\n</article>\n</details>\n</section><section id="73"><h3>Вопрос № 73</h3>\n<pre><code class="lang-js">\nfunction checkAge(age) {\n    if (age &lt; 18) {\n      const message = "Вы слишком молоды."\n    } else {\n      const message = "Вы достаточно взрослый!"\n    }\n    return message\n}\n\nconsole.log(checkAge(21))\n</code></pre>\n<ul>\n<li>A: "Вы слишком молоды."</li><li>B: "Вы достаточно взрослый!"</li><li>C: ReferenceError</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nПеременные, объявленные с помощью ключевых слов const и let имеют блочную область видимости. Блок - это любой код между {}. В данном случае в фигурных скобках операторов if/else. Вы не можете ссылаться на переменную за пределами блока, в котором она объявлена, выбрасывается исключение ReferenceError.\n</p>\n</article>\n</details>\n</section><section id="74"><h3>Вопрос № 74</h3>\n<pre><code class="lang-js">\nfunction getName(name) {\n    const hasName = /* ? */\n}\n</code></pre>\n<ul>\n<li>A: !!name</li><li>B: name</li><li>C: new Boolean(name)</li><li>D: name.length</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nС помощью !!name мы определяем, является ли значение name истинным. Если name = true, то !name возвращает false. А !false (это то, чем на самом деле является !!name) возвращает true. Устанавливая hasName равным name, мы устанавливаем hasName равным любому значению, которое передается функции getName(), а не логическому значению true. new Boolean(true) возвращает объектную обертку, а не само логическое значение. name.length возвращает длину переданного аргумента.\n</p>\n</article>\n</details>\n</section><section id="75"><h3>Вопрос № 75</h3>\n<pre><code class="lang-js">\nconsole.log("Я хочу пиццу!"[0])\n</code></pre>\n<ul>\n<li>A: ""</li><li>B: "Я"</li><li>C: SyntaxError</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nЧтобы получить символ по определенному индексу в строке, вы можете использовать скобочную нотацию. Первый символ в строке имеет индекс 0 и т.д. В данном случае мы хотим получить элемент с индексом 0, символ \'Я\', который и выводится в консоль. Альтернативой является метод charAt.\n</p>\n</article>\n</details>\n</section><section id="76"><h3>Вопрос № 76</h3>\n<pre><code class="lang-js">\nfunction sum(num1, num2 = num1) {\n    console.log(num1 + num2)\n}\n\nsum(10)\n</code></pre>\n<ul>\n<li>A: NaN</li><li>B: 20</li><li>C: ReferenceError</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nМы можем установить значение параметра по умолчанию равным другому параметру функции, если такой параметр был определен до параметра по умолчанию. Мы передаем значение 10 в функцию sum(). Если sum() принимает только один аргумент, значит, значение для num2 не передано, оно получает значение по умолчанию, т.е. 10. num1 + num2 возвращает 20. Если попытаться установить значение параметра по умолчанию равным параметру, который определяется позже, то возникнет ошибка.\n</p>\n</article>\n</details>\n</section><section id="77"><h3>Вопрос № 77</h3>\n<pre><code class="lang-js">\n// module.js\nexport default () =&gt; "Hello world"\nexport const name = "Lydia"\n\n// index.js\nimport * as data from "./module"\n\nconsole.log(data)\n</code></pre>\n<ul>\n<li>A: { default: function default(), name: "Lydia" }</li><li>B: { default: function default() }</li><li>C: { default: "Hello world", name: "Lydia" }</li><li>D: Глобальный объект module.js</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nС помощью import * as name мы импортируем все экспорты из файла module.js в файл index.js, создается новый объект data. В файле module.js имеется два экспорта: экспорт по умолчанию и именованный экспорт. Экспорт по умолчанию - это функция, которая возвращает строку "Hello World", а именованный экспорт - это переменная name, которая имеет значение "Lydia". Объект data имеет свойство default для экспорта по умолчанию, другие свойства - именованные экспорты и соответствующие значения.\n</p>\n</article>\n</details>\n</section><section id="78"><h3>Вопрос № 78</h3>\n<pre><code class="lang-js">\nclass Person {\n    constructor(name) {\n      this.name = name\n    }\n}\n\nconst member = new Person("John")\nconsole.log(typeof member)\n</code></pre>\n<ul>\n<li>A: "class"</li><li>B: "function"</li><li>C: "object"</li><li>D: "string"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nКлассы являются синтаксическим сахаром для конструкторов функций. Эквивалентом класса Person в качестве конструктора функции будет:<br>\nfunction Person() { this.name = name }<br>\nВызов конструктора функции с ключевым словом new приводит к созданию экземпляра Person. typeof member возвращает "object".\n</p>\n</article>\n</details>\n</section><section id="79"><h3>Вопрос № 79</h3>\n<pre><code class="lang-js">\nlet newList = [1, 2, 3].push(4)\n\nconsole.log(newList.push(5))\n</code></pre>\n<ul>\n<li>A: [1, 2, 3, 4, 5]</li><li>B: [1, 2, 3, 5]</li><li>C: [1, 2, 3, 4]</li><li>D: Error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nМетод push возвращает длину нового массива, а не сам массив. Устанавливая newList равным [1, 2, 3].push(4), мы устанавливаем newList равным 4. Затем мы пытаемся использовать метод push для newList. Поскольку newList является числом 4, мы не можем использовать push: выбрасывается исключение TypeError.\n</p>\n</article>\n</details>\n</section><section id="80"><h3>Вопрос № 80</h3>\n<pre><code class="lang-js">\nfunction giveLydiaPizza() {\n    return "А вот и пицца!"\n}\n\nconst giveLydiaChocolate = () =&gt; "Вот шоколад... теперь дуй в тренажерку."\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)\n</code></pre>\n<ul>\n<li>A: { constructor: ...} { constructor: ...}</li><li>B: {} { constructor: ...}</li><li>C: { constructor: ...} {}</li><li>D: { constructor: ...} undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОбычные функции, такие как giveLydiaPizza(), имеют свойство prototype, которое является объектом (прототипом объекта) со свойством constructor. Однако стрелочные функции, такие как giveLydiaChocolate(), не имеют прототипа. Поэтому при попытке получить доступ к giveLydiaChocolate.prototype возвращается undefined.\n</p>\n</article>\n</details>\n</section><section id="81"><h3>Вопрос № 81</h3>\n<pre><code class="lang-js">\nconst person = {\n    name: "Lydia",\n    age: 21\n}\n\nfor (const [x, y] of Object.entries(person)) {\n    console.log(x, y)\n}\n</code></pre>\n<ul>\n<li>A: name Lydia и age 21</li><li>B: ["name", "Lydia"] и ["age", 21]</li><li>C: ["name", "age"] и undefined</li><li>D: Error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nObject.entries(person) возвращает массив вложенных массивов, содержащий ключи и значения:<br>\n[ [ \'name\', \'Lydia\' ], [ \'age\', 21 ] ]<br>\nС помощью for-of мы перебираем элементы массива, в данном случае подмассивы. Мы можем деструктурировать подмассивы в цикле, используя const [x, y]. "x" равен первому элементу в подмассиве, "y" - второму. Первым подмассивом является [ "name", "Lydia" ], где "x" равняется "name", а "y" = "Lydia". Вторым подмассивом является [ "age", 21 ], где "x" = "age", и "y" равняется 21.\n</p>\n</article>\n</details>\n</section><section id="82"><h3>Вопрос № 82</h3>\n<pre><code class="lang-js">\nfunction getItems(fruitList, ...args, favoriteFruit) {\n    return [...fruitList, ...args, favoriteFruit]\n}\n\nconsole.log(getItems(["banana", "apple"], "pear", "orange"))\n</code></pre>\n<ul>\n<li>A: ["banana", "apple", "pear", "orange"]</li><li>B: [["banana", "apple"], "pear", "orange"]</li><li>C: ["banana", "apple", ["pear"], "orange"]</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\n...args - это прочие параметры (оператор rest). Значение rest - это массив, содержащий неиспользованные аргументы и в этой связи передаваемый последним. В примере rest является вторым аргументом. Это приводит к синтаксической ошибке.\n</p><pre><code class="lang-js">\nfunction getItems(fruitList, favoriteFruit, ...args) {\n  return [...fruitList, ...args, favoriteFruit]\n}\ngetItems(["banana", "apple"], "pear", "orange")\n</code></pre>\nДанный код работает. Он возвращает массив [ \'banana\', \'apple\', \'orange\', \'pear\' ].\n<p></p>\n</article>\n</details>\n</section><section id="83"><h3>Вопрос № 83</h3>\n<pre><code class="lang-js">\nfunction nums(a, b) {\n    if\n        (a &gt; b)\n        console.log(\'a больше\')\n    else\n        console.log(\'b больше\')\n        return\n    a + b\n}\n\nconsole.log(nums(4, 2))\nconsole.log(nums(1, 2))\n</code></pre>\n<ul>\n<li>A: a больше, 6 и b больше, 3</li><li>B: a больше, undefined and b больше, undefined</li><li>C: undefined and undefined</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nВ JavaScript мы не должны явно указывать точку с запятой (;), однако компилятор автоматически добавляет их после операторов. Например, оператором могут быть переменные или ключевые слова, такие как throw, return, break и т.д. Здесь мы написали инструкцию return и другое значение a + b в новой строке. Однако, поскольку это новая строка, движок не знает, что это на самом деле значение, которое мы хотим вернуть. Вместо этого, он автоматически добавляет точку с запятой после return. Это выглядит так:\n</p><pre><code class="lang-js">\nreturn;\na + b\n</code></pre>\nЭто означает, что a + b никогда не достигается, так как функция перестает выполняться после ключевого слова return. Если значение не возвращается, как здесь, функция возвращает undefined. Обратите внимание, что после операторов if / else точки с запятой автоматически не вставляются.\n<p></p>\n</article>\n</details>\n</section><section id="84"><h3>Вопрос № 84</h3>\n<pre><code class="lang-js">\nclass Person {\n    constructor() {\n        this.name = "Lydia"\n    }\n}\n\nPerson = class AnotherPerson {\n    constructor() {\n        this.name = "Sarah"\n    }\n}\n\nconst member = new Person()\nconsole.log(member.name)\n</code></pre>\n<ul>\n<li>A: "Lydia"</li><li>B: "Sarah"</li><li>C: Error: cannot redeclare Person</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nМы можем установить классы равными другим классам/конструкторам функций. В данном случае мы устанавливаем Person равным AnotherPerson. Свойство name этого конструктора - Sarah, поэтому свойство name для нового экземпляра класса Person member - это также Sarah.\n</p>\n</article>\n</details>\n</section><section id="85"><h3>Вопрос № 85</h3>\n<pre><code class="lang-js">\nconst info = {\n    [Symbol(\'a\')]: \'b\'\n}\n\nconsole.log(info)\nconsole.log(Object.keys(info))\n</code></pre>\n<ul>\n<li>A: {Symbol(\'a\'): \'b\'} и ["{Symbol(\'a\')"]</li><li>B: {} и []</li><li>C: { a: "b" } и ["a"]</li><li>D: {Symbol(\'a\'): \'b\'} и []</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nSymbol не является перечисляемый. Метод Object.keys возвращает все перечисляемые ключи объекта. Symbol не просматривается таким образом, и возвращается пустой массив. При выводе в консоль всего объекта будут видны все свойства, даже не перечисляемые. Это одно из многих качеств символа: помимо представления совершенно уникального значения (которое предотвращает случайное пересечение имен в объектах, например, при работе с 2 библиотеками, которые хотят добавить свойства к одному и тому же объекту). Мы также можем "скрыть" свойства объектов таким способом (хотя и не полностью. Мы можем получить доступ к символам с помощью метода Object.getOwnPropertySymbols()).\n</p>\n</article>\n</details>\n</section><section id="86"><h3>Вопрос № 86</h3>\n<pre><code class="lang-js">\nconst getList = ([x, ...y]) =&gt; [x, y]\nconst getUser = user =&gt; { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: "Lydia", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))\n</code></pre>\n<ul>\n<li>A: [1, [2, 3, 4]] и undefined</li><li>B: [1, [2, 3, 4]] и { name: "Lydia", age: 21 }</li><li>C: [1, 2, 3, 4] и { name: "Lydia", age: 21 }</li><li>D: Error и { name: "Lydia", age: 21 }</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nФункция getList() получает массив в качестве аргумента. В getList() мы деструктурируем этот массив. Это выглядит так:<br>\n[x, ...y] = [1, 2, 3, 4]<br>\nС помощью прочих параметров (оператора rest) ...y мы помещаем все "оставшиеся" аргументы в массив. Такими аргументами являются 2, 3 и 4. Значение "y" является массивом, содержащим прочие параметры. В данном случае значение "x" равно 1, поэтому, мы видим в консоли [x, y], [1, [2, 3, 4]]. Функция getUser() получает объект. В случае стрелочных функций мы можем обойтись без фигурных скобок, если возвращаем только одно значение. Однако, если мы хотим вернуть объект из стрелочной функции, то должны указать его в круглых скобках, в противном случае, никакое значение не будет возвращено. Следующая функция вернула бы объект:<br>\nconst getUser = user =&gt; ({ name: user.name, age: user.age }) <br>\nПоскольку значение не возвращается, функция возвращает undefined.\n</p>\n</article>\n</details>\n</section><section id="87"><h3>Вопрос № 87</h3>\n<pre><code class="lang-js">\nconst name = "Lydia"\n\nconsole.log(name())\n</code></pre>\n<ul>\n<li>A: SyntaxError</li><li>B: ReferenceError</li><li>C: TypeError</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nПеременная name содержит значение строки, которая не является функцией, поэтому не может быть вызвана. TypeError возникает, когда значение не соответствует ожидаемому типу. JavaScript ожидал, что name будет функцией, так как мы пытаемся ее вызвать. Однако name является строкой, поэтому выбрасывается исключение TypeError: name is not a function. SyntaxError генерируются, когда мы написали нечто недопустимое с точки зрения JavaScript, например, когда слово return написано как retrun. ReferenceError генерируются, когда JavaScript не может найти ссылку на значение, к которому мы обращаемся.\n</p>\n</article>\n</details>\n</section><section id="88"><h3>Вопрос № 88</h3>\n<pre><code class="lang-js">\nconsole.log(\n    `&#36;{[] &amp;&amp; \'Не\'}вероятно!\n    Вам &#36;{\'\' &amp;&amp; \'не\'}следует обратиться (обращаться) к врачу после такого количества JavaScript lol`\n)\n</code></pre>\n<ul>\n<li>A: вероятно! Вам следует обратиться к врачу после такого количества JavaScript lol</li><li>B: Невероятно! Вам следует обратиться к врачу после такого количества JavaScript lol</li><li>C: вероятно! Вам не следует обращаться к врачу после такого количества JavaScript lol</li><li>D: Невероятно! Вам не следует обращаться к врачу после такого количества JavaScript lol</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\n[] - истинное значение. Оператор &amp;&amp; возвращает правое значение, если левое значение является истинным. В данном случае левое значение [] является истинным, поэтому возвращается \'Не\'. "" - ложное значение. Если левое значение ложно, ничего не возвращается. "не" не возвращается.\n</p>\n</article>\n</details>\n</section><section id="89"><h3>Вопрос № 89</h3>\n<pre><code class="lang-js">\nconst one = (false || {} || null)\nconst two = (null || false || "")\nconst three = ([] || 0 || true)\n\nconsole.log(one, two, three)\n</code></pre>\n<ul>\n<li>A: false null []</li><li>B: null "" true</li><li>C: {} "" []</li><li>D: null null true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОператор || возвращает первый истинный операнд. Если все значения ложны, возвращается последний операнд. (false || {} || null): пустой объект {} является истинным значением. Это первое (и единственное) истинное значение, которое и возвращается. one = {}. (null || false ||" "): все операнды являются ложными. Это означает, что возвращается последний операнд - "". two = "". ([] || 0 ||" "): пустой массив [] является истинным. Это первое истинное значение, которое и возвращается. three = [].\n</p>\n</article>\n</details>\n</section><section id="90"><h3>Вопрос № 90</h3>\n<pre><code class="lang-js">\nconst myPromise = () =&gt; Promise.resolve(\'I have resolved!\')\n\nfunction firstFunction() {\n  myPromise().then(res =&gt; console.log(res))\n  console.log(\'first\')\n}\n\nasync function secondFunction() {\n  console.log(await myPromise())\n  console.log(\'second\')\n}\n\nfirstFunction()\nsecondFunction()\n</code></pre>\n<ul>\n<li>A: I have resolved!, first and I have resolved!, second</li><li>B: first, I have resolved! and second, I have resolved!</li><li>C: I have resolved!, second and first, I have resolved!</li><li>D: first, I have resolved! and I have resolved!, second</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nС промисами дело обстоит следующим образом: "Я хочу отложить выполнение этой функции, поскольку это может занять некоторое время". Только когда определенное значение разрешено (или отклонено), и когда стек вызовов пуст, я хочу получить это значение. Мы можем получить значение с помощью ключевого слова then и await в асинхронной функции. Хотя мы можем получить значение промиса с помощью then и await, они работают по-разному. В firstFunction мы (вроде бы) приостановили выполнение функции myPromise, и продолжили выполнение другого кода, в данном случае console.log(\'first\'). Затем функция разрешается строкой "I have resolved!", которая выводится в консоль после освобождения стека вызовов. С помощью ключевого слова await в secondFunction, мы приостанавливаем выполнение асинхронной функции до тех пор, пока значение не будет разрешено. Это означает, что мы ожидаем разрешения myPromise со значением "I have resolved!", и только когда это произошло, мы переходим к следующей строке: second выводится в консоль последней.\n</p>\n</article>\n</details>\n</section><section id="91"><h3>Вопрос № 91</h3>\n<pre><code class="lang-js">\nconst set = new Set()\n\nset.add(1)\nset.add("Lydia")\nset.add({ name: "Lydia" })\n\nfor (let item of set) {\n  console.log(item + 2)\n}\n</code></pre>\n<ul>\n<li>A: 3, NaN, NaN</li><li>B: 3, 7, NaN</li><li>C: 3, Lydia2, [object Object]2</li><li>D: "12", Lydia2, [object Object]2</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОператор + используется не только для сложения чисел, но и для объединения (конкатенации) строк. Всякий раз, когда движок JavaScript видит, что одно или несколько значений не являются числом, он приводит число к строке. Первым значением является 1 - число. 1 + 2 возвращает 3. Тем не менее, второе значение "Lydia". "Lydia" является строкой, а 2 является числом: 2 приводится к строке. "Lydia" и "2" объединяются, что приводит к "Lydia2". {name: "Lydia"} является объектом. Ни число, ни объект не являются строкой, поэтому они приводятся к строке. Когда объект приводится к строке он становится "[object Object]". "[object Object]", объединенный с "2", становится "[object Object]2".\n</p>\n</article>\n</details>\n</section><section id="92"><h3>Вопрос № 92</h3>\n<pre><code class="lang-js">\nconsole.log(Promise.resolve(5))\n</code></pre>\n<ul>\n<li>A: 5</li><li>B: Promise {<pending>: 5}</pending></li><li>C: Promise {<resolved>: 5}</resolved></li><li>D: Error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nМы можем передать в Promise.resolve любой тип данных. Данный метод возвращает промис с разрешенным значением. Если мы передадим ему обычную функцию, промис разрешится с обычным значением. Если мы передадим промис, промис разрешится с разрешенным значением переданного промиса. В данном случае мы передаем число 5. Возвращается разрешенный промис со значением 5.\n</p>\n</article>\n</details>\n</section><section id="93"><h3>Вопрос № 93</h3>\n<pre><code class="lang-js">\nfunction compareMembers(person1, person2 = person) {\n    if (person1 !== person2) {\n      console.log("Не одинаковые!")\n    } else {\n      console.log("Одинаковые!")\n    }\n}\n\nconst person = { name: "Lydia" }\n\ncompareMembers(person)\n</code></pre>\n<ul>\n<li>A: Не одинаковые!</li><li>B: Одинаковые!</li><li>C: ReferenceError</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nОбъекты передаются по ссылке. Когда мы проверяем объекты на строгое равенство (идентичность) (===), мы сравниваем их ссылки. Мы устанавливаем значение по умолчанию для person2, равное объекту person, и передаем объект person в качестве значения для person1. Это означает, что оба значения имеют ссылку на одно и то же место в памяти, поэтому они равны. Блок кода в операторе else запускается, и в консоль выводится "Одинаковые!".\n</p>\n</article>\n</details>\n</section><section id="94"><h3>Вопрос № 94</h3>\n<pre><code class="lang-js">\nconst colorConfig = {\n    red: true,\n    blue: false,\n    green: true,\n    black: true,\n    yellow: false,\n}\n\nconst colors = ["pink", "red", "blue"]\n\nconsole.log(colorConfig.colors[1])\n</code></pre>\n<ul>\n<li>A: true</li><li>B: false</li><li>C: undefined</li><li>D: TypeError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nВ JavaScript у нас есть два способа получить доступ к свойствам объекта: скобочная нотация или точечная нотация. В данном случае мы используем точечную нотацию (colorConfig.colors) вместо скобочной (colorConfig["colors"]). При точечной нотации JavaScript пытается найти свойство объекта с указанным именем. В примере JavaScript пытается найти свойство colors в объекте colorConfig. Не существует такого свойства, поэтому возвращается undefined.<br>\nЗатем мы пытаемся получить доступ к значению первого элемента, используя [1]. Мы не можем сделать этого для undefined, поэтому выбрасывается исключение TypeError: Cannot read property \'1\' of undefined.<br>\nJavaScript интерпретирует (или распаковывает) операторы. Когда мы используем скобочную нотацию, он видит открывающуюся скобку [ и продолжает работать, пока не найдет закрывающуюся скобку ]. Только тогда он оценивает выражение. Если бы мы использовали colorConfig[colors[1]], то вернулось бы значение свойства red объекта colorConfig.\n</p>\n</article>\n</details>\n</section><section id="95"><h3>Вопрос № 95</h3>\n<pre><code class="lang-js">\nconsole.log(\'❤️\' === \'❤️\')\n</code></pre>\n<ul>\n<li>A: true</li><li>B: false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nСмайлики - это юникоды. Юникод для сердца - "U+2764 U+FE0F". Юникоды одинаковы для одних и тех же смайликов, поэтому мы сравниваем две одинаковые строки, что возвращает true.\n</p>\n</article>\n</details>\n</section><section id="96"><h3>Вопрос № 96</h3>\n<pre><code class="lang-js">\nconst food = [\'🍕\', \'🍫\', \'🍳\', \'🍔\']\nconst info = { favoriteFood: food[0] }\n\ninfo.favoriteFood = \'🍝\'\n\nconsole.log(food)\n</code></pre>\n<ul>\n<li>A: [\'🍕\', \'🍫\', \'🍳\', \'🍔\']</li><li>B: [\'🍝\', \'🍫\', \'🍳\', \'🍔\']</li><li>C: [\'🍝\', \'🍕\', \'🍫\', \'🍳\', \'🍔\']</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nМы устанавливаем значение свойства favourFood объекта info равным строке \'🍕\'. Строка является примитивным типом данных. В JavaScript примитивные типы данных (все, что не является объектом) передаются по значению. Затем мы меняем значение свойства favourFood объекта info. Массив food не изменился, поскольку значение favourFood было скопировано из значения первого элемента в массиве и не имеет ссылки на то же место в памяти, что и food[0]. Поэтому в консоль выводится исходный массив [\'🍕\', \'🍫\', \'🍳\', \'🍔\'].\n</p>\n</article>\n</details>\n</section><section id="97"><h3>Вопрос № 97</h3>\n<pre><code class="lang-js">\nlet name = \'Lydia\'\n\nfunction getName() {\n  console.log(name)\n  let name = \'Sarah\'\n}\n\ngetName()\n</code></pre>\n<ul>\n<li>A: Lydia</li><li>B: Sarah</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nКаждая функция имеет собственный контекст выполнения (или область видимости). Функция getName() сначала ищет переменную name в собственном контексте (области видимости). getName() содержит собственную переменную name: мы объявляем переменную name с помощью ключевого слова let и присваиваем ей значение \'Sarah\'. Переменные, объявленные с помощью ключевого слова let (и const) не поднимаются в начало функции, в отличие от переменных, объявленных с помощью var. Они недоступны до инициализации. Это называется "временной мертвой зоной". Когда мы пытаемся получить доступ к таким переменным, JavaScript выбрасывает исключение ReferenceError. Если бы мы не объявили переменную name в функции getName(), движок JavaScript продолжал бы поиск переменной вверх по цепочке областей видимости. Внешняя область видимости содержит переменную name со значением Lydia. В этом случае в консоль было бы выведено "Lydia".\n</p>\n</article>\n</details>\n</section><section id="98"><h3>Вопрос № 98</h3>\n<pre><code class="lang-js">\nfunction* generatorOne() {\n    yield [\'a\', \'b\', \'c\'];\n}\n\nfunction* generatorTwo() {\n    yield* [\'a\', \'b\', \'c\'];\n}\n\nconst one = generatorOne()\nconst two = generatorTwo()\n\nconsole.log(one.next().value)\nconsole.log(two.next().value)\n</code></pre>\n<ul>\n<li>A: a и a</li><li>B: a и undefined</li><li>C: [\'a\', \'b\', \'c\'] и a</li><li>D: a и [\'a\', \'b\', \'c\']</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nС помощью ключевого слова yield мы получаем значения в функции-генераторе. С помощью yield* мы можем получить значение из другой функции-генератора или итерируемого объекта (например, массива). В generatorOne() мы получаем весь массив [\' a \',\' b \',\' c \'], используя yield. Значение свойства value, возвращаемого методом next объекта one (one.next().value), равняется массиву [\'a\', \'b\', \'c\'].\n</p><pre><code class="lang-js">\nconsole.log(one.next().value) // [\'a\', \'b\', \'c\']\nconsole.log(one.next().value) // undefined\n</code></pre>\nВ функции generatorTwo() мы используем ключевое слово yield*. Это означает, что первое значение равняется первому значению итератора. Итератор - это массив [\'a\', \'b\', \'c\']. Первым значением является a, поэтому когда мы вызываем two.next().value, возвращается a.\n<pre><code class="lang-js">\nconsole.log(two.next().value) // \'a\'\nconsole.log(two.next().value) // \'b\'\nconsole.log(two.next().value) // \'c\'\nconsole.log(two.next().value) // undefined\n</code></pre>\n<p></p>\n</article>\n</details>\n</section><section id="99"><h3>Вопрос № 99</h3>\n<pre><code class="lang-js">\nconsole.log(`&#36;{(x =&gt; x)(\'Я люблю\')} писать код`)\n</code></pre>\n<ul>\n<li>A: Я люблю писать код</li><li>B: undefined писать код</li><li>C: &#36;{(x =&gt; x)(\'Я люблю\') писать код</li><li>D: TypeError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nВыражения внутри шаблонных литералов оцениваются первыми. Это означает, что строка будет содержать значение выражения, в данном случае значение немедленно вызываемого функционального выражения (x =&gt; x)(\'I love\'). Мы передаем значение \'Я люблю\' в качестве аргумента стрелочной функции x =&gt; x. x = \'Я люблю\', что и возвращается. Это приводит к \'Я люблю писать код\'.\n</p>\n</article>\n</details>\n</section><section id="100"><h3>Вопрос № 100</h3>\n<pre><code class="lang-js">\nconst person = {\n    name: "Lydia",\n    age: 21\n}\n\nconst changeAge = (x = { ...person }) =&gt; x.age += 1\nconst changeAgeAndName = (x = { ...person }) =&gt; {\n    x.age += 1\n    x.name = "Sarah"\n}\n\nchangeAge(person)\nchangeAgeAndName()\n\nconsole.log(person)\n</code></pre>\n<ul>\n<li>A: {name: "Sarah", age: 22}</li><li>B: {name: "Sarah", age: 23}</li><li>C: {name: "Lydia", age: 22}</li><li>D: {name: "Lydia", age: 23}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nФункции changeAge() и changeAgeAndName() имеют параметры по умолчанию, а именно: вновь созданный объект { ...person }. Этот объект имеет копии всех ключей/значений объекта person. Сначала мы вызываем функцию changeAge() и передаем ей объект person в качестве аргумента. Эта функция увеличивает значение свойства age на 1. person теперь равняется {name: "Lydia", age: 22}. Затем мы вызываем функцию changeAgeAndName() без аргументов. Поэтому значение "x" равняется новому объекту: { ...person }. Поскольку это новый объект, он не влияет на свойства объекта person. person по-прежнему равняется {name: "Lydia", age: 22}.\n</p>\n</article>\n</details>\n</section><section id="101"><h3>Вопрос № 101</h3>\n<pre><code class="lang-js">\nfunction sumValues(x, y, z) {\n    return x + y + z; // 6\n}\n</code></pre>\n<ul>\n<li>A: sumValues([...1, 2, 3])</li><li>B: sumValues([...[1, 2, 3]])</li><li>C: sumValues(...[1, 2, 3])</li><li>D: sumValues([1, 2, 3])</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nС помощью оператора распространения (spread) ... мы разбиваем итерируемые сущности на отдельные элементы. Функция sumValues() принимает три аргумента: x, y и z. Для того, чтобы эта функция вернула 6, ей в качестве аргумента необходимо передать ...[1, 2, 3].\n</p>\n</article>\n</details>\n</section><section id="102"><h3>Вопрос № 102</h3>\n<pre><code class="lang-js">\nlet num = 1;\nconst list = [\'a\', \'b\', \'c\', \'d\'];\n\nconsole.log(list[(num += 1)]);\n</code></pre>\n<ul>\n<li>A: b</li><li>B: c</li><li>C: SyntaxError</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью оператора += мы увеличиваем значение num на 1. Начальным значением num является 1, 1 + 1 = 2. Элементом со вторым индексом является "c", что и выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="103"><h3>Вопрос № 103</h3>\n<pre><code class="lang-js">\nconst person = {\n    firstName: \'Lydia\',\n    lastName: \'Hallie\',\n    pet: {\n      name: \'Mara\',\n      breed: \'Dutch Tulip Hound\',\n    },\n    getFullName() {\n      return `&#36;{this.firstName} &#36;{this.lastName}`;\n    },\n};\n\nconsole.log(person.pet?.name);\nconsole.log(person.pet?.family?.name);\nconsole.log(person.getFullName?.());\nconsole.log(member.getLastName?.());\n</code></pre>\n<ul>\n<li>A: undefined undefined undefined undefined</li><li>B: Mara undefined Lydia Hallie undefined</li><li>C: Mara null Lydia Hallie null</li><li>D: null ReferenceError null ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nБлагодаря оператору опциональной цепочки ?. нам больше не нужно проверять глубоко вложенные значения на валидность. Если мы попытаемся получить доступ к свойству значения undefined или null, выражение вернет undefined. person.pet?.name: person имеет свойство pet; pet имеет свойство name, возвращается Mara. person.pet?.family?.name: person имеет свойство pet; pet не имеет свойства family; person.pet?.family отсутствует, возвращается undefined. person.getFullName?.(): person имеет метод getFullName(), возвращается Lydia Hallie. member.getLastName?.(): member не определена; member.getLastName() отсутствует, возвращается undefined.\n</p>\n</article>\n</details>\n</section><section id="104"><h3>Вопрос № 104</h3>\n<pre><code class="lang-js">\nconst groceries = [\'banana\', \'apple\', \'peanuts\'];\n\nif (groceries.indexOf(\'banana\')) {\n  console.log(\'Нам нужно купить бананы!\');\n} else {\n  console.log(\'Нам не нужно покупать бананы!\');\n}\n</code></pre>\n<ul>\n<li>A: Нам нужно купить бананы!</li><li>B: Нам не нужно покупать бананы!</li><li>C: undefined</li><li>D: 1</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nУсловие groceries.indexOf(\'banana\') возвращает 0, который является ложным значением. Поскольку условие ложно, выполняется блок else, и мы получаем "Нам не нужно покупать бананы!"\n</p>\n</article>\n</details>\n</section><section id="105"><h3>Вопрос № 105</h3>\n<pre><code class="lang-js">\nconst config = {\n    languages: [],\n    set language(lang) {\n      return this.languages.push(lang);\n    },\n};\n\nconsole.log(config.language);\n</code></pre>\n<ul>\n<li>A: function language(lang) { this.languages.push(lang }</li><li>B: 0</li><li>C: []</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nМетод language() - это сеттер. Сеттеры не имеют собственных значений, их задача - модифицировать свойства. Поэтому вызов сеттера возвращает undefined.\n</p>\n</article>\n</details>\n</section><section id="106"><h3>Вопрос № 106</h3>\n<pre><code class="lang-js">\nconst name = \'Lydia Hallie\';\n\nconsole.log(!typeof name === \'object\');\nconsole.log(!typeof name === \'string\');\n</code></pre>\n<ul>\n<li>A: false true</li><li>B: true false</li><li>C: false false</li><li>D: true true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\ntypeof name возвращает \'string\'. \'string\' - это истинное значение, поэтому !typeof name = false. false === \'object\' и false === \'string\' возвращают false (если мы хотим сравнить типы значений вместо !typeof следует использовать !==).\n</p>\n</article>\n</details>\n</section><section id="107"><h3>Вопрос № 107</h3>\n<pre><code class="lang-js">\nconst add = x =&gt; y =&gt; z =&gt; {\n    console.log(x, y, z);\n    return x + y + z;\n};\n\nadd(4)(5)(6);\n</code></pre>\n<ul>\n<li>A: 4 5 6</li><li>B: 6 5 4</li><li>C: 4 function function</li><li>D: undefined undefined 6</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nФункция add() возвращает стрелочную функцию, которая возвращает стрелочную функцию, которая возвращает стрелочную функцию (вы еще здесь?). Первая функция принимает аргумент "x" со значением 4. Мы вызываем вторую функцию с аргументом "y" со значением 5. Затем мы вызываем третью функцию с аргументом "z" со значением 6. Когда мы пытаемся получить доступ к значениям "x" и "y", движок JavaScript поднимается по цепочке областей видимости в поисках соответствующих значений. Возвращается 4 5 6.\n</p>\n</article>\n</details>\n</section><section id="108"><h3>Вопрос № 108</h3>\n<pre><code class="lang-js">\nasync function* range(start, end) {\n    for (let i = start; i &lt;= end; i++) {\n      yield Promise.resolve(i);\n    }\n  }\n\n(async () =&gt; {\n    const gen = range(1, 3);\n    for await (const item of gen) {\n        console.log(item);\n    }\n})();\n</code></pre>\n<ul>\n<li>A: Promise {1} Promise {2} Promise {3}</li><li>B: Promise {<pending>} Promise {<pending>} Promise {<pending>}</pending></pending></pending></li><li>C: 1 2 3</li><li>D: undefined undefined undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nФункция-генератор range() возвращает асинхронный объект с промисами для каждого переданного значения: Promise{1}, Promise{2}, Promise{3}. Мы присваиваем переменной gen этот объект, и перебираем его элементы с помощью цикла for await... of. Мы устанавливаем значение переменной item равным значению промиса. Поскольку мы ожидаем значения item, т.е. разрешения промиса, то получаем 1, 2, 3.\n</p>\n</article>\n</details>\n</section><section id="109"><h3>Вопрос № 109</h3>\n<pre><code class="lang-js">\nconst myFunc = ({ x, y, z }) =&gt; {\n    console.log(x, y, z);\n};\n\nmyFunc(1, 2, 3);\n</code></pre>\n<ul>\n<li>A: 1 2 3</li><li>B: {1: 1} {2: 2} {3: 3}</li><li>C: { 1: undefined } undefined undefined</li><li>D: undefined undefined undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nmyFunc в качестве аргумента ожидает получить объект со свойствами x, y и z. Поскольку мы передаем ей 1, 2, 3, а не {x: 1, y: 2, z: 3}, то возвращается значение x, y и z по умолчанию, т.е. undefined.\n</p>\n</article>\n</details>\n</section><section id="110"><h3>Вопрос № 110</h3>\n<pre><code class="lang-js">\nfunction getFine(speed, amount) {\n    const formattedSpeed = new Intl.NumberFormat({\n        \'en-US\',\n        { style: \'unit\', unit: \'mile-per-hour\' }\n    }).format(speed)\n\n    const formattedAmount = new Intl.NumberFormat({\n        \'en-US\',\n        { style: \'currency\', currency: \'USD\' }\n    }).format(amount)\n\n    return `The driver drove &#36;{formattedSpeed} and has to pay &#36;{formattedAmount}`\n}\n\nconsole.log(getFine(130, 300))\n</code></pre>\n<ul>\n<li>A: The driver drove 130 and has to pay 300</li><li>B: The driver drove 130 mph and has to pay &#36;300.00</li><li>C: The driver drove undefined and has to pay undefined</li><li>D: The driver drove 130.00 and has to pay 300.00</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью метода Intl.NumberFormat() мы можем форматировать числовые значению в любую локаль. Мы форматируем число 130 в локаль en-US как unit со значением mile-per-hour, что возвращает 130 mph. Число 300 в локали en-US со свойством currency и значением USD возвращает &#36;300.00.\n</p>\n</article>\n</details>\n</section><section id="111"><h3>Вопрос № 111</h3>\n<pre><code class="lang-js">\nconst spookyItems = [\'👻\', \'🎃\', \'👿\'];\n({ item: spookyItems[3] } = { item: \'💀\' });\n\nconsole.log(spookyItems);\n</code></pre>\n<ul>\n<li>A: ["👻", "🎃", "👿"]</li><li>B: ["👻", "🎃", "👿", "💀"]</li><li>C: ["👻", "🎃", "👿", { item: "💀" }]</li><li>D: ["👻", "🎃", "👿", "[object Object]"]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nДеструктурируя объекты, мы распаковываем значения правого объекта и присваиваем это значение одноименному свойству левого объекта. В данном случае, мы присваиваем значение "💀" spookyItems[3]. Это означает, что мы модифицируем массив spookyItems, добавляя в него "💀". Поэтому получаем ["👻", "🎃", "👿", "💀"].\n</p>\n</article>\n</details>\n</section><section id="112"><h3>Вопрос № 112</h3>\n<pre><code class="lang-js">\nconst name = \'Lydia Hallie\';\nconst age = 21;\n\nconsole.log(Number.isNaN(name));\nconsole.log(Number.isNaN(age));\n\nconsole.log(isNaN(name));\nconsole.log(isNaN(age));\n</code></pre>\n<ul>\n<li>A: true false true false</li><li>B: true false false false</li><li>C: false false true false</li><li>D: false true false true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nС помощью метода Number.isNaN() мы можем проверить, является ли переданное значение числом и равняется ли оно NaN. name не является числовым значением, поэтому Number.isNaN(name) возвращает false. age является числовым значением, но не равняется NaN, поэтому Number.isNaN(age) также возвращает false. С помощью метода isNaN() мы можем проверить, что переданное значение не является числом. Значение name не является числом, поэтому isNaN(name) возвращает true. Значение age является числом, поэтому isNaN(age) возвращает false.\n</p>\n</article>\n</details>\n</section><section id="113"><h3>Вопрос № 113</h3>\n<pre><code class="lang-js">\nconst randomValue = 21;\n\nfunction getInfo() {\n  console.log(typeof randomValue);\n  const randomValue = \'Lydia Hallie\';\n}\n\ngetInfo();\n</code></pre>\n<ul>\n<li>A: "number"</li><li>B: "string"</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nПеременные, объявленные с помощью ключевого слова const недоступны до инициализации: это называется "временной мертвой зоной". В getInfo() областью видимости переменной randomValue является функция. Когда мы пытаемся вывести значение randomValue в консоль, она еще не инициализирована: выбрасывается исключение ReferenceError. Движок не спускается вниз по цепочке областей видимости, поскольку мы объявили переменную randomValue в функции getInfo().\n</p>\n</article>\n</details>\n</section><section id="114"><h3>Вопрос № 114</h3>\n<pre><code class="lang-js">\nconst myPromise = Promise.resolve(\'Woah some cool data\');\n\n(async () =&gt; {\n  try {\n    console.log(await myPromise);\n  } catch {\n    throw new Error(`Oops didn\'t work`);\n  } finally {\n    console.log(\'Oh finally!\');\n  }\n})();\n</code></pre>\n<ul>\n<li>A: Woah some cool data</li><li>B: Oh finally!</li><li>C: Woah some cool data Oh finally!</li><li>D: Oops didn\'t work Oh finally!</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nВ блоке try мы выводим в консоль ожидаемое значение переменной myPromise: "Woah some cool data". Поскольку в блоке try не возникло ошибки, код в блоке catch не выполняется. Код в блоке finally выполняется всегда, поэтому в консоль выводится "Oh finally!"\n</p>\n</article>\n</details>\n</section><section id="115"><h3>Вопрос № 115</h3>\n<pre><code class="lang-js">\nconst emojis = [\'💫\', [\'✨\', \'✨\', [\'🍕\', \'🍕\']]];\n\nconsole.log(emojis.flat(1));\n</code></pre>\n<ul>\n<li>A: [\'💫\', [\'✨\', \'✨\', [\'🍕\', \'🍕\']]]</li><li>B: [\'💫\', \'✨\', \'✨\', [\'🍕\', \'🍕\']]</li><li>C: [\'💫\', [\'✨\', \'✨\', \'🍕\', \'🍕\']]</li><li>D: [\'💫\', \'✨\', \'✨\', \'🍕\', \'🍕\']</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью метода flat мы можем создать новый "плоский" массив. Глубина этого массива зависит от передаваемого значения. В данном случае, мы передаем значение 1 (чего мы могли бы не делать, поскольку это является значением по умолчанию), значит, будут объединены только массивы певрого уровня вложенности, т.е. [\'💫\'] и [\'✨\', \'✨\', [\'🍕\', \'🍕\']]. Результатом объединения этих массивов является [\'💫\', \'✨\', \'✨\', [\'🍕\', \'🍕\']].\n</p>\n</article>\n</details>\n</section><section id="116"><h3>Вопрос № 116</h3>\n<pre><code class="lang-js">\nclass Counter {\n    constructor() {\n      this.count = 0;\n    }\n\n    increment() {\n      this.count++;\n    }\n}\n\nconst counterOne = new Counter();\ncounterOne.increment();\ncounterOne.increment();\n\nconst counterTwo = counterOne;\ncounterTwo.increment();\n\nconsole.log(counterOne.count);\n</code></pre>\n<ul>\n<li>A: 0</li><li>B: 1</li><li>C: 2</li><li>D: 3</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\ncounterOne является экземпляром класса Counter. Класс Counter содержит свойство count в конструкторе и метод increment(). Сначала мы дважды вызываем метод increment() с помощью counterOne.increment(). Таким образом, значением counterOne.count становится 2. Затем мы создаем новую переменную counterTwo и присваиваем ей значение counterOne. Поскольку объекты взаимодействуют через ссылки, мы просто создали новую ссылку на тоже самое место в памяти, на которое указывает counterOne. Поскольку обе переменные ссылаются на одно и тоже место в памяти, любые изменения объекта, на который ссылается counterTwo также влияют на counterOne. Таким образом, значением counterTwo является 2. Мы вызываем counterTwo.increment(), который увеличивает значение count до 3. Наконец, мы выводим в консоль значение counterOne.count, которое также равняется 3.\n</p>\n</article>\n</details>\n</section><section id="117"><h3>Вопрос № 117</h3>\n<pre><code class="lang-js">\nconst myPromise = Promise.resolve(Promise.resolve(\'Promise!\'));\n\nfunction funcOne() {\n  myPromise.then(res =&gt; res).then(res =&gt; console.log(res));\n  setTimeout(() =&gt; console.log(\'Timeout!\', 0));\n  console.log(\'Last line!\');\n}\n\nasync function funcTwo() {\n  const res = await myPromise;\n  console.log(await res);\n  setTimeout(() =&gt; console.log(\'Timeout!\', 0));\n  console.log(\'Last line!\');\n}\n\nfuncOne();\nfuncTwo();\n</code></pre>\n<ul>\n<li>A: Promise! Last line! Promise! Last line! Last line! Promise!</li><li>B: Last line! Timeout! Promise! Last line! Timeout! Promise!</li><li>C: Promise! Last line! Last line! Promise! Timeout! Timeout!</li><li>D: Last line! Promise! Promise! Last line! Timeout! Timeout!</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nСначала мы вызываем функцию funcOne(). На первой строке этой функции мы вызываем промис myPromise, который является асинхронной операцией. Пока движок занят выполнением промиса, выполнение myFunc() продолжается. Следующей строкой является асинхронная функция setTimeout(), функция обратного вызова которой отправляется в Web API. Промис и setTimeout() являются асинхронными, поэтому выполнение функции не дожидается разрешения промиса и обработки setTimeout().<br>\nЭто означает, что сначала в консоль выводится "Last line!", поскольку console.log() не асинхронная операция. Это последняя строка кода в myFunc(), промис разрешается и в консоль выводится "Promise!".<br>\nВ момент вызова функции funcTwo() стек вызовов не является пустым, поэтому функция обратного вызова setTimeout() не может туда попасть. В funcTwo() мы сначала ожидаем разрешение промиса myPromise. С помощью ключевого слова await мы приостанавливаем выполнение функции до разрешения (или отклонения) промиса. Затем мы выводим в консоль ожидаемое значение res (поскольку промис возвращает промис). В консоль выводится "Promise!". На следуюей строке у нас снова асинхронная функция setTimeout(), чей колбек отправляется в Web API. Мы достигаем последней строки кода в funcTwo(), в консоль выводится "Last line!".<br>\nПосле того, как funcTwo() удаляется из стека вызовов, он оказывается пустым. Ожидающие этого в очереди задач колбеки (() =&gt; console.log("Timeout!") из funcOne() и () =&gt; console.log("Timeout!") из funcTwo()) помещаются в стек одна за другой. Первый колбек выводит в консоль "Timeout!" и покидает стек, затем тоже самое происходит со вторым колбеком. Таким образом, мы получаем "Last line! Promise! Promise! Last line! Timeout! Timeout!".\n</p>\n</article>\n</details>\n</section><section id="118"><h3>Вопрос № 118</h3>\n<pre><code class="lang-js">\n// sum.js\nexport default function sum(x) {\n  return x + x;\n}\n\n// index.js\nimport * as sum from \'./sum\';\n/* sum */\n</code></pre>\n<ul>\n<li>A: sum(4)</li><li>B: sum.sum(4)</li><li>C: sum.default(4)</li><li>D: символ * может использоваться только в именованном экспорте</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nС помощью символа * мы импортируем все экспортируемые из файла значения, как дефолтные, так и именованные. Если у нас есть такой файл:\n</p><pre><code class="lang-js">\n// info.js\nexport const name = \'Lydia\';\nexport const age = 21;\nexport default \'I love JavaScript\';\n\n// index.js\nimport * as info from \'./info\';\nconsole.log(info);\n</code></pre>\nВ консоль будет выведено:\n<pre><code class="lang-js">\n{\n    default: "I love JavaScript",\n    name: "Lydia",\n    age: 21\n}\n</code></pre>\nВ данном случае импортированное значение sum выглядит примерно так:<br>\n{ default: function sum(x) { return x + x } }<br>\nМы можем вызвать эту функцию посредством sum.default().\n<p></p>\n</article>\n</details>\n</section><section id="119"><h3>Вопрос № 119</h3>\n<pre><code class="lang-js">\nconst handler = {\n    set: () =&gt; console.log(\'Added a new property!\'),\n    get: () =&gt; console.log(\'Accessed a property!\'),\n};\n\nconst person = new Proxy({}, handler);\n\nperson.name = \'Lydia\';\nperson.name;\n</code></pre>\n<ul>\n<li>A: Added a new property!</li><li>B: Accessed a property!</li><li>C: Added a new property! Accessed a property!</li><li>D: Nothing gets logged</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nС помощью прокси-объекта мы можем добавить объекту, передаваемому в качестве второго аргумента, определенное поведение. В данном случае, мы передаем объект handler, который имеет два свойства: set и get. set вызывается при установке значений, а get - при их получении. Первый аргумент прокси - пустой объект {}, который является значением person. Поведение этого объекта определено в объекте handler. При добавлении свойства объекту person вызывается set. При получении доступа к свойству person вызывается get. Сначала мы добавляем прокси-объекту новое свойство name. Вызывается set и в консоль выводится "Added a new property!". Затем мы получаем значение свойства name. Вызывается get и в консоль выводится "Accessed a property!".\n</p>\n</article>\n</details>\n</section><section id="120"><h3>Вопрос № 120</h3>\n<pre><code class="lang-js">\nconst person = {\n    name: \'Lydia Hallie\',\n    address: {\n        street: \'100 Main St\',\n    },\n};\n\nObject.freeze(person);\n</code></pre>\n<ul>\n<li>A: person.name = "Evan Bacon"</li><li>B: delete person.address</li><li>C: person.address.street = "101 Main St"</li><li>D: person.pet = { name: "Mara" }</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: С</h3>\n<p>\nМетод Object.freeze() "замораживает" объект. Свойства не могут добавляться, изменяться или удаляться. Тем не менее, объект замораживается поверхностно. Это означает, что свойства первого уровня вложенности заморожены. Однако, в случае когда таким свойством является объект - address, его свойства не являются замороженными и их можно изменять.\n</p>\n</article>\n</details>\n</section><section id="121"><h3>Вопрос № 121</h3>\n<pre><code class="lang-js">\nconst add = x =&gt; x + x;\n\nfunction myFunc(num = 2, value = add(num)) {\n  console.log(num, value);\n}\n\nmyFunc();\nmyFunc(3);\n</code></pre>\n<ul>\n<li>A: 2 4 and 3 6</li><li>B: 2 NaN and 3 NaN</li><li>C: 2 Error and 3 6</li><li>D: 2 4 and 3 Error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nСначала мы вызываем функцию myFunc() без аргументов. Поэтому аргументам присваиваются значения по умолчанию, num - 2, а value - значение функции add(). Мы передаем add() значение num в качестве аргумента, которое равняется 2. add() возвращает 4, что является значением value. Затем мы вызываем myFunc() с аргументом 3, которое присваивается num. Поскольку мы не присваиваем значения value, его значением вновь становится значение add(). Мы передаем add() значение 3, она возвращает 6, что и является значением value.\n</p>\n</article>\n</details>\n</section><section id="122"><h3>Вопрос № 122</h3>\n<pre><code class="lang-js">\nclass Counter {\n    #number = 10\n\n    increment() {\n        this.#number++\n    }\n\n    getNum() {\n        return this.#number\n    }\n}\n\nconst counter = new Counter()\ncounter.increment()\n\nconsole.log(counter.#number)\n</code></pre>\n<ul>\n<li>A: 10</li><li>B: 11</li><li>C: undefined</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nВ ES2020 мы можем добавлять классам приватные переменные с помощью #. Мы не можем получить доступ к таким переменным за пределами класса. Поэтому, когда мы пытается вывести в консоль значение counter.#number, выбрасывается исключение SyntaxError.\n</p>\n</article>\n</details>\n</section><section id="123"><h3>Вопрос № 123</h3>\n<pre><code class="lang-js">\nconst teams = [\n    { name: \'Team 1\', members: [\'Paul\', \'Lisa\'] },\n    { name: \'Team 2\', members: [\'Laura\', \'Tim\'] },\n];\n\nfunction* getMembers(members) {\n    for (let i = 0; i &lt; members.length; i++) {\n        yield members[i];\n    }\n}\n\nfunction* getTeams(teams) {\n    for (let i = 0; i &lt; teams.length; i++) {\n        /* ? */\n    }\n}\n\nconst obj = getTeams(teams);\nobj.next(); // { value: "Paul", done: false }\nobj.next(); // { value: "Lisa", done: false }\n</code></pre>\n<ul>\n<li>A: yield getMembers(teams[i].members)</li><li>B: yield* getMembers(teams[i].members)</li><li>C: return getMembers(teams[i].members)</li><li>D: return yield getMembers(teams[i].members)</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nДля того, чтобы перебрать members в каждом элементе массива items, нам необходимо передать teams[i].members в функцию-генератор getMembers(). Генератор возвращает объект. Для того, чтобы перебрать элементы этого объекта следует использовать yield*. Если мы не укажем yield, return yield или return, внутренняя функция-генератор не будет возвращена при первом вызове метода next.\n</p>\n</article>\n</details>\n</section><section id="124"><h3>Вопрос № 124</h3>\n<pre><code class="lang-js">\nconst person = {\n    name: \'Lydia Hallie\',\n    hobbies: [\'coding\'],\n};\n\nfunction addHobby(hobby, hobbies = person.hobbies) {\n    hobbies.push(hobby);\n    return hobbies;\n}\n\naddHobby(\'running\', []);\naddHobby(\'dancing\');\naddHobby(\'baking\', person.hobbies);\n\nconsole.log(person.hobbies);\n</code></pre>\n<ul>\n<li>A: ["coding"]</li><li>B: ["coding", "dancing"]</li><li>C: ["coding", "dancing", "baking"]</li><li>D: ["coding", "running", "dancing", "baking"]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nФункция addHobby() принимает два аргумента, hobby и hobbies с дефолтным значением, равным свойству hobbies объекта person. Сначала мы вызываем addHobby() и передаем ей "running" в качестве значения для hobby и пустой массив в качестве значения для hobbies. Поскольку мы передали пустой массив в качестве значения для hobbies, в него добавляется "running". Затем мы вызываем addHobby() и передаем ей "dancing" в качестве значения для hobby. Мы не передаем значения для hobbies, поэтому он получает значение по умолчанию, т.е. значение свойства hobbies объекта person. Мы добавляем в этот массив "dancing". Наконец, мы вызываем addHobby() и передаем ей "baking" в качестве значения для hobby и массив person.hobbies в качестве значения для hobbies. Мы добавляем "baking" в массив person.hobbies. После добавления dancing и baking значением person.hoobies является ["coding", "dancing", "baking"].\n</p>\n</article>\n</details>\n</section><section id="125"><h3>Вопрос № 125</h3>\n<pre><code class="lang-js">\nclass Bird {\n    constructor() {\n        console.log("I\'m a bird. 🐤");\n    }\n}\n\nclass Flamingo extends Bird {\n    constructor() {\n        console.log("I\'m pink. 🌸");\n        super();\n    }\n}\n\nconst pet = new Flamingo();\n</code></pre>\n<ul>\n<li>A: I\'m pink. 🌸</li><li>B: I\'m pink. 🌸 I\'m a bird. 🐤</li><li>C: I\'m a bird. 🐤 I\'m pink. 🌸</li><li>D: Ничего.</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nМы создаем переменную pet, которая является экземпляром класса Flamingo. При создании экземпляра вызывается constructor(). В консоль выводится "I\'m pink. 🌸", после чего вызывается super(). super() вызывает конструктор родительского класса. В консоль выводится "I\'m a bird. 🐤".\n</p>\n</article>\n</details>\n</section><section id="126"><h3>Вопрос № 126</h3>\n<pre><code class="lang-js">\nconst person = {\n    name: "Lydia Hallie",\n    age: 21\n}\n\n[...person] // ["Lydia Hallie", 21]\n</code></pre>\n<ul>\n<li>A: Объекты являются итерируемыми по умолчанию</li><li>B: *[Symbol.iterator]() { for (let x in this) yield* this[x] }</li><li>C: *[Symbol.iterator]() { yield* Object.values(this) }</li><li>D: *[Symbol.iterator]() { for (let x in this) yield this }</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОбъекты не являются итерируемыми по умолчанию. В итерируемых сущностях имеется протокол итератора. Мы можем сделать это вручную, добавив символ итератора [Symbol.iterator], который будет возвращать объект-генератор, например, сделав исходный объект функцией-генератором *[Symbol.iterator]() {}. Эта функция-генератор должна перебирать Object.values объекта person, если мы хотим вернуть массив ["Lydia Hallie", 21]: yield* Object.values(this).\n</p>\n</article>\n</details>\n</section><section id="127"><h3>Вопрос № 127</h3>\n<pre><code class="lang-js">\nlet count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach(num =&gt; {\n    if (num) count += 1\n})\n\nconsole.log(count)\n</code></pre>\n<ul>\n<li>A: 1</li><li>B: 2</li><li>C: 3</li><li>D: 4</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nУсловие if в цикле forEach проверяет, является ли значение num истинным. Поскольку первым значением num является 0, который является ложным, код в блоке if не выполняется. Остальные значения num (1, 2, 3) являются истинными, поэтому counter увеличивается на 1 три раза. В результате значением counter является 3.\n</p>\n</article>\n</details>\n</section><section id="128"><h3>Вопрос № 128</h3>\n<pre><code class="lang-js">\nfunction getFruit(fruits) {\n\tconsole.log(fruits?.[1]?.[1])\n}\n\ngetFruit([[\'🍊\', \'🍌\'], [\'🍍\']])\ngetFruit()\ngetFruit([[\'🍍\'], [\'🍊\', \'🍌\']])\n</code></pre>\n<ul>\n<li>A: null, undefined, 🍌</li><li>B: [], null, 🍌</li><li>C: [], [], 🍌</li><li>D: undefined, undefined, 🍌</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОператор ?. позволяет нам получать опциональный доступ к глубоко вложенным свойствам объектов. Мы пытаемся вывести в консоль элемент с индексом 1 подмассива с индексом 1 массива fruits. Если подмассив с индексом 1 в массиве fruits не существует, возвращается undefined. Если подмассив с индексом 1 в массиве fruits существует, но не имеет элемента с индексом 1, также возвращается undefined. Сначала мы пытаемся вывести в консоль второй элемент подмассива [\'🍍\'] массива [[\'🍊\', \'🍌\'], [\'🍍\']]]. Этот подмассив состоит из одного элемента, т.е. элемента с индексом 1 не существует, поэтому возвращается undefined. Затем мы вызываем функцию getFruits() без аргументов, поэтому массив fruits имеет значение undefined по умолчанию. Наконец, мы пытаемся вывести в консоль второй элемент подмассива [\'🍊\', \'🍌\'] массива [\'🍍\'], [\'🍊\', \'🍌\']. Элементом с индексом 1 этого подмассива является 🍌, который и выводится в консоль.\n</p>\n</article>\n</details>\n</section><section id="129"><h3>Вопрос № 129</h3>\n<pre><code class="lang-js">\nclass Calc {\n\tconstructor() {\n\t\tthis.count = 0\n\t}\n\n\tincrease() {\n\t\tthis.count++\n\t}\n}\n\nconst calc = new Calc()\nnew Calc().increase()\n\nconsole.log(calc.count)\n</code></pre>\n<ul>\n<li>A: 0</li><li>B: 1</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nМы присваиваем переменной calc значение нового экземпляра класса Calc. Затем мы инициализируем новый экземпляр класса Calc и вызываем метод increase() этого экземпляра. Поскольку свойство count находится в конструкторе класса Calc, данное свойство не является общим для экземпляров класса Calc. Это означает, что свойство count не обновляется для экземпляра calc, оно по-прежнему равняется 0.\n</p>\n</article>\n</details>\n</section><section id="130"><h3>Вопрос № 130</h3>\n<pre><code class="lang-js">\nconst user = {\n\temail: "e@mail.com",\n\tpassword: "12345"\n}\n\nconst updateUser = ({ email, password }) =&gt; {\n\tif (email) {\n        Object.assign(user, { email })\n\t}\n\n\tif (password) {\n        user.password = password\n\t}\n\n\treturn user\n}\n\nconst updatedUser = updateUser({ email: "new@email.com" })\n\nconsole.log(updatedUser === user)\n</code></pre>\n<ul>\n<li>A: false</li><li>B: true</li><li>C: TypeError</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nФункция updateUser() обновляет свойства email и password объекта user, если их значения переданы в качестве аргументов, после чего функция возвращает объект user. Значение, которое вернула updateUser(), это объект user. Таким образом, переменная updatedUser ссылается на тот же объект user, на который ссылается сам user. Поэтому updatedUser === user возвращает true.\n</p>\n</article>\n</details>\n</section><section id="131"><h3>Вопрос № 131</h3>\n<pre><code class="lang-js">\nconst fruits = [\'🍌\', \'🍊\', \'🍎\']\n\nfruits.slice(0, 1)\nfruits.splice(0, 1)\nfruits.unshift(\'🍇\')\n\nconsole.log(fruits)\n</code></pre>\n<ul>\n<li>A: [\'🍌\', \'🍊\', \'🍎\']</li><li>B: [\'🍊\', \'🍎\']</li><li>C: [\'🍇\', \'🍊\', \'🍎\']</li><li>D: [\'🍇\', \'🍌\', \'🍊\', \'🍎\']</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nСначала мы вызываем метод slice() для массива fruits. Данный метод не модифицирует исходный массив, но возвращает извлеченное значение: \'🍌\'. Затем мы вызываем метод splice(). Данный метод модифицирует исходный массив, fruits теперь состоит из [\'🍊\', \'🍎\']. Наконец, мы вызываем метод unshift(), который модифицирует исходный массив, добавляя \'🍇\' в качестве первого элемента. Массив fruits теперь состоит из [\'🍇\', \'🍊\', \'🍎\'].\n</p>\n</article>\n</details>\n</section><section id="132"><h3>Вопрос № 132</h3>\n<pre><code class="lang-js">\nconst animals = {};\nlet dog = { emoji: \'🐶\' }\nlet cat = { emoji: \'🐈\' }\n\nanimals[dog] = { ...dog, name: "Mara" }\nanimals[cat] = { ...cat, name: "Sara" }\n\nconsole.log(animals[dog])\n</code></pre>\n<ul>\n<li>A: { emoji: "🐶", name: "Mara" }</li><li>B: { emoji: "🐈", name: "Sara" }</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nКлючи объекта конвертируются (преобразуются) в строки. Поскольку значением dog является объект, animals[dog] на самом деле означает, что мы создаем новое свойство с именем "object Object", значением которого является новый объект. animals["object Object"] равняется { emoji: "🐶", name: "Mara"}. Значением cat также является объект. Это означает, что мы перезаписываем свойство animals["object Object"] новым значением. Поэтому, когда мы выводим в консоль animals[dog], мы на самом деле выводим animals["object Object"], поэтому выводится { emoji: "🐈", name: "Sara" }.\n</p>\n</article>\n</details>\n</section><section id="133"><h3>Вопрос № 133</h3>\n<pre><code class="lang-js">\nconst user = {\n\temail: "my@email.com",\n\tupdateEmail: email =&gt; {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail("new@email.com")\nconsole.log(user.email)\n</code></pre>\n<ul>\n<li>A: my@email.com</li><li>B: new@email.com</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nФункция updateEmail() является стрелочной, поэтому она не привязана к объекту user. Это означает, что ключевое слово this не ссылается на объект user, в данном случае оно ссылается на глобальную область видимости (window в браузере, global в Node.js). Значение свойства email объекта user не обновляется. Поэтому, когда мы выводим в консоль значение user.email, выводится my@email.com.\n</p>\n</article>\n</details>\n</section><section id="134"><h3>Вопрос № 134</h3>\n<pre><code class="lang-js">\nconst promise1 = Promise.resolve(\'First\')\nconst promise2 = Promise.resolve(\'Second\')\nconst promise3 = Promise.reject(\'Third\')\nconst promise4 = Promise.resolve(\'Fourth\')\n\nconst runPromises = async () =&gt; {\n\tconst res1 = await Promise.all([promise1, promise2])\n\tconst res2  = await Promise.all([promise3, promise4])\n\treturn [res1, res2]\n}\n\nrunPromises()\n\t.then(res =&gt; console.log(res))\n\t.catch(err =&gt; console.log(err))\n</code></pre>\n<ul>\n<li>A: [[\'First\', \'Second\'], [\'Fourth\']]</li><li>B: [[\'First\', \'Second\'], [\'Third\', \'Fourth\']]</li><li>C: [[\'First\', \'Second\']]</li><li>D: \'Third\'</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nМетод Promise.all() выполняет переданные ему промисы одновременно. Если один из промисов отклоняется, Promise.all также отклоняется со значением отклоненного промиса. В данном случае, promise3 отклоняется со значением "Third". Мы перехватываем отклоненное значение в методе catch вызова функции runPromises(). Поэтому в консоль выводится только "Third".\n</p>\n</article>\n</details>\n</section><section id="135"><h3>Вопрос № 135</h3>\n<pre><code class="lang-js">\nconst keys = ["name", "age"]\nconst values = ["Lydia", 22]\n\nconst method = /* ? */\n\nObject[method](keys.map((_, i) =&gt; {\n\treturn [keys[i], values[i]]\n})) // { name: "Lydia", age: 22 }\n</code></pre>\n<ul>\n<li>A: entries</li><li>B: values</li><li>C: fromEntries</li><li>D: forEach</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nМетод fromEntries() преобразует двумерный массив в объект. Первый элемент каждого подмассива становится ключом, а второй элемент - значением. В данном случае, мы перебираем элементы массива keys, возвращая массив, первым элементом которого является элемент массива keys с текущим индексом, вторым элементом - элемент массива values с текущим индексом. Это создает массив массивов с правильными ключами и значениями, которые преобразуются в { name: "Lydia", age: 22 }.\n</p>\n</article>\n</details>\n</section><section id="136"><h3>Вопрос № 136</h3>\n<pre><code class="lang-js">\nconst createMember = ({ email, address = {}}) =&gt; {\n\tconst validEmail = /.+@.+..+/.test(email)\n\tif (!validEmail) throw new Error("Valid email pls")\n\n\treturn {\n\t\temail,\n\t\taddress: address ? address : null\n\t}\n}\n\nconst member = createMember({ email: "my@email.com" })\nconsole.log(member)\n</code></pre>\n<ul>\n<li>A: { email: "my@email.com", address: null }</li><li>B: { email: "my@email.com" }</li><li>C: { email: "my@email.com", address: {} }</li><li>D: { email: "my@email.com", address: undefined }</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nЗначением address по умолчанию является пустой объект {}. Когда мы присваиваем переменной member значение функции createMember(), мы не передаем значение для address, поэтому значением address становится {}. Пустой объект - это истинное значение, поэтому условие address ? address : null возвращает true. Значением address является {}.\n</p>\n</article>\n</details>\n</section><section id="137"><h3>Вопрос № 137</h3>\n<pre><code class="lang-js">\nlet randomValue = { name: "Lydia" }\nrandomValue = 23\n\nif (!typeof randomValue === "string") {\n\tconsole.log("Это не строка!")\n} else {\n\tconsole.log("Это строка!")\n}\n</code></pre>\n<ul>\n<li>A: Это не строка!</li><li>B: Это строка!</li><li>C: TypeError</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nУсловие if проверяет, является ли !typeof random value строкой. Оператор ! преобразует значение в логический тип данных. Если значение истинно, возвращается false, если ложно - true. В данном случае, значением typeof randomValue является "number", что есть истина, поэтому возвращается false. !typeof randomValue === "string" возвращает false, поскольку на самом деле мы проверяем false === "string". Условие возвращает false, поэтому выполняется код в блоке else и в консоль выводится "Это строка!".\n</p>\n</article>\n</details>\n</section><section id="138"><h3>Вопрос № 138</h3>\n<pre><code class="lang-js">\nvar car = new Vehicle("Honda", "white", "2010", "UK");\nconsole.log(car);\n\nfunction Vehicle(model, color, year, country) {\n    this.model = model;\n    this.color = color;\n    this.year = year;\n    this.country = country;\n}\n</code></pre>\n<ul>\n<li>A: undefined</li><li>B: error</li><li>C: null</li><li>D: {model: "Honda", color: "white", year: "2010", country: "UK"}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОбъявления функций поднимаются подобно объявлениям переменных. Поэтому место объявления функции "Venicle()" не имеет значения.\n</p>\n</article>\n</details>\n</section><section id="139"><h3>Вопрос № 139</h3>\n<pre><code class="lang-js">\nfunction foo() {\n    let x = y = 0;\n    x++;\n    y++;\n    return x;\n}\n\nconsole.log(foo(), typeof x, typeof y);\n</code></pre>\n<ul>\n<li>A: 1 undefined undefined</li><li>B: error</li><li>C: 1 undefined number</li><li>D: 1 number number</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nФункция "foo()" возвращает 1 из-за оператора "++". Выражение "let x = y = 0" определяет локальную переменную "x". Однако "y" определяется как глобальная переменная. Данное выражение эквивалентно следующему:\n</p><pre><code class="lang-js">\nlet x\nwindow.y = 0\nx = window.y\n</code>\n</pre>\nПоскольку переменная "x" за пределами функции имеет значение "undefined", т.е. не определена, ее типом также является "undefined". Однако "y" за пределами функции доступна и имеет значение "0" с типом "number".\n<p></p>\n</article>\n</details>\n</section><section id="140"><h3>Вопрос № 140</h3>\n<pre><code class="lang-js">\nfunction main() {\n    console.log(\'A\')\n    setTimeout(function print() {\n        console.log(\'B\')\n    }, 0)\n    console.log(\'C\')\n}\n\nmain()\n</code></pre>\n<ul>\n<li>A: A B C</li><li>B: B A C</li><li>C: A C</li><li>D: A C B</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nПорядок выполнения функций зависит от стека вызовов. В данном случае, он будет следующим: <br>\n1. Сначала в стек помещается функция "main()". <br>\n2. Затем в стек помещается console.log(\'A\'), выполняется и удаляется из стека. <br>\n3. Далее "setTimeot()" отправляется в Web API, а оставшийся код выполняется дальше. <br>\n4. В стек помещается console.log(\'C\'), выполняется и удаляется из стека. <br>\n5. Колбек счетчика помещается в очередь задач. <br>\n6. Функция "main()" удаляется из стека. <br>\n7. Поскольку стек опустел, в него помещается колбек из очереди. <br>\n8. В стек помещается console.log(\'B\'), выполняется и удаляется из стека.\n</p>\n</article>\n</details>\n</section><section id="141"><h3>Вопрос № 141</h3>\n<pre><code class="lang-js">\nconsole.log(0.1 + 0.2 === 0.3)\n</code></pre>\n<ul>\n<li>A: false</li><li>B: true</li><li>C: undefined</li><li>D: SyntaxError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nЗдесь мы имеем дело с распространенной проблемой чисел с плавающей точкой. Поскольку такие числа преобразуются в двоичные данные, имеет место некоторая неточность округления. Поэтому сравнение названных чисел порой приводит к неожиданным результатам. В частности, значением выражения "0.1 + 0.2" будет 0.30000000000000004, что чуть больше, чем 0.3.\n</p>\n</article>\n</details>\n</section><section id="142"><h3>Вопрос № 142</h3>\n<pre><code class="lang-js">\nvar y = 1;\nif (function f(){}) {\n    y += typeof f;\n}\nconsole.log(y);\n</code></pre>\n<ul>\n<li>A: 1function</li><li>B: 1object</li><li>C: error</li><li>D: 1undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nif возвращает true. Поскольку переменная "f" нигде не определяется, она имеет значением "undefined" по умолчанию с типом "undefined".\n</p>\n</article>\n</details>\n</section><section id="143"><h3>Вопрос № 143</h3>\n<pre><code class="lang-js">\nfunction foo() {\nreturn\n    {\n        message: "Hello World"\n    };\n}\nconsole.log(foo());\n</code></pre>\n<ul>\n<li>A: Hello World</li><li>B: Object {message: "Hello World"}</li><li>C: undefined</li><li>D: error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nЗдесь мы имеем дело с автоматической расстановкой точек с запятой. В данном случае, точка с запятой автоматически вставляется после оператора "return". Поэтому функция возвращает "undefined". <br>\nЕсли поставить "{" перед return, то функция будет работать как ожидается:\n</p><pre><code class="lang-js">\nfunction foo() {\n    return {\n        message: \'Hello World\'\n    }\n}\nconsole.log(foo()) // {message: \'Hello World\'}\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="144"><h3>Вопрос № 144</h3>\n<pre><code class="lang-js">\nvar myChars = [\'a\', \'b\', \'c\', \'d\']\ndelete myChars[0];\nconsole.log(myChars);\nconsole.log(myChars[0]);\nconsole.log(myChars.length);\n</code></pre>\n<ul>\n<li>A: [empty, \'b\', \'c\', \'d\'], empty, 3</li><li>B: [null, \'b\', \'c\', \'d\'], empty, 3</li><li>C: [empty, \'b\', \'c\', \'d\'], undefined, 4</li><li>D: [null, \'b\', \'c\', \'d\'], undefined, 4</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОператор "delete" удаляет свойства объекта, но не индексы массива. Другими словами, удаляется только значение массива по указанному индексу, сам индекс остается, его значением становится "undefined". Поэтому количество элементов в массиве или его длина сохраняется.\n</p>\n</article>\n</details>\n</section><section id="145"><h3>Вопрос № 145</h3>\n<pre><code class="lang-js">\nvar array1 = new Array(3);\nconsole.log(array1);\n\nvar array2 = [];\narray2[2] = 100;\nconsole.log(array2);\n\nvar array3 = [,,,];\nconsole.log(array3);\n</code></pre>\n<ul>\n<li>A: [undefined × 3], [undefined × 2, 100], [undefined × 3]</li><li>B: [empty × 3], [empty × 2, 100], [empty × 3]</li><li>C: [null × 3], [null × 2, 100], [null × 3]</li><li>D: [], [100], []</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nНа самом деле то, что будет выведено в консоль, зависит от браузера. Например, последние версии Chrome выводят "empty x n", а старые выводили "undefined x n". В Firefox выводится "n empty slots".\n</p>\n</article>\n</details>\n</section><section id="146"><h3>Вопрос № 146</h3>\n<pre><code class="lang-js">\nconst obj = {\n    prop1: function() { return 0 },\n    prop2() { return 1 },\n    [\'prop\' + 3]() { return 2 }\n}\n\nconsole.log(obj.prop1());\nconsole.log(obj.prop2());\nconsole.log(obj.prop3());\n</code></pre>\n<ul>\n<li>A: 0, 1, 2</li><li>B: 0, { return 1 }, 2</li><li>C: 0, { return 1 }, { return 2 }</li><li>D: 0, 1, undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nES6, среди прочего, представил новые способы определения методов и сокращения свойств объекта. Поэтому "prop2" и "prop3" обрабатываются как обычные функции.\n</p>\n</article>\n</details>\n</section><section id="147"><h3>Вопрос № 147</h3>\n<pre><code class="lang-js">\nconsole.log(1 &lt; 2 &lt; 3);\nconsole.log(3 &gt; 2 &gt; 1);\n</code></pre>\n<ul>\n<li>A: true, true</li><li>B: true, false</li><li>C: error</li><li>D: false, false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nЕсли в if содержатся одинаковые операторы, то выражение оценивается слева направо. Для первого выражения порядок будет следующим:\n</p><pre><code class="lang-js">\nconsole.log(1 &lt; 2 &lt; 3)\nconsole.log(true &lt; 3)\nconsole.log(1 &lt; 3)\ntrue\n</code>\n</pre>\nА для второго таким:\n<pre><code class="lang-js">\nconsole.log(3 &gt; 2 &gt; 1)\nconsole.log(true &gt; 1)\nconsole.log(1 &gt; 1)\nfalse\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="148"><h3>Вопрос № 148</h3>\n<pre><code class="lang-js">\n// код выполняется в нестрогом режиме\nfunction printNumbers (first, second, first) {\n    console.log(first, second, first);\n}\nprintNumbers(1, 2, 3);\n</code></pre>\n<ul>\n<li>A: 1, 2, 3</li><li>B: 3, 2, 3</li><li>C: error</li><li>D: 1, 2, 1</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nВ нестрогом режиме дублирующиеся параметры в обычных функциях разрешены. В приведенном примере дублирующимися являются параметры 1 и 3. Первый параметр указывает на третий аргумент, передаваемый функции. Поэтому третий аргумент перезаписывает первый параметр. Обратите внимание, что в строгом режиме возникнет ошибка.\n</p>\n</article>\n</details>\n</section><section id="149"><h3>Вопрос № 149</h3>\n<pre><code class="lang-js">\n// код выполняется в нестрогом режиме\nconst printNumbersArrow = (first, second, first) =&gt; {\n    console.log(first, second, first);\n}\nprintNumbersArrow(1, 2, 3);\n</code></pre>\n<ul>\n<li>A: 1, 2, 3</li><li>B: 3, 2, 3</li><li>C: error</li><li>D: 1, 2, 1</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nВ отличие от обычных, в стрелочных функциях дублирующиеся параметры запрещены независимо от режима выполнения кода. Поэтому в данном случае будет вырошено исключение SyntaxError: Duplicate parameter name not allowed in this context.\n</p>\n</article>\n</details>\n</section><section id="150"><h3>Вопрос № 150</h3>\n<pre><code class="lang-js">\nconst f = () =&gt; arguments.length;\nconsole.log(f(1, 2, 3));\n</code></pre>\n<ul>\n<li>A: ReferenceError: arguments is not defined</li><li>B: 3</li><li>C: undefined</li><li>D: null</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nСтрелоные функции не имеют arguments, this, super и new.target. Поэтому любое обращение к arguments приводит к поиску переменной с таким названием в лексическом окружении функции. В данном случае, переменной "arguments" не существует. Поэтому возникает ошибка.<br>\nВ обычных функциях arguments - это массивоподобный объект, содержащий переданные функции аргументы:\n</p><pre><code class="lang-js">\nconst f = function () {\n    return arguments.length\n}\nconsole.log(f(1,2,3)) // 3\n</code>\n</pre>\nВ стрелочных функциях альтернативой arguments является оператор "rest" (прочие параметры, ...):\n<pre><code class="lang-js">\nconst f = (...args) =&gt; args.length\nconsole.log(f(1,2,3)) // 3\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="151"><h3>Вопрос № 151</h3>\n<pre><code class="lang-js">\nconsole.log( String.prototype.trimLeft.name === \'trimLeft\' );\nconsole.log( String.prototype.trimLeft.name === \'trimStart\' );\n</code></pre>\n<ul>\n<li>A: true false</li><li>B: false true</li><li>C: undefined</li><li>D: null</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nПо аналогии с String.prototype.padStart стандартный метод для удаления пробелов в начале строки был назван "trimStart". Однако для обеспечения обратной совместимости название "trimLeft" было сохранено в качестве алиаса для "trimStart". Однако, прототипом trimLeft является trimStart.\n</p>\n</article>\n</details>\n</section><section id="152"><h3>Вопрос № 152</h3>\n<pre><code class="lang-js">\nconsole.log(Math.max());\n</code></pre>\n<ul>\n<li>A: undefined</li><li>B: Infinity</li><li>C: 0</li><li>D: -Infinity</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\n-Infinity - это наименьшее сравниваемое значение, поскольку почти любое другое значение в JavaScript больше него. Поэтому, когда метод "Math.max()" вызывается без аргументов, возвращается -Infinity.\n</p>\n</article>\n</details>\n</section><section id="153"><h3>Вопрос № 153</h3>\n<pre><code class="lang-js">\nconsole.log(10 === [10]);\nconsole.log(10 === [[[[[[[10]]]]]]]);\n</code></pre>\n<ul>\n<li>A: true true</li><li>B: true false</li><li>C: false false</li><li>D: false true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nСогласно спецификации приведенные выражения будут преобразованы следующим образом:\n</p><pre><code class="lang-js">\n10 === Number([10].valueOf().toString()) // 10\n</code>\n</pre>\nПоэтому количество скобок не имеет значения.\n<p></p>\n</article>\n</details>\n</section><section id="154"><h3>Вопрос № 154</h3>\n<pre><code class="lang-js">\nconsole.log(10 + \'10\');\nconsole.log(10 - \'10\');\n</code></pre>\n<ul>\n<li>A: 20 0</li><li>B: 1010 0</li><li>C: 1010 10-10</li><li>D: NaN NaN</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nОператор "+" применяется как к числам, так и к строкам. Если одним из операндов является строка, тогда оба операнда объединяются как строки. Оператор "-" пытается преобразовать операнды в число.\n</p>\n</article>\n</details>\n</section><section id="155"><h3>Вопрос № 155</h3>\n<pre><code class="lang-js">\nconsole.log([1, 2] + [3, 4]);\n</code></pre>\n<ul>\n<li>A: [1,2,3,4]</li><li>B: [1,2][3,4]</li><li>C: error</li><li>D: 1,23,4</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОператор "+" не предназначен для сложения массивов. Поэтому массивы преобразуются в строки и объединяются.\n</p>\n</article>\n</details>\n</section><section id="156"><h3>Вопрос № 156</h3>\n<pre><code class="lang-js">\nconst numbers = new Set([1, 1, 2, 3, 4]);\nconsole.log(numbers);\n\nconst browser = new Set(\'Firefox\');\nconsole.log(browser);\n</code></pre>\n<ul>\n<li>A: {1, 2, 3, 4} {"F", "i", "r", "e", "f", "o", "x"}</li><li>B: {1, 2, 3, 4} {"F", "i", "r", "e", "o", "x"}</li><li>C: [1, 2, 3, 4] ["F", "i", "r", "e", "o", "x"]</li><li>D: {1, 1, 2, 3, 4} {"F", "i", "r", "e", "f", "o", "x"}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nSet - это объект, представляющий собой коллекцию уникальных значений, поэтому повторяющиеся значения исключаются. В тоже время данный объяект является чуствительным к регистру, поэтому в коллекцию записываются и "F", и "f".\n</p>\n</article>\n</details>\n</section><section id="157"><h3>Вопрос № 157</h3>\n<pre><code class="lang-js">\nconsole.log(NaN === NaN);\n</code></pre>\n<ul>\n<li>A: true</li><li>B: false</li><li>C: error</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nNaN согласно стандарту IEEE 754 не равен никакому другому значению, включая NaN.\n</p>\n</article>\n</details>\n</section><section id="158"><h3>Вопрос № 158</h3>\n<pre><code class="lang-js">\nconst numbers = [1, 2, 3, 4, NaN];\nconsole.log(numbers.indexOf(NaN));\n</code></pre>\n<ul>\n<li>A: 4</li><li>B: NaN</li><li>C: error</li><li>D: -1</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nindexOf() использует оператор строгого равенства (===), а поскольку NaN не равен никокому другому значению, включая NaN, выражение "NaN === NaN" возвращает false. indexOf() не может найти NaN в массиве, возвращается -1. Для поиска индекса NaN можно использовать метод "findIndex()". Также для проверки наличия NaN в массиве можно использовать метод "includes()":\n</p><pre><code class="lang-js">\nconst numbers = [1, 2, 3, 4, NaN];\nconsole.log(numbers.findIndex(Number.isNaN)); // 4\n\nconsole.log(numbers.includes(Number.isNaN)); // true\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="159"><h3>Вопрос № 159</h3>\n<pre><code class="lang-js">\nconst [a, ...b,] = [1, 2, 3, 4, 5];\nconsole.log(a, b);\n</code></pre>\n<ul>\n<li>A: 1 [2, 3, 4, 5]</li><li>B: 1 {2, 3, 4, 5}</li><li>C: SyntaxError: Rest element must be last element</li><li>D: 1 [2, 3, 4]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nПри использовании оператора "rest" (прочие параметры, ...), данный оператор передается в качестве последнего аргумента. В данном случае, использование замыкающей запятой (trailing comma) приводит к возникновению ошибки. Если удалить запятую, то все будет в порядке:<br>\n</p><pre><code class="lang-js">\nconst [a, ...b] = [1, 2, 3, 4, 5];\nconsole.log(a, b); // 1, [2, 3, 4, 5]\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="160"><h3>Вопрос № 160</h3>\n<pre><code class="lang-js">\nasync function func() {\n    return 10;\n}\nconsole.log(func());\n</code></pre>\n<ul>\n<li>A: Promise {: 10}</li><li>B: 10</li><li>C: error</li><li>D: Promise {: undefined}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nАсинхронная функция всегда возвращает промис. Даже если возвращаемое такой функцией значение само по себе не является промисом, оно будет завернуто в промис. Приведенный пример эквивалентен следующему:\n</p><pre><code class="lang-js">\nfunction func() {\n    return Promise.resolve(10)\n}\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="161"><h3>Вопрос № 161</h3>\n<pre><code class="lang-js">\nasync function func() {\n    await 10;\n}\nconsole.log(func());\n</code></pre>\n<ul>\n<li>A: Promise {: 10}</li><li>B: 10</li><li>C: error</li><li>D: Promise {: undefined}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nawait возвращает Promise {: 10}, который может быть обработан с помощью then(). В данном случае, функция не содержит return, т.е. не возвращает значения. Поэтому возвращается undefined. Приведенный пример эквивалентен следующему:\n</p><pre><code class="lang-js">\nfunction func () {\n    return Promise.resolve(10).then(() =&gt; undefined)\n}\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="162"><h3>Вопрос № 162</h3>\n<pre><code class="lang-js">\nfunction delay() {\n    return new Promise(resolve =&gt; setTimeout(resolve, 2000));\n}\n\nasync function delayedLog(item) {\n    await delay();\n    console.log(item);\n}\n\nasync function processArray(array) {\n    array.forEach(item =&gt; {\n        await delayedLog(item);\n    })\n}\n\nprocessArray([1, 2, 3, 4]);\n</code></pre>\n<ul>\n<li>A: error</li><li>B: 1, 2, 3, 4</li><li>C: 4, 4, 4, 4</li><li>D: 4, 3, 2, 1</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nНесмотря на то, что processArray - это асинхронная функция, анонимная функция, которую мы используем в forEach, является синхронной. Использование ключевого слова "await" в синхронных функциях приводит к выбрасыванию исключения SyntaxError: await is only valid in async function.\n</p>\n</article>\n</details>\n</section><section id="163"><h3>Вопрос № 163</h3>\n<pre><code class="lang-js">\nfunction delay() {\n    return new Promise(resolve =&gt; setTimeout(resolve, 2000));\n}\n\nasync function delayedLog(item) {\n    await delay();\n    console.log(item);\n}\n\nasync function process(array) {\n    array.forEach(async (item) =&gt; {\n        await delayedLog(i);\n    });\n    console.log(\'Process completed!\');\n}\n\nprocess([1, 2, 3, 5]);\n</code></pre>\n<ul>\n<li>1: 1 2 3 5 Process completed!</li><li>2: 5 5 5 5 Process completed!</li><li>3: Process completed! 5 5 5 5</li><li>4: Process completed! 1 2 3 5</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nМетод "forEach" не ожидает завершения операции, он лишь запускает ее выполнение и двигается дальше. Поэтому console.log(\'Process finished!\') выполняется первым согласно последовательности разрешения промисов.<br>\nОпределить нужную последовательность можно с помощью оператора for-of:<br>\n</p><pre><code class="lang-js">\nasync function processArray (array) {\n    for (const item of array) {\n        await delayedLog(item)\n    }\n    console.log(\'Process completed!\')\n}\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="164"><h3>Вопрос № 164</h3>\n<pre><code class="lang-js">\nvar set = new Set();\nset.add("+0")\n    .add("-0")\n        .add(NaN)\n            .add(undefined)\n                .add(NaN);\n\nconsole.log(set);\n</code></pre>\n<ul>\n<li>A: Set(4) {"+0", "-0", NaN, undefined}</li><li>B: Set(3) {"+0", NaN, undefined}</li><li>C: Set(5) {"+0", "-0", NaN, undefined, NaN}</li><li>D: Set(4) {"+0", NaN, undefined, NaN}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nВ отличии от операторов равенства (==, ===), для Set все NaN являются одинаковыми значениями, а +0 и -0 - разными.\n</p>\n</article>\n</details>\n</section><section id="165"><h3>Вопрос № 165</h3>\n<pre><code class="lang-js">\nconst sym1 = Symbol(\'one\');\nconst sym2 = Symbol(\'one\');\n\nconst sym3 = Symbol.for(\'two\');\nconst sym4 = Symbol.for(\'two\');\n\nconsole.log(sym1 === sym2, sym3 === sym4);\n</code></pre>\n<ul>\n<li>A: true true</li><li>B: true false</li><li>C: false true</li><li>D: false false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nДля символом характерно следующее:<br>\n1. Каждый символ, возвращаемый Symbol(), это уникальное значение. Строка, передаваемая Symbol(), это лишь опциональная метка или описание символа, которая, обычно, используется в целях отладки кода.<br>\n2. Метод "Symbol.for()" создает символ в глобальном реестре символов. При каждом вызове данного метода проверяется, имеется ли символ с указанным ключом в реестре. После этого либо возвращается найденный символ, либо создается новый.\n</p>\n</article>\n</details>\n</section><section id="166"><h3>Вопрос № 166</h3>\n<pre><code class="lang-js">\nconst sym1 = new Symbol(\'one\');\nconsole.log(sym1);\n</code></pre>\n<ul>\n<li>A: error</li><li>B: one</li><li>C: Symbol(\'one\')</li><li>D: Symbol</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nSymbol - это обычная функция, а не конструктор, в отличие, например, от Number или String. Поэтому при попытке использования его с ключевым словом "new" выбрасывается исключение TypeError: Symbol is not a constructor.\n</p>\n</article>\n</details>\n</section><section id="167"><h3>Вопрос № 167</h3>\n<pre><code class="lang-js">\nlet myNumber = 100;\nlet myString = \'100\';\n\nif (!typeof myNumber === "string") {\n    console.log("It is not a string!");\n} else {\n    console.log("It is a string!");\n}\n\nif (!typeof myString === "number"){\n    console.log("It is not a number!")\n} else {\n    console.log("It is a number!");\n}\n</code></pre>\n<ul>\n<li>A: error</li><li>B: It is not a string! It is not a number!</li><li>C: It is not a string! It is a number!</li><li>D: It is a string! It is a number!</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОператор "!" приводит значение к логическому типу. Поскольку выражения "typeof myNumber" и "typeof myString" истинные, в обоих случаях возвращается false. Далее выполняются блоки "else".\n</p>\n</article>\n</details>\n</section><section id="168"><h3>Вопрос № 168</h3>\n<pre><code class="lang-js">\nconsole.log(JSON.stringify({ myArray: [\'one\', undefined, function() {}, Symbol(\'\')] }));\nconsole.log(JSON.stringify({ [Symbol.for(\'one\')]: \'one\' }, [Symbol.for(\'one\')]));\n</code></pre>\n<ul>\n<li>A: {"myArray":[\'one\', undefined, {}, Symbol]}, {}</li><li>B: {"myArray":[\'one\', null, null, null]}, {}</li><li>C: {"myArray":[\'one\', null, null, null]}, "{ [Symbol.for(\'one\')]: \'one\' }, [Symbol.for(\'one\')]"</li><li>D: {"myArray":[\'one\', undefined, function(){}, Symbol(\'\')]}, {}</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nundefined, функции и символы не являются валидными JSON-значениями. Такие значения не включаются в объект и конвертируются в null в массиве. Поэтому возвращается null, null, null.<br>\nГлобальные символы игнорируются, поэтому возвращается пустой объект ({}).\n</p>\n</article>\n</details>\n</section><section id="169"><h3>Вопрос № 169</h3>\n<pre><code class="lang-js">\nclass A {\n    constructor() {\n        console.log(new.target.name)\n    }\n}\n\nclass B extends A { constructor() { super() } }\n\nnew A();\nnew B();\n</code></pre>\n<ul>\n<li>A: A A</li><li>B: A B</li><li>C: B B</li><li>D: error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nnew.target ссылается на конструктор (указывает на определение инициализируемого класса), который вызывается с помощью new. Это также справедливо для конструктора родительского класса, делегированного из дочернего конструктора.\n</p>\n</article>\n</details>\n</section><section id="170"><h3>Вопрос № 170</h3>\n<pre><code class="lang-js">\nconst {a: x = 10, b: y = 20} = {a: 30};\n\nconsole.log(x);\nconsole.log(y);\n</code></pre>\n<ul>\n<li>A: 30 20</li><li>B: 10 20</li><li>C: 10 undefined</li><li>D: 30 undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nДля свойств объекта характерно следующее:<br>\n1. Значение свойства (30) может быть извлечено и присвоено переменной (x).<br>\n2. Свойству присваивается значение по умолчанию (20), когда извлекаемым значением является undefined (y).\n</p>\n</article>\n</details>\n</section><section id="171"><h3>Вопрос № 171</h3>\n<pre><code class="lang-js">\nfunction area({ length = 10, width = 20 }) {\n    console.log(length * width);\n}\n\narea();\n</code></pre>\n<ul>\n<li>A: 200</li><li>B: error</li><li>C: undefined</li><li>D: 0</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nЗдесь мы имеем дело с деструктуризацией объекта. Если опустить правую часть выражения, функция при вызове попытается найти хотя бы один аргумент. Если ей не удастся этого сделать, будет выброшено исключение TypeError: Cannot read property \'length\' of undefined.<br>\nРешить данную проблему можно следующими способами:<br>\n1. Передать функции пустой объект в качестве аргумента:<br>\n</p><pre><code class="lang-js">\nfunction area ({ length = 10, width = 20 }) {\n    console.log(length * width)\n}\n\narea({}) // 200\n</code>\n</pre>\n2. Присвоить пустой объект в качестве значения по умолчанию:<br>\n<pre><code class="lang-js">\nfunction area ({ length = 10, width = 20 } = {}) {\n    console.log(length * width)\n}\n\narea() // 200\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="172"><h3>Вопрос № 172</h3>\n<pre><code class="lang-js">\nconst props = [\n    { id: 1, name: \'John\'},\n    { id: 2, name: \'Jack\'},\n    { id: 3, name: \'Tom\'}\n];\n\nconst [, , { name }] = props;\nconsole.log(name);\n</code></pre>\n<ul>\n<li>A: Tom</li><li>B: Error</li><li>C: undefined</li><li>D: John</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nДеструктуризацию массива и объекта можно комбинировать. В данном случае переменной "name" присваивается значение соответствующего свойства третьего элемента массива "props".\n</p>\n</article>\n</details>\n</section><section id="173"><h3>Вопрос № 173</h3>\n<pre><code class="lang-js">\nfunction checkType(num = 1) {\n    console.log(typeof num);\n}\n\ncheckType();\ncheckType(undefined);\ncheckType(\'\');\ncheckType(null);\n</code></pre>\n<ul>\n<li>A: number, undefined, string, object</li><li>B: undefined, undefined, string, object</li><li>C: number, number, string, object</li><li>D: number, number, number, number</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nЕсли функции не передается значение или передается undefined, аргумент принимает значение по умолчанию (1). Другие ложные значения ("" и null) присваиваются аргументу.<br>\nПервые два вызова функции возвращают number, поскольку значением аргумента является 1.<br>\nТипом "" является string (строка), а типом null - object (объект).\n</p>\n</article>\n</details>\n</section><section id="174"><h3>Вопрос № 174</h3>\n<pre><code class="lang-js">\nfunction add(item, items = []) {\n    items.push(item);\n    return items;\n}\n\nconsole.log(add(\'Orange\'));\nconsole.log(add(\'Apple\'));\n</code></pre>\n<ul>\n<li>A: [\'Orange\'] [\'Orange\', \'Apple\']</li><li>B: [\'Orange\'] [\'Apple\']</li><li>C: []</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nАргументу "items" при каждом вызове функции "add" присваивается пустой массив (значение по умолчанию), который возвращается с помещенным в него значением аргумента "item".\n</p>\n</article>\n</details>\n</section><section id="175"><h3>Вопрос № 175</h3>\n<pre><code class="lang-js">\nfunction greet(greeting, name, message = greeting + \' \' + name) {\n    console.log([name, greeting, message]);\n}\n\ngreet(\'Hello\', \'John\');\ngreet(\'Hello\', \'John\', \'Good morning!\');\n</code></pre>\n<ul>\n<li>A: error</li><li>B: [\'Hello\', \'John\', \'Hello John\'] [\'Hello\', \'John\', \'Good morning!\']</li><li>C: [\'Hello\', \'John\', \'Hello John\'] [\'Hello\', \'John\', \'Hello John\']</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nПри первом вызове функции "greet" аргументу "message" присваивается значение по умолчанию (greeting + \' \' + name). При втором вызове данному аргументу присваивается переданное значение (Good morning!).\n</p>\n</article>\n</details>\n</section><section id="176"><h3>Вопрос № 176</h3>\n<pre><code class="lang-js">\nfunction outer(f = inner()) {\n    function inner() { return \'Inner\' }\n}\nconsole.log(outer());\n</code></pre>\n<ul>\n<li>A: error</li><li>B: Inner</li><li>C: Inner Inner</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nФункции и переменные, объявленные в теле функции, не могут использоваться в качестве значений по умолчанию, поэтому выбрасывается исключение ReferenceError: inner is not defined.<br>\nФункцию можно переписать так:<br>\n</p><pre><code class="lang-js">\nfunction outer (f) {\n    function inner () { return \'Inner\' }\n    const fun = f || inner()\n    return fun\n}\nconsole.log(outer()) // Inner\nconsole.log(outer(\'Outer\')) // Outer\n</code>\n</pre>\nИли так:<br>\n<pre><code class="lang-js">\nconst outer = (msg = \'Inner\') =&gt; msg\nconsole.log(outer()) // Inner\nconsole.log(outer(\'Outer\')) // Outer\n</code>\n</pre>\n<p></p>\n</article>\n</details>\n</section><section id="177"><h3>Вопрос № 177</h3>\n<pre><code class="lang-js">\nfunction myFun(x, y, ...args) {\n    console.log(args)\n}\n\nmyFun(1, 2, 3, 4, 5);\nmyFun(1, 2);\n</code></pre>\n<ul>\n<li>A: [3, 4, 5] undefined</li><li>B: error</li><li>C: [3, 4, 5] []</li><li>D: [3, 4, 5] [undefined]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОператор "rest" (прочие параметры, ...) возвращает массив с переданными функции неименованными аргументами или пустой массив в случае, когда такие аргументы отсутствуют.\n</p>\n</article>\n</details>\n</section><section id="178"><h3>Вопрос № 178</h3>\n<pre><code class="lang-js">\nconst obj = {\'key\': \'value\'};\nconst array = [...obj];\nconsole.log(array);\n</code></pre>\n<ul>\n<li>A: [\'key\', \'value\']</li><li>B: error</li><li>C: []</li><li>D: [\'key\']</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nОператор "spread" (распространения, ...) применяется только к итерируемым сущностям. Объекты таковыми не являются. Поэтому выбрасывается исключение TypeError: object is not iterable.\n</p>\n</article>\n</details>\n</section><section id="179"><h3>Вопрос № 179</h3>\n<pre><code class="lang-js">\nfunction* myGenFunc() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\nvar myGenObj = new myGenFunc;\nconsole.log(myGenObj.next().value);\n</code></pre>\n<ul>\n<li>A: 1</li><li>B: undefined</li><li>C: 2</li><li>D: error</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nГенераторы (функции со специальным символом "*") не могут использоваться в качестве конструктора, т.е. с ключевым словом "new", поэтому выбрасывается исключение TypeError: myGenFunc is not a constructor.\n</p>\n</article>\n</details>\n</section><section id="180"><h3>Вопрос № 180</h3>\n<pre><code class="lang-js">\nfunction* yieldAndReturn() {\n    yield 1;\n    return 2;\n    yield 3;\n}\n\nvar myGenObj = yieldAndReturn()\nconsole.log(myGenObj.next());\nconsole.log(myGenObj.next());\nconsole.log(myGenObj.next());\n</code></pre>\n<ul>\n<li>A: { value: 1, done: false }, { value: 2, done: true }, { value: undefined, done: true }</li><li>B: { value: 1, done: false }, { value: 2, done: false }, { value: undefined, done: true }</li><li>C: { value: 1, done: false }, { value: 2, done: true }, { value: 3, done: true }</li><li>D: { value: 1, done: false }, { value: 2, done: false }, { value: 3, done: true }</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nИнструкция "return" в генераторе (функция со специальным символом "*") останавливает его выполнение. Возвращаемое значение 2 присваивается свойству "value", а значением свойства "done" становится true. После завершения работы генератора вызов метода "next()" возвращает {value: undefined, done: true}.\n</p>\n</article>\n</details>\n</section><section id="181"><h3>Вопрос № 181</h3>\n<pre><code class="lang-js">\nconst myGenerator = (function *(){\n    yield 1;\n    yield 2;\n    yield 3;\n})();\nfor (const value of myGenerator) {\n    console.log(value);\n    break;\n}\n\nfor (const value of myGenerator) {\n    console.log(value);\n}\n</code></pre>\n<ul>\n<li>A: 1,2,3 1,2,3</li><li>B: 1,2,3 4,5,6</li><li>C: 1 1</li><li>D: 1</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nГенератор (функция со специальным символом "*") не может использоваться после закрытия итератора. В первом цикле мы с помощью break останавливаем выполнение генератора со значением 1. Повторный перебор генератора невозможен, поэтому второй console.log() ничего не возвращает.\n</p>\n</article>\n</details>\n</section><section id="182"><h3>Вопрос № 182</h3>\n<pre><code class="lang-js">\nconst squareObj = new Square(10);\nconsole.log(squareObj.area);\n\nclass Square {\n    constructor(length) {\n        this.length = length;\n    }\n\n    get area() {\n        return this.length * this.length;\n    }\n\n    set area(value) {\n        this.area = value;\n    }\n}\n</code></pre>\n<ul>\n<li>A: 100</li><li>B: error</li><li>C: 10</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nВ отличие от объявления функций (не функциональных выражений), объявления классов не поднимаются в начало области видимости. Это также справедливо для выражений класса. Поэтому использовать класс можно только после его объявления, в противном случае, выбрасывается исключение ReferenceError: Square is not defined.\n</p>\n</article>\n</details>\n</section><section id="183"><h3>Вопрос № 183</h3>\n<pre><code class="lang-js">\nfunction Person() { }\n\nPerson.prototype.walk = function() {\n    return this;\n}\n\nPerson.run = function() {\n    return this;\n}\n\nlet user = new Person();\nlet walk = user.walk;\nconsole.log(walk());\n\nlet run = Person.run;\nconsole.log(run());\n</code></pre>\n<ul>\n<li>A: undefined undefined</li><li>B: Person Person</li><li>C: error</li><li>D: Window Window</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nКогда обычный метод или метод прототипа вызывается без передачи ему значения this, метод возвращает значение this по умолчанию. В данном случае, таким значением является глобальный объект "window".\n</p>\n</article>\n</details>\n</section><section id="184"><h3>Вопрос № 184</h3>\n<pre><code class="lang-js">\nclass Vehicle {\n    constructor(name) {\n        this.name = name;\n    }\n\n    start() {\n        console.log(`&#36;{this.name} vehicle started`);\n    }\n}\n\nclass Car extends Vehicle {\n    start() {\n        console.log(`&#36;{this.name} car started`);\n        super.start();\n    }\n}\n\nconst car = new Car(\'BMW\');\nconsole.log(car.start());\n</code></pre>\n<ul>\n<li>A: error</li><li>B: BMW vehicle started, BMW car started</li><li>C: BMW car started, BMW vehicle started</li><li>D: BMW car started, BMW car started</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nКлючевое слово "super" используется, в том числе, для вызова методов родительского класса. В отличие от других языков программирования, в JavaScript вызов super() не обязательно должен быть первой инструкцией.\n</p>\n</article>\n</details>\n</section><section id="185"><h3>Вопрос № 185</h3>\n<pre><code class="lang-js">\nconst user = {\'age\': 30};\nuser.age = 25;\nconsole.log(user.age);\n</code></pre>\n<ul>\n<li>A: 30</li><li>B: 25</li><li>C: error</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nМы используем ключевое слово "const" для объявления переменной "user", т.е. делаем ее неизменяемой (константой). Однако иммутабельность переменной, являющейся объектом, не распространяется на свойства объекта. Другими словами, свойства такого объекта можно изменять. Однако, если мы попытаемся присвоить переменной "user" новое значение (user = {\'age\': 25}), будет выброшено исключение TypeError: Assignment to constant variable. Для обеспечения иммутабельности свойств объекта используется метод "freeze()".\n</p>\n</article>\n</details>\n</section><section id="186"><h3>Вопрос № 186</h3>\n<pre><code class="lang-js">\nfunction a(x) {\n    x++;\n    return function () {\n        console.log(++x);\n    };\n}\n\na(1)();\na(1)();\na(1)();\n\nlet x = a(1);\nx();\nx();\nx();\n</code></pre>\n<ul>\n<li>A: 1, 2, 3 и 1, 2, 3</li><li>B: 3, 3, 3 и 3, 4, 5</li><li>C: 3, 3, 3 и 1, 2, 3</li><li>D: 1, 2, 3 и 3, 3, 3</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nЗдесь мы имеем дело с замыканием. Замыкания позволяют нам создавать статические функции, которым доступны переменные из внешнего окружения. Другими словами, замыкание имеет доступ к глобальной области видимости, области видимости родительской функции и собственной области видимости.<br>\nМы получаем 3, 3, 3 и 3, 4, 5, поскольку сначала просто вызываем функцию "a()". Она работает как обычная функция. Затем мы объявляем переменную "x" и присваиваем ей значение функции "a(1)", вот почему мы получаем 3, 4, 5 вместо 3, 3, 3.\n</p>\n</article>\n</details>\n</section><section id="187"><h3>Вопрос № 187</h3>\n<pre><code class="lang-js">\nfunction Name(a, b) {\n    this.a = a;\n    this.b = b;\n}\n\nconst me = Name(\'John\', \'Smith\');\n\nconsole.log(!(a.length - window.a.length));\n</code></pre>\n<ul>\n<li>A: undefined</li><li>B: NaN</li><li>C: true</li><li>D: false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: С</h3>\n<p>\nМы получаем true. Обратите внимание, что при создании объекта с помощью конструктора функции "Name" мы не использовали ключевое слово "new". Из-за этого переменная "a" стала глобальной и получила значение "John". В действительности, глобальные переменные - это свойства глобального объекта "window" (в браузере) или "global" в Node.js.<br>\nПоэтому выражение "a.length - window.a.length" возвращает 0. !0 возвращает true.\n</p>\n</article>\n</details>\n</section><section id="188"><h3>Вопрос № 188</h3>\n<pre><code class="lang-js">\nconst x = function (...x) {\n    let k = (typeof x).length;\n    let y = () =&gt; "freetut".length;\n    let z = { y: y };\n\n    return k - z.y();\n};\n\nconsole.log(Boolean(x()));\n</code></pre>\n<ul>\n<li>A: true</li><li>B: 1</li><li>C: -1</li><li>D: false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nОператор распространения (spread) "...x" позволяет получить параметры функции в виде массива. В JavaScript "typeof array" возвращает "object".<br>\nДлина строки "object" равняется 6. z.y() возвращает длину строки "freetut", т.е. 7.<br>\nФункциональное выражение "x()" возвращает -1, которое после преобразования в логический тип становится true. Обратите внимание, что boolean(0) вернет false.\n</p>\n</article>\n</details>\n</section><section id="189"><h3>Вопрос № 189</h3>\n<pre><code class="lang-js">\n(function js(x) {\n    const y = (j) =&gt; j * x;\n\n    console.log(y(s()));\n\n    function s() {\n        return j();\n    }\n\n    function j() {\n        return x ** x;\n    }\n})(3);\n</code></pre>\n<ul>\n<li>A: undefined</li><li>B: 18</li><li>C: 81</li><li>D: 12</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nФункция "js()" выполняется автоматически, поскольку является IIFE (Immediately Invoked Function Expression - немедленно вызываемым функциональным выражением). Параметр "x" функции "js" передается со значением 3.<br>\nЗначение, возвращаемое функцией "y(s())", означает вызов трех функций: y(), s() и j(), поскольку функция s() возвращает j().<br>\nj() возвращает 3 ^ 3 = 27, поэтому s() возвращает 27.<br>\ny(s()) означает y(27), которая возвращает 27 * 3 = 81.<br>\nОбратите внимание, что мы можем вызвать функцию до ее объявления, но это не работает с функциональными выражениями.\n</p>\n</article>\n</details>\n</section><section id="190"><h3>Вопрос № 190</h3>\n<pre><code class="lang-js">\nvar tip = 100;\n\n(function () {\n    console.log("I have &#36;" + husband());\n\n    function wife() {\n        return tip * 2;\n    }\n\n    function husband() {\n        return wife() / 2;\n    }\n\n    var tip = 10;\n})();\n</code></pre>\n<ul>\n<li>A: "I have &#36;10"</li><li>B: "I have &#36;100"</li><li>C: "I have &#36;50"</li><li>D: "I have &#36;NaN"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nЗдесь мы имеем дело с IIFE (Immediately Invoked Function Expression - немедленно вызываемым функциональным выражением). IIFE выполняются автоматически. Последовательность следующая: husband() возвращает wife(), а wife() возвращает tip * 2.<br>\nМожно подумать, что tip = 100, поскольку мы объявили ее с помощью ключевого слова "var", и она стала глобальной. Однако, на самом деле ее значением является undefined, поскольку мы объявляем "tip = 10" внутри функции. Поскольку переменная "tip" поднимается со значением "undefined", правильным ответом является D. Undefined возвращает NaN, когда мы пытаемся разделить его на 2 или умножить на 2.<br>\nЕсли убрать "var tip = 10" в конце функции, правильным ответом будет B.\n</p>\n</article>\n</details>\n</section><section id="191"><h3>Вопрос № 191</h3>\n<pre><code class="lang-js">\nconst js = { language: "loosely type", label: "difficult" };\n\nconst edu = { ...js, level: "PhD" };\n\nconst newbie = edu;\n\ndelete edu.language;\n\nconsole.log(Object.keys(newbie).length);\n</code></pre>\n<ul>\n<li>A: 2</li><li>B: 3</li><li>C: 4</li><li>D: 5</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nДанная задача посвящена оператору распространения (spread, ...). Этот оператор позволяет получать параметры функции, копировать или объединять объекты и массивы в JavaScript.<br>\nВ переменной "edu" мы используем оператор распространения для копирования объекта "js" и добавления к нему нового свойства "level". Это также работает с массивами.<br>\nЗатем мы объявляем другую переменную с именем "newbie". Важное замечание: обе переменных указывают или ссылаются на одно место в памяти. Это называется передачей значения по ссылке.<br>\nПосле удаления свойства "language" посредством delete edu.language, длина обоих объектов становится равной 2.\n</p>\n</article>\n</details>\n</section><section id="192"><h3>Вопрос № 192</h3>\n<pre><code class="lang-js">\nvar candidate = {\n    name: "Vuong",\n    age: 30,\n};\n\nvar job = {\n    frontend: "Vuejs or Reactjs",\n    backend: "PHP and Laravel",\n    city: "Auckland",\n};\n\nclass Combine {\n    static get() {\n        return Object.assign(candidate, job);\n    }\n\n    static count() {\n        return Object.keys(this.get()).length;\n    }\n}\n\nconsole.log(Combine.count());\n</code></pre>\n<ul>\n<li>A: 5</li><li>B: 6</li><li>C: 7</li><li>D: 8</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nВcтроенный метод "Object.assign(candidate, job)" объединяет candidate и job в один объект. Затем метод "Object.keys()" считает количество ключей объекта.<br>\nОбратите внимание, что методы "get()" и "count()" определены как статические, поэтому их можно вызывать с помощью Class.staticMethod(). Результирующий объект содержит 5 элементов.\n</p>\n</article>\n</details>\n</section><section id="193"><h3>Вопрос № 193</h3>\n<pre><code class="lang-js">\nvar x = 1;\n\n(() =&gt; {\n    x += 1;\n    ++x;\n})();\n((y) =&gt; {\n    x += y;\n    x = x % y;\n})(2);\n(() =&gt; (x += x))();\n(() =&gt; (x *= x))();\n\nconsole.log(x);\n</code></pre>\n<ul>\n<li>A: 4</li><li>B: 50</li><li>C: 2</li><li>D: 10</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nНачальное значение переменной "x" равно 1. В первом IIFE (Immediately Invoked Function Expression - немедленно вызываемом функциональном выражении) значение "x" увеличивается до 3.<br>\nВо втором IIFE выражение "x + y (3 + 2)" возвращает 5, а выражение "x % y (5 % 2)" - 1.<br>\nВ третьем и четвертом IIFE мы получаем 2 (1 + 1) и 4 (2 * 2), соответственно. Проще простого.\n</p>\n</article>\n</details>\n</section><section id="194"><h3>Вопрос № 194</h3>\n<pre><code class="lang-js">\nlet x = {};\nlet y = {};\nlet z = x;\n\nconsole.log(x == y);\nconsole.log(x === y);\nconsole.log(x == z);\nconsole.log(x === z);\n</code></pre>\n<ul>\n<li>A: true true true true</li><li>B: false false false false</li><li>C: true true false false</li><li>D: false false true true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nТехнически "x" и "y" имеют одинаковые значения. Обе переменные являются пустыми объектами. Однако объекты сравниваются не по значениям.<br>\n"z" и "x" являются объектами, ссылающимися на одно и тоже место в памяти. В JavaScript массивы и объекты передаются по ссылке. Поэтому при сравнении "x" и "z" возвращается true.\n</p>\n</article>\n</details>\n</section><section id="195"><h3>Вопрос № 195</h3>\n<pre><code class="lang-js">\nconsole.log("hello");\n\nsetTimeout(() =&gt; console.log("hey"), 1);\nsetTimeout(() =&gt; console.log("kiora"), 2);\nsetTimeout(() =&gt; console.log("world"), 0);\n\nconsole.log("hi");\n</code></pre>\n<ul>\n<li>A: "hello" "hey" "kiora" "world" "hi"</li><li>B: "hello" "hi" "hey" "kiora" "world"</li><li>C: "hello" "hi" "world" "hey" "kiora"</li><li>D: "hello" "hi" "hey" "world" "kiora"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nТри функции setTimeout() помещаются в очередь задач (task queue) перед попаданием в стек вызовов (call stack), поэтому сначала в консоль выводятся "hello" и "hi".<br>\nМожно подумать, что три setTimeout() будут выполнены в следующем порядке: "world" -&gt; "hey" -&gt; "kiora" согласно временной задержке в 0 мс -&gt; 1 мс -&gt; 2 мс, соответственно. Однако, между 0 мс и 1 мс нет разницы. Поэтому следующим в консоль выводится "hey", затем "world" и в конце "kiora".\n</p>\n</article>\n</details>\n</section><section id="196"><h3>Вопрос № 196</h3>\n<pre><code class="lang-js">\nString.prototype.lengthy = () =&gt; {\n    console.log("hello");\n};\n\nlet x = { name: "John" };\n\ndelete x;\n\nx.name.lengthy();\n</code></pre>\n<ul>\n<li>A: "John";</li><li>B: "hello";</li><li>C: undefined</li><li>D: ReferenceError</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nС помощью String.prototype.someThing = function () {} можно определить новый встроенный метод объекта "String". Мы можем сделать тоже самое с Array, Object или FunctionName, где FunctionName - это созданная нами функция.<br>\nНесложно понять, что "string".lengthy всегда возвращает "hello". Delete удаляет свойство объекта, а не сам объект. Поэтому мы получаем "hello", а не RefferenceError.<br>\nОбратите внимание, что если мы объявим объект без ключевых слов "let", "const" или "var", то получим глобальный объект. В этом случае delete objectName вернет true. В противном случае, он всегда возвращает false.\n</p>\n</article>\n</details>\n</section><section id="197"><h3>Вопрос № 197</h3>\n<pre><code class="lang-js">\nlet x = {};\n\nx.__proto__.hi = 10;\n\nObject.prototype.hi = ++x.hi;\n\nconsole.log(x.hi + Object.keys(x).length);\n</code></pre>\n<ul>\n<li>A: 10</li><li>B: 11</li><li>C: 12</li><li>D: NaN</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nНачальным значением переменной "x" является пустой объект. Затем мы добавляем к нему свойство "hi" с помощью "x.__proto__.hi". Обратите внимание, что это является эквивалентом "Object.prototype.hi = 10", поэтому мы добавляем свойство "hi" родителю пустого объекта - объекту Object. Это означает, что любой объект будет наследовать данное свойство. Свойство "hi" становится распределенным (совместным). Если мы объявим новый объект, скажем, let y = {}, "y" унаследует свойство "hi" от Object. Сравнение "x.__proto__ === Object.prototype" вернет true.<br>\nПосле этого, мы перезаписываем значение свойства "hi" новым значением 11. Получаем 1 (x имеет одно свойство) + 11 (значение свойства hi) = 12.\n</p>\n</article>\n</details>\n</section><section id="198"><h3>Вопрос № 198</h3>\n<pre><code class="lang-js">\nconst array = (a) =&gt; {\n    let length = a.length;\n    delete a[length - 1];\n    return a.length;\n};\n\nconsole.log(array([1, 2, 3, 4]));\n\nconst object = (obj) =&gt; {\n    let key = Object.keys(obj);\n    let length = key.length;\n    delete obj[key[length - 1]];\n\n    return Object.keys(obj).length;\n};\n\nconsole.log(object({ 1: 2, 2: 3, 3: 4, 4: 5 }));\n\nconst setPropNull = (obj) =&gt; {\n    let key = Object.keys(obj);\n    let length = key.length;\n    obj[key[length - 1]] = null;\n\n    return Object.keys(obj).length;\n};\n\nconsole.log(setPropNull({ 1: 2, 2: 3, 3: 4, 4: 5 }));\n</code></pre>\n<ul>\n<li>A: 3 3 3</li><li>B: 4 4 4</li><li>C: 4 3 4</li><li>D: 3 4 3</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nДанная задача демонстрирует, как работает оператор "delete" в JavaScript. Выражения "delete someObject" и "delete someArray" возвращают false (ничего не делают). Выражение "delete someObject.someProperty" удаляет указанное свойство объекта. В случае с массивом выражение "delete someArray[keyNumber]" удаляет только значение указанного индекса, сам индекс остается и его новым значением становится undefined. По этой причине первый console.log() выводит 4 (массив содержит 4 элемента, последний имеет значение "undefined"), а второй - 3 (оставшиеся свойств объекта).<br>\nПоследний console.log() выводит 4, поскольку присвоение свойству объекта значения "null" или "undefined" не удаляет это свойство. Ключ остается. Поэтому длина остается прежней.\n</p>\n</article>\n</details>\n</section><section id="199"><h3>Вопрос № 199</h3>\n<pre><code class="lang-js">\nvar a = [1, 2, 3];\nvar b = [1, 2, 3];\n\nvar c = [1, 2, 3];\nvar d = c;\n\nvar e = [1, 2, 3];\nvar f = e.slice();\n\nconsole.log(a === b);\nconsole.log(c === d);\nconsole.log(e === f);\n</code></pre>\n<ul>\n<li>A: true true true</li><li>B: false false true</li><li>C: true true false</li><li>D: false true false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nСравнение "a" и "b" возвращает false, поскольку эти переменные ссылаются на разные места в памяти, несмотря на то, что их значения являются одинаковыми.<br>\nВ JavaScript в случае с массивами и объектами значения передаются по ссылке. Во втором случае "d" является копией "c", поэтому они ссылаются на одно место в памяти. Любые изменения в "c" отражаются на "d".<br>\nТретий пример демонстирует способ копирования массива с помощью метода "slice()". "f" является копией "e", но они ссылаются на разные места в памяти. Поэтому их сравнение возвращает false.\n</p>\n</article>\n</details>\n</section><section id="200"><h3>Вопрос № 200</h3>\n<pre><code class="lang-js">\nvar languages = {\n    name: ["elixir", "golang", "js", "php", { name: "feature" }],\n    feature: "awesome",\n};\n\nlet flag = languages.hasOwnProperty(\n    Object.values(languages)[0][4].name\n);\n\n(() =&gt; {\n    if (flag !== false) {\n        console.log(\n            Object.getOwnPropertyNames(languages)[0].length &lt;&lt;\n            Object.keys(languages)[0].length\n        );\n    } else {\n        console.log(\n            Object.getOwnPropertyNames(languages)[1].length &lt;&lt;\n            Object.keys(languages)[1].length\n        );\n    }\n})();\n</code></pre>\n<ul>\n<li>A: 8</li><li>B: NaN</li><li>C: 64</li><li>D: 12</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nДанная задача является довольно сложной, поскольку в ней встречается несколько встроенных методов для работы с объектами. Например, методы "Object.keys()" и "Object.getOwnPropertyNames" возвращают свойства объекта: первый - только перечисляемые, второй - также не перечисляемые.<br>\nObject.values() и Object.keys() возвращают значения и ключи объекта, соответственно. Object.hasOwnProperty(\'propertyName\') возвращает булево значение в зависимости от того, существует указанное свойство в объекте или нет.<br>\nПеременная "language" имеет значение true, поскольку Object.values(languages)[0][4].name возвращает "feature", которое является свойством объекта.<br>\nНаконец, мы получаем 4 &lt;&lt; 4, что возвращает побитовое значение, эквивалентное "4 * 2 ^ 4" или "4 * 16", или 64.\n</p>\n</article>\n</details>\n</section><section id="201"><h3>Вопрос № 201</h3>\n<pre><code class="lang-js">\nvar player = {\n    name: "Ronaldo",\n    age: 34,\n    getAge: function () {\n        return ++this.age - this.name.length;\n    },\n};\n\nfunction score(greeting, year) {\n    console.log(\n        greeting + " " + this.name + `! You were born in  &#36;{year - this.getAge()}`\n    );\n}\n\nwindow.window.window.score.call(\n    window.window.window.player, "Kiora", 2019\n);\n\nscore.apply(player, ["Kiora", 2009]);\n\nconst helloRonaldo = window.score\n    .bind(window.player, "Kiora", 2029);\n\nhelloRonaldo();\n</code></pre>\n<ul>\n<li>A: "Kiora Ronaldo! You were born in 1985", "Kiora Ronaldo! You were born in 1985", "Kiora Ronaldo! You were born in 1985"</li><li>B: "Kiora Ronaldo! You were born in 1991", "Kiora Ronaldo! You were born in 1991", "Kiora Ronaldo! You were born in 1999"</li><li>C: "Kiora Ronaldo! You were born in 1991", NaN, "Kiora Ronaldo! You were born in 1980"</li><li>D: "Kiora Ronaldo! You were born in 1991", "Kiora Ronaldo! You were born in 1980", "Kiora Ronaldo! You were born in 1999"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nМы можем использовать call(), apply() и bind() для привязки функции к объекту. На первый взгляд может показаться, что все три метода делают одно и тоже. Однако они немного по-разному спроектированы для работы с контекстом.<br>\nИз этих методов только bind() можно вызывать после привязки. Мы можем создать переменную для хранения результата, как "helloRonaldo" в задаче. apply() и call() привязывают и вызывают функцию сразу. В методу "apply()" параметры передаются в виде массива (array, a), а в методе "call()" - через запятую (comma, c).<br>\nОбратите внимание, что window.window.window.score или window.score, или просто score делают одно и тоже. Они указывают на функцию "score()" в глобальном пространстве имен.\n</p>\n</article>\n</details>\n</section><section id="202"><h3>Вопрос № 202</h3>\n<pre><code class="lang-js">\nvar ronaldo = { age: 34 };\n\nvar messi = { age: 32 };\n\nfunction score(year, tr, t) {\n    if (typeof tr === "function" &amp;&amp; typeof t === "function") {\n        console.log(`You score &#36;{tr(year, t(this.age))} times`);\n    }\n}\n\nconst transform = (x, y) =&gt; x - y;\n\nconst title = (x) =&gt; ++x + x++;\n\nconst helloRonaldo = score.bind(ronaldo, 2029, transform, title);\n\nhelloRonaldo();\n\nconst helloMessi = score.bind(messi, 2029, transform, title);\n\nhelloMessi();\n</code></pre>\n<ul>\n<li>A: "You score 1989 times" and "You score 1963 times"</li><li>B: "You score 1959 times" and "You score 1989 times"</li><li>C: "You score 1989 times" and "You score 1953 times"</li><li>D: "You score 1959 times" and "You score 1963 times"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nbind() позволяет привязать функцию к объекту. В данном случае мы привязываем функцию "score()" к объектам "ronaldo" и "messi".<br>\nФункция "score()" принимает три параметра: year, tr и t, где "tr" и "t" должны быть функциями.<br>\nКогда мы привязываем score() к ronaldo и messi, мы передаем ей три аргумента, два из которых, "transfrom" и "title", являются функциями.\n</p>\n</article>\n</details>\n</section><section id="203"><h3>Вопрос № 203</h3>\n<pre><code class="lang-js">\nvar person = {};\n\nObject.defineProperties(person, {\n    name: {\n        value: "John",\n        enumerable: true,\n    },\n    job: {\n        value: "developer",\n        enumerable: true,\n    },\n    studying: {\n        value: "PhD",\n        enumerable: true,\n    },\n    money: {\n        value: "NZD",\n        enumerable: false,\n    },\n});\n\nclass Evaluate {\n    static checkFlag(obj) {\n        return Object.getOwnPropertyNames(obj) &gt; Object.keys(obj)\n            ? Object.getOwnPropertyNames(obj)\n            : Object.keys(obj);\n    }\n}\n\nconst flag = Evaluate.checkFlag(person);\n\nconsole.log(flag.length);\n</code></pre>\n<ul>\n<li>A: 1</li><li>B: 2</li><li>C: 3</li><li>D: 4</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nObject.keys(obj) почти идентичен Object.getOwnPropertyNames(obj), за исключением того, что последний, кроме перечисляемых, возвращает также неперечисляемые свойства объекта. По умолчанию все свойства создаваемого объекта являются перечисляемыми. Мы можем сделать их неперечисляемыми с помощью Object.defineProperty или Object.defineProperties.<br>\nПоэтому Object.keys(person) возвращает 3, а Object.getOwnPropertyNames(person) - 4. Тернарный оператор возвращает 4.\n</p>\n</article>\n</details>\n</section><section id="204"><h3>Вопрос № 204</h3>\n<pre><code class="lang-js">\nconst id = 10;\n\nconst getID = (...id) =&gt; {\n    id(id);\n\n    function id(id) {\n        console.log(typeof id);\n    }\n};\n\ngetID(id);\n</code></pre>\n<ul>\n<li>A: ReferenceError</li><li>B: 10</li><li>C: undefined</li><li>D: \'function\'</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nКогда мы определяем одну функцию внутри другой, то получаем замыкание. Обратите внимание, если функция обычная (а не функциональное выражение), она поднимается. Мы видим несколько id в коде, но некоторые из них ничего не делают.<br>\nРезультатом выполнения кода является "typeof id", т.е. "function". Таким образом, "id" в этой операции является функцией "id()".\n</p>\n</article>\n</details>\n</section><section id="205"><h3>Вопрос № 205</h3>\n<pre><code class="lang-js">\nvar book1 = {\n    name: "Name of the rose",\n    getName: function () {\n        console.log(this.name);\n    },\n};\n\nvar book2 = {\n    name: { value: "Harry Potter" },\n};\n\nvar bookCollection = Object.create(book1, book2);\n\nbookCollection.getName();\n</code></pre>\n<ul>\n<li>A: \'Harry Potter\'</li><li>B: \'Name of the rose\'</li><li>C: ReferenceError</li><li>D: Object object</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nObject.create() позволяет создавать одни объекты на основе других. Если мы не передадим второй параметр - book2, в данном случае - свойство "name" объекта "bookCollection" будет иметь значение "Name of the rose", унаследованное от book1. Это означает, что мы можем добавлять новые свойства создаваемому с помощью Object.create() объекту.<br>\nbookCollection имеет собственное свойство "name" и одноименное свойство, унаследованное от book1. Собственные свойства объекта имеют приоритет перед унаследованными. Поэтому мы получаем "Harry Potter".\n</p>\n</article>\n</details>\n</section><section id="206"><h3>Вопрос № 206</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const a = Object.create({});\n\n    const b = Object.create(null);\n\n    let f1 = a.hasOwnProperty("toString");\n\n    let f2 = "toString" in b;\n\n    let result =\n        f1 === false &amp;&amp; f2 === false\n            ? console.log((typeof a.toString()).length)\n            : console.log(b.toString());\n})();\n</code></pre>\n<ul>\n<li>A: ReferenceError</li><li>B: undefined</li><li>C: 0</li><li>D: 6</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОбъекты "a" и "b" создаются с помощью Object.create(). Разница между ними состоит в том, что "a" наследует прототип Object, а "b" является совершенно пустым, поскольку мы передали параметр "null" методу "Object.create()". hasOwnProperty(\'toString\') в обоих случаях возвращает false, поскольку в объектах метод "toString()" не определяется. Однако данный метод существует в объекте "a" как унаследованный от Object.<br>\n"f1" и "f2" возвращают false. Обратите внимание, что для проверки существования свойства в объекте мы используем "Object.hasOwnProperty(\'key\')" и "(\'key\' in object)". Они отличаются тем, что первый возвращает только собственные свойства объекта, а второй - также унаследованные.<br>\ntypeof a.toString() возвращает "string", длина которой равняется 6.\n</p>\n</article>\n</details>\n</section><section id="207"><h3>Вопрос № 207</h3>\n<pre><code class="lang-js">\nlet promise = new Promise((rs, rj) =&gt; {\n    setTimeout(() =&gt; rs(4), 0);\n\n    Promise.resolve(console.log(3));\n\n    console.log(2);\n});\n\npromise\n    .then((rs) =&gt; {\n        console.log(rs ? rs ** rs : rs);\n        return rs;\n    })\n    .then((rs) =&gt; console.log(rs === 256 ? rs : rs * rs));\n</code></pre>\n<ul>\n<li>A: 3, 2, 256, 256</li><li>B: 3, 2, 256, 16</li><li>C: 256, 16, 3, 2</li><li>D: 16, 256, 3, 2</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nМы определяем промис с помощью ключевого слова "let" и вызываем его. setTimeout() - это асинхронная функция, которая выполняется последней, даже при нулевой задержке: setTimeout(() =&gt; rs(4), 0). Хотя "Promise.resolve(console.log(3))" также возвращает промис, он относится к микрозадачам, которые имеет приоритет над (макро)задачами, такими как "setTimeout()".<br>\nВ первом then() мы получаем "4 ^ 4", во втором - "4 * 4". Обратите внимание, что "return rs" возвращает оригинальное значение.\n</p>\n</article>\n</details>\n</section><section id="208"><h3>Вопрос № 208</h3>\n<pre><code class="lang-js">\nasync function f() {\n    let promise = new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; resolve("done!"), 0);\n    });\n\n    setTimeout(() =&gt; console.log("world"), 0);\n\n    console.log(await promise);\n\n    console.log("hello");\n}\n\nf(setTimeout(() =&gt; console.log("kiora"), 0));\n</code></pre>\n<ul>\n<li>A: ReferenceError</li><li>B: done, hello, world</li><li>C: hello, done, world</li><li>D: kiora, done, hello, world</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nХотя мы не определяем параметров в функции "f()", мы передаем ей "setTimeout(() =&gt; console.log("kiora"), 0)" при вызове. Поэтому сначала мы получаем "kiora".<br>\nПеременная promise, возвращающая разрешенный промис, вызывается с помощью ключевого слова "await". JavaScript приостанавливает выполнение кода на строке "console.log(await promise)" до разрешения промиса. Вот почему следующим мы получаем "done".<br>\nПочему вторым значением, выведенным в консоль, является "done", а не "world" или "hello"? Поскольку JavaScript ставит выполнение кода на паузу, когда встречает ключевое слово "await", мы не можем получить "hello" до разрешения промиса (обратите внимание, что setTimeout() всегда выполняется последней, поскольку является асинхронной (макро)задачей, поэтому "setTimeout(() =&gt; console.log("world"), 0))" выполняется последней).<br>\nЗдесь мы наблюдаем небольшую разницу в работе ключевого слова "await" перед асинхронным оператором (в данном случае, мы использовали setTimeout() в качестве примера) и вызовом функции/оператора без этого ключевого слова.\n</p>\n</article>\n</details>\n</section><section id="209"><h3>Вопрос № 209</h3>\n<pre><code class="lang-js">\nfunction name() {\n    return new Promise((resolve) =&gt; {\n        setTimeout(() =&gt; {\n            resolve("New Zealand");\n        }, 10);\n    });\n}\n\nfunction fruit() {\n    return new Promise((resolve) =&gt; {\n        setTimeout(() =&gt; {\n        resolve("Kiwi");\n        }, 20);\n    });\n}\n\n(async function countryandfruit() {\n    const getName = await name();\n    const getFruit = await fruit();\n\n    console.log(`Kiora: &#36;{getName} &#36;{getFruit}`);\n})();\n\n(async function fruitandcountry() {\n    const [getName, getFruit] = await Promise.all([name(), fruit()]);\n\n    console.log(`Hello: &#36;{getName} &#36;{getFruit}`);\n})();\n</code></pre>\n<ul>\n<li>A: Null</li><li>B: Kiora</li><li>C: "Hello: New Zealand Kiwi" -&gt; "Kiora: New Zealand Kiwi"</li><li>D: "Kiora: New Zealand Kiwi" -&gt; "Hello: New Zealand Kiwi"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nФункции "countryandfruit" и "fruitandcountry" являются самовызываемыми. Обе определяются с помощью ключевого слова "async", это означает, что код внутри будет выполняться последовательно. Это позволяет в более краткой форме управлять получением данных по сравнению с промисами или колбеками.<br>\nПервая функция возвращает "Kiora: New Zealand Kiwi", вторая - "Hello: New Zealand Kiwi". Можно подумать, что порядок будет таким же, но на самом деле порядок обратный, поскольку функции с ключевым словом "await" выполняются последовательно, а не параллельно как "Promise.all". Это означает, что сначала выполнится "fruitandcountry".\n</p>\n</article>\n</details>\n</section><section id="210"><h3>Вопрос № 210</h3>\n<pre><code class="lang-js">\nclass MySort {\n    constructor(object) {\n        this.object = object;\n}\n\ngetSort() {\n    return Object.entries(this.object)[0][1].sort()[\n            Object.values(this.object).length\n        ];\n    }\n}\n\nconst object = {\n    month: ["July", "September", "January", "December"],\n};\n\nconst sortMe = new MySort(object);\n\nconsole.log(sortMe.getSort());\n</code></pre>\n<ul>\n<li>A: July</li><li>B: September</li><li>C: January</li><li>D: December</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nObject.entries возвращает массив, состоящий из ключей и значений объекта, Object.values - массив значений объекта, а Object.keys - массив ключей. Таким образом, "Object.entries(object)" в примере возвращает вложенный массив с одним элементом, значения которого также вложены в другой массив -  [["month", ["July", "September", "January", "December"]]].<br>\nПо этой причине "Object.entries(this.object)[0][1].sort()" на самом деле сортирует значения массива и возвращает новый порядок: "December" -&gt; "January" -&gt; "July" -&gt; "September". Следовательно, когда мы пытаемся получить элемент с индексом "[Object.values(this.object).length]", то получаем "January", поскольку "[Object.values(this.object).length]" возвращает 1 (длина массива, возвращенного Object.values).\n</p>\n</article>\n</details>\n</section><section id="211"><h3>Вопрос № 211</h3>\n<pre><code class="lang-js">\nconst flag = [] !== !!!!![];\n\nlet f = () =&gt; {};\n\nconsole.log((typeof f()).length + flag.toString().length);\n</code></pre>\n<ul>\n<li>A: NaN</li><li>B: 12</li><li>C: 13</li><li>D: 14</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nСравнение двух массивов или объектов в JavaScript всегда возвращает false, поскольку оба передаются по ссылке, в отличие от примитивов, таких как строка, число или логическое значение. Вот почему сравнение [] и [] с помощью == или === возвращает false. Странная часть - это !==!!!!!, что эквивалентно !==, так что в ней нет ничего особенного. Таким образом, значением переменной "flag" является true.<br>\nВ функциональном выражении "f()" мы используем стрелочную функцию, но {} - это часть функции, а не объект. Для того, чтобы вернуть объект, следует написать "let f = () =&gt; ({})" или использовать обычную функцию. С помощью ключевого слова "return" мы легко можем поймать содержимое функции, когда используем обычный способ ее определения.<br>\nПоэтому "typeof f()" возвращает undefined, а не object. Затем мы получаем 9 (длина undefined) + 4 (длина строки "true") = 13.\n</p>\n</article>\n</details>\n</section><section id="212"><h3>Вопрос № 212</h3>\n<pre><code class="lang-js">\n(function (a, b, c) {\n    arguments[2] = (typeof arguments).length;\n    c &gt; 10 ? console.log(c) : console.log(++c);\n})(1, 2, 3);\n</code></pre>\n<ul>\n<li>A: 4</li><li>B: 5</li><li>C: 6</li><li>D: 7</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nЗдесь мы имеем дело с самовызываемой функцией с тремя параметрами. Обратите внимание, что arguments внутри функции возвращает объект, состоящий из параметров функции.<br>\nКогда мы присваиваем значение этому массиву (массивоподобному объекту) (или любому его элементу), функция будет использовать это значение, а не значение переданного при ее вызове параметра. Поэтому значением "(typeof arguments).length" будет 6, а не 3.<br>\n6 меньше 10, поэтому мы получаем console.log(++c) или 7.<br>\nОбратите внимание, что arguments не доступна в стрелочных функциях.<br>\nES6 рекомендует использовать прочие параметры (...rest) - настоящий массив. Это означает, что таким массивом можно манипулировать с помощью таких методов, как map, filter или reduce.\n</p>\n</article>\n</details>\n</section><section id="213"><h3>Вопрос № 213</h3>\n<pre><code class="lang-js">\nclass Calculator {\n    constructor(a, b) {\n        this.a = a;\n        this.b = b;\n    }\n    static getFlag() {\n        return new Array(this.a).length == new Array(this.b).toString().length;\n    }\n\n    getValue() {\n        return Calculator.getFlag() ? typeof this.a : typeof new Number(this.b);\n    }\n}\n\nconst me = new Calculator(5, 5);\n\nconsole.log(me.getValue());\n</code></pre>\n<ul>\n<li>A: NaN</li><li>B: "string"</li><li>C: "object"</li><li>D: "number"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nУ нас есть класс Calculator. При объявлении нового экземпляра мы передаем два параметра: "a" и "b". Эти параметры одинаковые, но "new Array(this.a).length" сильно отличается от "new Array(this.b).toString().length", поскольку последний возвращает длину строки \',,,,\' или 4, а первый - длину массива или 5.<br>\nПо этой причине getFlags() возвращает false. В getValue() мы получаем "typeof new Number(this.b)", что возвращает object. Это немного отличается от "typeof b", что возвращает number.\n</p>\n</article>\n</details>\n</section><section id="214"><h3>Вопрос № 214</h3>\n<pre><code class="lang-js">\nvar name = "Auckland";\n\nconst nz = {\n    name: "Kiwi",\n\n    callMe: function () {\n        return this.name;\n    },\n};\n\nlet me = nz.callMe;\n\nlet she = nz.callMe.bind(nz);\n\nlet result = me() === nz.callMe() ? she() : `&#36;{me()} &#36;{she()}`;\n\nconsole.log(result);\n</code></pre>\n<ul>\n<li>A: undefined</li><li>B: "Auckland"</li><li>C: "Kiwi"</li><li>D: "Auckland Kiwi"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nДанный вопрос посвящен ключевому слову "this". У нас есть простой объект, содержащий один метод и одно свойство.<br>\nВо-первых, важно понимать, что "let me = nz.callMe" и последующий вызов me() существенно отличаются от прямого вызова "nz.callMe()". Если мы присваиваем переменной метод, объявленный внутри объекта, this в этом объекте будет вести себя по-разному (когда мы вызываем переменную как метод и когда мы вызываем сам метод). В частности, в первом случае, this - это объект window, в то время как во втором случае this внутри функции по-прежнему ссылается на свойство "name" объекта "nz". Это означает, что me() возвращает \'Auckland\', а nz.callMe - \'Kiwi\'.<br>\nЗатем result возвращает false, и мы получаем &#36;{me()} &#36;{she()}. Почему she() отличается от me()? Потому что she() привязана к объекту nz, а me() нет.\n</p>\n</article>\n</details>\n</section><section id="215"><h3>Вопрос № 215</h3>\n<pre><code class="lang-js">\nconst club = {\n    name: "Juventus",\n    player: ["Ronaldo"],\n    showMePlayer: function () {\n        this.player.map(function (thename) {\n            console.log(this.name.length);\n        }, this);\n    },\n    showMe: function () {\n        this.player.forEach(\n        function (thename) {\n            console.log(this.name.length);\n        }.bind(this)\n        );\n    },\n    show: function () {\n        const self = this;\n        this.player.map(function (thename) {\n            console.log(self.name.length);\n        });\n    },\n    Me: function () {\n        this.player.map(function (thename) {\n            console.log(this.name.length);\n        });\n    },\n};\n\nclub.showMePlayer();\nclub.showMe();\nclub.show();\nclub.Me();\n</code></pre>\n<ul>\n<li>A: 8 - 8 - 8 - 8</li><li>B: "Juventus" - "Juventus" - "Juventus" - "Juventus"</li><li>C: "Ronaldo" - "Ronaldo" - "Ronaldo" - "Ronaldo"</li><li>D: 8 - 8 - 8 - 0</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nДанная задача не слишком сложна для вас, не так ли? В ней просто приводится пример this в разных контекстах, когда мы объявляем анонимную функцию внутри метода объекта. Первые три метода являются распространенными способами обработки this с помощью this как второго параметра map(), bind(this) в forEach (или map()) или с помощью приема "that = this" (мы используем self вместо that).<br>\nПоследний метод Me() приводит к неожиданному результату, поскольку "this.name" не привязано к объекту "club". Обратите внимание, что при тестировании кода в jsbin мы получаем другой результат. В Chrome и Firefox мы получаем 0.\n</p>\n</article>\n</details>\n</section><section id="216"><h3>Вопрос № 216</h3>\n<pre><code class="lang-js">\n((...a) =&gt; {\n    const b = ["javascript", "new zealand"];\n\n    const c = [...a, typeof a, ...b, "kiwi"];\n\n    console.log(c.length + c[0].length);\n})(new Array(10));\n</code></pre>\n<ul>\n<li>A: 5</li><li>B: 10</li><li>C: 15</li><li>D: 20</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\n... используется двумя способами: как оператор распространения (spread) и как прочие параметры (rest).<br>\nВ приведенном примере мы видим оба способа. Первый оператор в самовызывающейся функции - это, разумеется, rest, а в константе c мы видим spread. В первом случае мы можем передать фукнции любое количество параметров. Обратите внимание, что "typeof a" - это object, несмотря на то, что фактически - это настоящий массив (в отличие от массивоподобного объекта "arguments").<br>\nspread позволяет нам объединять массивы. Таким образом, ...a - это оператор rest при использовании в качестве параметра функции, но в константе - это оператор spread.<br>\nМы получаем "c" с пятью элементами (...a - это вложенный массив, поэтому его длина равняется 1), но первый элемент имеет 10 элементов (когда мы передали в функцию new Array(10)). Сумма длин обоих равняется 15.\n</p>\n</article>\n</details>\n</section><section id="217"><h3>Вопрос № 217</h3>\n<pre><code class="lang-js">\nfunction Kiora(name, ...career) {\n    this.name = name;\n\n    return Array.isArray(career) === true &amp;&amp; typeof career === "object" ? {} : "";\n}\n\nvar student = new Kiora("Vuong");\n\nconsole.log(student.name);\n</code></pre>\n<ul>\n<li>A: "Vuong"</li><li>B: undefined</li><li>C: ErrorReference</li><li>D: false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nУ нас имеется конструктор функции "Kiora" (написано с заглавной буквы, но это не обязательно), который может использоваться для создания объекта, как объект "student" в задаче. В функции имеется два параметра, хотя второй параметр - это на самом деле оператор rest. Типом оператора является "object", но "Array.isArray(career)" возвращает true. Оператор "return" возвращает объект {}.<br>\nВы можете быть удивлены, когда "console.log(student.name)" выведет в консоль undefined, если конструктор возвращает объект.\n</p>\n</article>\n</details>\n</section><section id="218"><h3>Вопрос № 218</h3>\n<pre><code class="lang-js">\nclass Filter {\n    constructor(element) {\n        this.element = element;\n    }\n    filter() {\n        return this.type() === "object" ? this.element[0].name : "hello";\n    }\n\n    type() {\n        return typeof this.element;\n    }\n}\n\nlet countries = [\n    { name: "New Zealand", isdeveloped: true },\n    { name: "Vietnam", isdeveloped: false },\n];\n\nlet x = new Filter(countries);\n\nconst filter = countries.filter((item) =&gt; {\n    return !item.isdeveloped;\n});\n\nconsole.log(x.filter().length + filter[0].name.length);\n</code></pre>\n<ul>\n<li>A: 15</li><li>B: 16</li><li>C: 17</li><li>D: 18</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nПример получился длиннее, чем обычно. На самом деле он не слишком сложный. Вы легко найдете правильный ответ, потратив немного времени.<br>\nСначала мы определяем класс с двумя методами. Первый метод "filter()" возвращает первый элемент массива (свойства element) или "hello" в зависимости от метода "type()". Мы знаем, что "typeof array" вернет object, так что filter() вернет this.elements[0].name.<br>\nЗатем мы вызываем встроенный метод "filter()". Этот метод возвращает новый массив в зависимости от условия, переданного колбеку. Обратите внимание, что "!item.isdeveloped" означает false. Значит, мы получаем "Vietnam".<br>\nНаконец, мы получаем "New Zealand.length" и "Vietnam.length", что в сумме дает 18.\n</p>\n</article>\n</details>\n</section><section id="219"><h3>Вопрос № 219</h3>\n<pre><code class="lang-js">\nasync function abc() {\n    console.log(8);\n\n    await Promise.resolve(2).then(console.log);\n\n    console.log(3);\n}\n\nsetTimeout(() =&gt; {\n    console.log(1);\n}, 0);\n\nabc();\n\nqueueMicrotask(() =&gt; {\n    console.log(0);\n});\n\nPromise.resolve(4).then(console.log);\n\nconsole.log(6);\n</code></pre>\n<ul>\n<li>A: 6 - 8 - 3 - 0 - 4 - 2 - 1</li><li>B: 8 - 2 - 3 - 0 - 4 - 6 - 1</li><li>C: 6 - 8 - 2 - 0 - 4 - 3 - 1</li><li>D: 8 - 6 - 2 - 0 - 4 - 3 - 1</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nПорядок выполнения асинхронного кода зависит от микро- и макрозадач. Микрозадачи имеют приоритет. Запомните, что синхронный код всегда выполняется перед асинхронным. Поэтому мы имеем следующий порядок:<br>\n</p><pre><code class="lang-js">\n1) synchronous code\n2) microtask code (promise, queueMicrotask)\n3) macrotask code (setTimeout, setInterval)\n</code></pre>\nОбратите внимание, что в Node.js у нас также имеется process.nextTick(callback), который имеет высший приоритет, но его здесь нет.<br>\nИтак, первый колбек - это setTimeout(), который будет выполнен последним, поскольку является макрозадачей. Поэтому мы получаем 1 последним.<br>\nСледующей вызывается функция abc(). Сначала в консоль выводится 8. Затем на ключевом слове "await" выполнение функции приостанавливается, выполняется console.log(6), поскольку "Promise.resolve(4).then(console.log)" - это асинхронный код. Вот почему следующим мы получаем 6.<br>\nТеперь настало время для "Promise.resolve(2)", поэтому мы получаем 2. Что произойдет если убрать ключевое слово "await"?<br>\nПоскольку у нас имеется ключевое слово "await", выполнение кода ставится на паузу. Мы получаем 0 и 4, а не 3. Promise и queueMicrotask - микрозадачи, которые выполняются перед console.log(3).<br>\nНа следующем этапе мы получаем 3 и последним 1.<br>\nТак что же произойдет, если убрать ключевое слово "await"? Тогда порядок будет следующим: 8-3-6-2-0-4-1.\n<p></p>\n</article>\n</details>\n</section><section id="220"><h3>Вопрос № 220</h3>\n<pre><code class="lang-js">\nconst hoccoban = {\n    x: "youtube.com/hoccoban".length,\n    getMe() {\n        const inner = function () {\n            console.log(++this.x);\n        };\n        inner.bind(this)();\n    },\n};\n\nhoccoban.getMe();\n</code></pre>\n<ul>\n<li>A: 20</li><li>B: 21</li><li>C: 22</li><li>D: 23</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nМы получаем 21. Сначала "youtube.com/hoccoban" возвращает 20, поскольку мы используем свойство "length" строки. Затем значение "x" увеличивается на 1 посредством "++this.x". Вопрос выглядит тривиальным, но это не так. Нужно помнить о том, что "console.log(++this.x)" не будет работать, если значением "x" будет undefined при вызове за пределами объекта.<br>\nМы можем решить эту проблему с this с помощью стрелочной функции: const inner = () =&gt; {}, поскольку стрелочные функции берут this из внешнего (лексического) окружения.<br>\nВторым решением является использования трюка с that/this. Нам нужно лишь объявить новую переменную "const that = this" внутри insideMe() и перед объявлением функции "inner". Это довольно распространенный прием.<br>\nТретьим решением является использование apply(), call() или bind(), нативных методов функций (функция - это тоже объект). В данном случае, мы реализовали bind(this) для связывания функции и объекта, чтобы this указывал на объект при выполнении функции. Обратите внимание, что bind() не выполняется сразу, поэтому мы добавили () после него. Если заменить bind() на call(), то дополнительные () не понадобятся. inner.bind(this)() станет inner.call(this). На практике, мы, как правило, создаем переменную для хранения результата связывания функции и объекта.\n</p>\n</article>\n</details>\n</section><section id="221"><h3>Вопрос № 221</h3>\n<pre><code class="lang-js">\nfunction* hocCoBan() {\n    yield "js.edu.vn";\n    yield "youtube.com/hoccoban";\n    yield "Vuong Nguyen";\n}\n\nlet data = hocCoBan();\n\nconsole.log((typeof data).length + data.next().value.length);\n</code></pre>\n<ul>\n<li>A: NaN</li><li>B: 10</li><li>C: Error</li><li>D: 15</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nПрисмотритесь к функции. После ключевого слова "function" имеется символ "*". В функции отсутствует ключевое слово "return". Что здесь происходит?<br>\nЕсли вы знакомы с генераторами, решить данную задачу вам не составит труда. Мы не часто используем генераторы, но они являются основой async/await, позволяющей удобно работать с асинхронным кодом.<br>\nОператор "typeof data" возвращает object, а не function. typeof hoCoBan возвращает function, поскольку hoCoBan - обычная функция. Оператор "(typeof data).length" возвращает 6.<br>\ndata.next() вызывает встроенный метод next(), который возвращает значение первого yield, определенного в функции. Получаем 9 - длину строки "js.edu.vn".<br>\nВ итоге получаем 15. Понимание работы генераторов важно, если вы хотите понять, как работает async/await.\n</p>\n</article>\n</details>\n</section><section id="222"><h3>Вопрос № 222</h3>\n<pre><code class="lang-js">\nconst a = [1, 2, "chó", 3, 1, "chó", "mèo", 3];\n\nconst b = [...new Set(a)];\n\nb.length = "chó".length;\n\nconsole.log(b);\n</code></pre>\n<ul>\n<li>A: 4</li><li>B: [1, 2, "chó", 3, "mèo"]</li><li>C: [1, 2, "chó", "mèo"]</li><li>D: [1, 2, "chó"]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\n... в массиве - это оператор распространения (spread), который похож на оператор rest (прочие параметры). Данный оператор позволяет объединять (изменять) и копировать массивы. В примере "b" - это копия "a". Тем не менее, когда мы передаем "a" в Set, возвращаются только уникальные значения. Это означает, что "b" содержит [1, 2, "chó", 3, "mèo"].<br>\nЗатем мы устанавливаем значение длины "b" равное 3 ("chó".length).<br>\nТаким образом, мы уменьшили длину массива. Вот почему в консоль выводится только [1, 2, "chó"].\n</p>\n</article>\n</details>\n</section><section id="223"><h3>Вопрос № 223</h3>\n<pre><code class="lang-js">\nconst mot = function (m) {\n    return arguments[0];\n};\n\nconst hai = function (...m) {\n    return arguments[arguments[0]];\n};\n\nconst a = [mot(123), hai(1, 2, 3)];\n\nconsole.log(typeof a !== "object" ? a[0] : a[1]);\n</code></pre>\n<ul>\n<li>A: 1</li><li>B: 2</li><li>C: 3</li><li>D: 123</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nПрежде всего, следует заметить, что мы не можем использовать arguments в стрелочных функциях. arguments - это массивоподобный объект, который содержит параметры функции, переданные при ее вызове.<br>\n... - это оператор rest (прочие параметры). Мы используем его в функции и массиве. Обратите внимание, что ... в массиве - это оператор распространения (spread), который ведет себя иначе, чем rest. При использовании ... в функции, мы можем передавать ей любое количество параметров.<br>\nОбратите внимание, что в функции "hai" мы возвращаем "arguments[arguments[0]]" или "hai(1, 2, 3)", или 2, а не 1, поскольку arguments[0] возвращает 1, а arguments[1] - 2.<br>\n"typeof a" возвращает "object". В итоге мы получаем 2 из a[1] или hai(1, 2, 3).\n</p>\n</article>\n</details>\n</section><section id="224"><h3>Вопрос № 224</h3>\n<pre><code class="lang-js">\nclass Component {\n    constructor(age) {\n        this.age = age + `&#36;{typeof Coder}`.length;\n    }\n\n    getAge() {\n        return ++this.age;\n    }\n}\n\nclass Coder extends Component {\n    constructor(age) {\n        super(age);\n        this.age = age - `&#36;{typeof Coder}`.length;\n    }\n}\n\nconst a = new Coder(16);\n\nconsole.log(a.getAge());\n</code></pre>\n<ul>\n<li>A: 7</li><li>B: 8</li><li>C: 9</li><li>D: 10</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nУ нас есть два простых класса, Coder расширяет Component. Ничего особенного. Поскольку "typeof ClassName" возвращает function, а не class, мы получаем 8 из "function".length.<br>\nПоскольку мы используем super(age) в классе Coder, то перезаписываем конструктор родительского класса Component. Поэтому при инициализации объекта "a" автоматически выполняется "this.age = age - `&#36;{typeof Coder}`.length". Разница между дочерним и родительским конструкторами заключается в арифметической операции.<br>\nТаким образом, мы получаем 16 - 8, а не 16 + 8, т.е. 8. Функция "getAge()" возвращает 9.<br>\nПомните, что JavaScript - это не настоящий объектно-ориентированный язык, несмотря на то, что мы можем использовать в нем классы и объекты.\n</p>\n</article>\n</details>\n</section><section id="225"><h3>Вопрос № 225</h3>\n<pre><code class="lang-js">\nclass RemoveFalse {\n    constructor(element) {\n        this.element = element;\n\n        this.length = this.removeFalse().length;\n    }\n\n    removeFalse() {\n        this.element = this.element.filter(Boolean);\n\n        return this.element;\n    }\n}\n\nconst theArray = [true, false, 1, 0, NaN, undefined, "", null, "js.edu.vn"];\n\nconst a = new RemoveFalse(theArray);\n\nconsole.log(a.length);\n</code></pre>\n<ul>\n<li>A: false</li><li>B: true</li><li>C: 2</li><li>D: 3</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОсновной вывод, который можно сделать из примера - filter(Boolean) может быть использован для удаления ложных значений в массиве. Для этого мы также можем использовать filter(callback). Обратите внимание, что мы должны передать filter функцию обратного вызова, а Boolean как раз является такой функцией. Вы можете убедиться в этом с помощью typeof Boolean.<br>\nКак и map или reduce, filter возвращает новый массив из существующего. "[true, false, 1, 0, NaN, undefined, "", null, "js.edu.vn"].filter(Boolean)" возвращает "[true, 1, \'js.edu.vn\']", поэтому вызов функции "removeFalse()" возвращает 3.\n</p>\n</article>\n</details>\n</section><section id="226"><h3>Вопрос № 226</h3>\n<pre><code class="lang-js">\nconst coderfarm = [1, [], {}, [], 2, 3];\n\nconst converted = Number(coderfarm instanceof Array);\n\nconst result = coderfarm.indexOf(converted + true);\n\nconsole.log(result);\n</code></pre>\n<ul>\n<li>A: []</li><li>B: {}</li><li>C: 2</li><li>D: 4</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nУ нас есть массив, состоящий из нескольких чисел, двух массивов и объекта. Посредством встроенной функции "Number" мы можем конвертировать любое переданное ей значение в число. "codefarm instanceof Array" возвращает true, которое преобразуется в 1. Для проверки того, является ли значение массивом, также можно использовать "Array.isArray(arrayToBeChecked)", возвращающий логическое значение. Оператор "typeof []" возвращает object, а не array.<br>\nВстроенная функция "indexOf" возвращает индекс искомого элемента. Поскольку "converted + true" возвращает 2, мы ищем индекс элемента 2 в массиве codefarm.<br>\nДанный элемент находится на 4 позиции.\n</p>\n</article>\n</details>\n</section><section id="227"><h3>Вопрос № 227</h3>\n<pre><code class="lang-js">\nconst converter = (arrayInput) =&gt; {\n    return { ...arrayInput };\n};\n\nconst content = ["function", "object", "decorator"];\n\nconst checking = content[Number(false)];\n\nconst result = typeof converter(content) === content[1];\n\nconsole.log(checking ? (result ? (typeof converter).length : false) : false);\n</code></pre>\n<ul>\n<li>A: 6</li><li>B: NaN</li><li>C: true</li><li>D: 8</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОператор ... является очень полезным. В функции "converted" нет ничего необычного, она использует преимущества ... (оператор rest || оператор spread) для преобразования массива в объект.<br>\nКонстанта "checking" имеет значение "function" из Number(false), что дает 0, т.е. значением checking является элемент массива content с индексом 0.<br>\nКонстанта "result" имеет значение true, поскольку "typeof converter(content)" возвращает function, как и content[1].<br>\nТаким образом, мы получаем "checking = true" и "result = true", поэтому получаем "(typeof converter).length" или "function".length, или 8.<br>\nГлавный вывод здесь такой: мы можем использовать оператор распространения (spread) для преобразования массива в объект. Например: const a = [\'hello\', 2]; const b = {...a}, получаем b = {0: \'hello\', 1: 2}. Ключом объекта в данном случае является индекс элемента в массиве.\n</p>\n</article>\n</details>\n</section><section id="228"><h3>Вопрос № 228</h3>\n<pre><code class="lang-js">\nfunction* js(length) {\n    for (let i = length.length; i &gt; 0; --i) {\n        yield i;\n    }\n}\n\nlet getJS = js(typeof js);\n\nlet result = getJS.next().value;\n\nconsole.log(result + getJS.next().value);\n</code></pre>\n<ul>\n<li>A: 10</li><li>B: 14</li><li>C: 15</li><li>D: 16</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nЗдесь мы имеем дело с функцией-генератором, которая определяется с помощью символа "*".<br>\nБлагодаря ключевому слову "yield" мы можем хранить в функции любое количество значений.<br>\nПоскольку "typeof js" возвращает function, длина этой строки равняется 8. Поэтому при вызове "getJS.next().value" мы получаем 8. При следующем вызове мы получаем 7, затем 6. Вот почему генератор может хранить и возвращать любое количество значений.<br>\nВ итоге мы получаем 8 + 7 = 15.\n</p>\n</article>\n</details>\n</section><section id="229"><h3>Вопрос № 229</h3>\n<pre><code class="lang-js">\nvar ages = [10, 15, 20, 25];\n\nlet response = [];\n\nages.some(function (currentValue, index, ages) {\n    if (currentValue &gt; ages[ages.length - index])\n        response.push(currentValue + ages.length);\n});\n\nconsole.log(response);\n</code></pre>\n<ul>\n<li>A: [20]</li><li>B: [20, 25]</li><li>C: [25, 29]</li><li>D: [29]</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nArray.prototype.some() - это встроенная функция, позволяющая перебирать массив с помощью колбека. Колбек в примере имеет три параметра: currentValue (значение текущего элемента массива), index (индекс текущего элемента) и ages (сам массив).<br>\nФункция some() возвращает логическое значение. Код "currentValue &gt; ages[ages.length - index]" возвращает true только один раз, поскольку речь идет о последнем элементе. Давайте рассмотрим код последовательно:<br>\n</p><pre><code class="lang-js">\n10 &gt; ages[4 - 0]. Поскольку ages[4] возвращает undefined, и "10 &gt; undefined" также возвращает false, выполнение кода останавливается.\n\n15 &gt; ages[4 - 1]. Поскольку ages[3] возвращает 25, условие является ложным.\n\n20 &gt; ages[4 - 2]. Поскольку ages[2] возвращает 20, условие также не удовлетворяется.\n\n25 &gt; ages[4 - 3]. Поскольку ages[1] возвращает 10, выражение возвращает true. Только это значение помещается в массив "response".\n</code></pre>\nВ массиве "response" содержится "response.push(currentValue + ages.length)" или "25 + ages.length" или "25 + 4", т.е. 29.\n<p></p>\n</article>\n</details>\n</section><section id="230"><h3>Вопрос № 230</h3>\n<pre><code class="lang-js">\nconst getSTring = (string, method = false) =&gt; {\n    if (method === true) {\n        return string.slice(1, 4).length;\n    }\n\n    return string.substr(1, 4).length;\n};\n\nconsole.log(getSTring("hello", true) + getSTring("hello"));\n</code></pre>\n<ul>\n<li>A: 6</li><li>B: 7</li><li>C: 8</li><li>D: 9</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\ngetString() - это стрелочная функция с двумя параметрами. Как видите, параметр "method" имеет значение по умолчанию, равное false, если не передать другое значение при вызове функции, будет использовано значение по умолчанию.<br>\nОсновной вывод: разница между slice(1, 4), возвращающим 3, и substr(1, 4), возвращающим 4.<br>\nconsole.log(getSTring("hello", true) + getSTring("hello")) или console.log(string.substr(1, 4).length + string.slice(1, 4).length), или console.log(4 + 3) выводит в консоль 7.\n</p>\n</article>\n</details>\n</section><section id="231"><h3>Вопрос № 231</h3>\n<pre><code class="lang-js">\n(function (a, b, c) {\n    console.log(Boolean([...arguments].slice(2, 3)[0].slice(3, 4)));\n})("hello", "world", "new zealand");\n</code></pre>\n<ul>\n<li>A: "new"</li><li>B: true</li><li>C: "land"</li><li>D: false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nЗдесь мы имеем дело с самовызываемой функцией (IIFE). Такая функция вызывается сразу после объявления. У нас есть три параметра и три аргумента: "hello", "world" и "new zealand".<br>\nСначала arguments возвращает объект, состоящий из аргументов, переданных функции при ее вызове. С помощью оператора распространения (...spread) мы преобразуем объект в массив. Мы также можем сделать это с помощью "Array.from(object)".<br>\nДалее slice(2, 3) извлекает элемент со второго по третий индекс, т.е. "new zealand". Это все еще массив. Затем мы извлекаем элемент с индексом 0 и получаем строку "new zealand".<br>\nНаконец, "new zealand".slice(3, 4) возвращает " " (пробел). Boolean(" ") возвращает true. Если бы строке не было пробела, мы получили бы false.<br>\n</p>\n</article>\n</details>\n</section><section id="232"><h3>Вопрос № 232</h3>\n<pre><code class="lang-js">\nclass HocCoBan {\n    name = "hello world";\n\n    getSlice(slice) {\n        return this.getName(slice).slice(true, this.name.length);\n    }\n\n    getName(space) {\n        return this.name.split(space);\n    }\n}\n\nHocCoBan.prototype.split = function (argument) {\n    return this.getSlice(argument);\n};\n\nconst a = new HocCoBan();\n\nconsole.log(a.split("").length);\n</code></pre>\n<ul>\n<li>A: NaN</li><li>B: true</li><li>C: 10</li><li>D: 11</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nВ примере нет ничего необычного. Он намеренно запутан. У нас есть класс HocCoBan с двумя методами и одним свойством. Затем мы добавляем к нему еще один метод "split", используя традиционный способ (через prototype). Помните, что class в JavaScript - это лишь синтаксический сахар function (typeof ClassName возвращает function).<br>\nПри вызове split мы передаем ему пустую строку. Данный метод вызывает другие методы. Порядок следующий:<br>\nsplit("") -&gt; this.getSlice("") -&gt; this.getName("") -&gt; this.name.split(""). Здесь split - это функция, преобразующая строку в массив.<br>\nОбратите внимание, что в getSlice() мы используем ".slice(true, this.name.length)" для модификации массива с 1 по 11 индекс. Длина нового массива равна 10.<br>\nДанный код помогает понять, как работают прототипы в JavaScript, а также увидеть разницу между встроенными и пользовательскими методами.\n</p>\n</article>\n</details>\n</section><section id="233"><h3>Вопрос № 233</h3>\n<pre><code class="lang-js">\nfunction javaScript(node) {\n    let mot = node.includes("I") ? "love" : "you";\n\n    return function (deno = mot) {\n        let hai = node.replace(deno, "done");\n\n        return function (done = hai) {\n            return (node + deno + done).length;\n        };\n    };\n}\n\nconsole.log(javaScript("I love you")()());\n</code></pre>\n<ul>\n<li>A: 18</li><li>B: 24</li><li>C: 20</li><li>D: 25</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nКроме изучения некоторых встроенных функций для работы со строками, таких как "replace" и "includes", здесь мы имеем дело с каррированием. Обратите внимание, что только внешняя (главная) функция имеет название, внутренние функции являются анонимными. У нас также имеется три ключевых слова "return".<br>\nПри вызове функции необходимо использовать три пары круглых скобок - javaScript("I love you")()(). Мы не передаем аргументы вложенным функциям, поэтому они используют значения по умолчанию.<br>\nРезультирующим выражением является "return (node + deno + done).length", где node - "I love you", deno - "love" и done - "I done you". Результирующая длина равняется 24 (I love youyou I done you). Пробелы также принимаются в расчет.\n</p>\n</article>\n</details>\n</section><section id="234"><h3>Вопрос № 234</h3>\n<pre><code class="lang-js">\nconst www = ["hello", "coranovirus", "kiora", "world", "new zealand"];\n\nconst found = www.find(function (world) {\n    return world &gt; "victory";\n});\n\nconst result = found[1] &lt; www[0][0] ? www[false ? 1 : 0] : www[true ? 0 : 1];\n\nconsole.log(result);\n</code></pre>\n<ul>\n<li>A: "hello"</li><li>B: "world"</li><li>C: "victory"</li><li>D: "w"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nДанный вопрос посвящен методу "Array.prototype.find()". Он возвращает первый элемент, удовлетворящий условию, определенному в колбеке, передаваемом функции. Массив перебирается поэлементно. В примере "world" - это первый элемент, значение которого больше чем значение "victory". Запомните, при сравнении "w" &gt; "v" возвращается true. При сравнении двух слов, сравниваются только их первые буквы.<br>\nЗначением "found" является "world" и поэтому found[1] возвращает "w", а www[0][0] возвращает "h" как первую букву "hello". Это объясняет, почему found[1] &lt; www[0][0] возвращает false.<br>\nВ итоге мы получаем www[true ? 0 : 1] или www[0], или hello.\n</p>\n</article>\n</details>\n</section><section id="235"><h3>Вопрос № 235</h3>\n<pre><code class="lang-js">\n(function (flag) {\n    let age = Boolean(NaN === NaN ? false : flag);\n\n    console.log(age.toString()[Number(flag)]);\n})([]);\n</code></pre>\n<ul>\n<li>A: "f"</li><li>B: "t"</li><li>C: true</li><li>D: false</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nУ нас есть самовызываемая функция с пустым массивом в качестве параметра. Обратите внимание, что NaN === NaN возвращает false, затем переменная "age" получает значение flag, т.е. пустой массив. Boolean([]) возвращает true.<br>\nФункция "toString()" возвращает строку "true", а Number([]) - 0. Поэтому в консоль выводится "t".<br>\nЗапомните, что Boolean([]) = true, но Number([]) = 0. И NaN === NaN дает false.\n</p>\n</article>\n</details>\n</section><section id="236"><h3>Вопрос № 236</h3>\n<pre><code class="lang-js">\nconsole.log(Boolean([]));\nconsole.log(Number([]));\nconsole.log(Number(Boolean([])));\nconsole.log(Boolean(Number([])));\n\nconsole.log(Boolean({}));\nconsole.log(Number({}));\nconsole.log(Number(Boolean({})));\nconsole.log(Boolean(Number({})));\n\nconsole.log(Boolean(new Boolean(false)));\n</code></pre>\n<ul>\n<li>A: true - 0 - 1 - false - true - 1 - 1 - false - false</li><li>B: true - 0 - 1 - false - false - NaN - 1 - false - true</li><li>C: true - 0 - 1 - false - false - false - 1 - false - false</li><li>D: true - 0 - 1 - false - true - NaN - 1 - false - true</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: B</h3>\n<p>\nJavaScript - это язык со слабой (динамической) типизацией. Тип данных переменной может меняться в зависимости от значения. При изменении одного значения на другое поведение JavaScript может быть весьма неожиданным.<br>\nНапример, Number([]) возвращает 0, Number({}) - NaN, а Boolean([]) и Boolean({}) - true.<br>\nBoolean(new Boolean(false)) возвращает true, несмотря на то, что мы передаем конструктору функции Boolean значение false. Однако, если мы уберем ключевое слово "new", то получим false. Boolean(new Boolean(false)) - это валидная операция, поэтому возвращается true. С другой стороны, Boolean(Boolean(false)) без ключевого слова "new", возвращает false, поскольку значение "false" не является операцией.\n</p>\n</article>\n</details>\n</section><section id="237"><h3>Вопрос № 237</h3>\n<pre><code class="lang-js">\nconst myYoutube = {\n    name: "hoccoban",\n    address: "youtube.com/hoccoban",\n    getInfo() {\n        return this;\n    },\n    content: () =&gt; (this === window ? myYoutube.getInfo() : this),\n};\n\nconsole.log(myYoutube.content().name);\n</code></pre>\n<ul>\n<li>A: "hoccoban"</li><li>B: window (object)</li><li>C: NaN</li><li>D: undefined</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nДля того, чтобы правильно ответить на данный вопрос, нужно понимать концепцию this в JavaScript (в браузере). По умолчанию this указывает на объект window. Обратите внимание, что Window (с заглавной буквы) - это конструктор функции объекта window. Поэтому console.log(this === window) возвращает true, а console.log(this === Window) - false.<br>\ngetInfo() - это стрелочная функция, this, объявленный внутри этой функции, указывает на window, поэтому myYoutube.content() возвращает myYoutube.getInfo(). Обратите внимание, что нам пришлось явно писать myYoutube.getInfo() для того, чтобы код работал корректно, поскольку this не указывает на текущий объект. В функции "getInfo()" this указывает на текущий объект, поскольку getInfo() - это обычная функция.<br>\nВ итоге мы получаем hoccoban как значение свойства name.\n</p>\n</article>\n</details>\n</section><section id="238"><h3>Вопрос № 238</h3>\n<pre><code class="lang-js">\nconst myArray = [1, 2, 3];\n\nmyArray.someProperty = this;\n\nArray.prototype.someOtherProperty = "hello";\n\nlet result = [];\n\nfor (let key in myArray) {\n    result.push(key);\n}\n\nfor (let key in myArray) {\n    if (myArray.hasOwnProperty(key)) {\n        result.push(key);\n    }\n}\n\nconsole.log(result.length);\n</code></pre>\n<ul>\n<li>A: 10</li><li>B: NaN</li><li>C: 9</li><li>D: 7</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: C</h3>\n<p>\nУ нас есть простой массив с тремя элементами. При проверке типа массива с помощью typeof мы получаем object (для определения того, что значение является массивом, можно использовать Array.isArray(array) или array instanceof Array).<br>\nПри объявлении myArray.someProperty мы добавляем новое свойство к данному массиву, при объявлении Array.prototype.someProperty = \'hello\', мы добавляем новое свойство к каждому массиву.<br>\nЦикл for... in перебирает массив и возвращает пары ключ/значение, включая унаследованное свойство. На второй итерации мы используем метод hasOwnProperty(key), который перебирает только собственные (не унаследованные) ключи/значения.<br>\nЕсли коротко, на первой итерации мы получаем 5 (3 исходных элемента, 1 собственное свойство и еще 1 унаследованное). На второй - только 4 (унаследованное свойство не учитывается).<br>\nДля перебора массива обычно используется for... of или классический for. Использование for... in для этого является плохой практикой. for... in, как правило, используется для перебора объектов.\n</p>\n</article>\n</details>\n</section><section id="239"><h3>Вопрос № 239</h3>\n<pre><code class="lang-js">\nconst coderfarm = [1, 2, 3, 4, 5];\n\nconst [top, ...bottom] = (function (a) {\n    let result = a;\n\n    a.unshift(new Array(3));\n\n    return result;\n})(coderfarm);\n\nconsole.log(top.length + bottom.length);\n</code></pre>\n<ul>\n<li>A: 8</li><li>B: 9</li><li>C: 10</li><li>D: 11</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nЗдесь мы используем деструктуризацию для извлечения значений массива (или объекта) и оператор расптространения (...spread).<br>\nДеструктурируемый массив возвращается из самовызываемой функции. Сначала мы передаем аргумент "codefarm" (параметр "a" в функции). Затем мы обновляем этот массив, добавляя в начало (посредством unshift) массив из трех undefined (с помощью new Array(3)). После этого массив выглядит так: [[undefined, undefined, undefined], 1, 2, 3, 4, 5].<br>\nПеременная "top" - это первый элемент массива или [undefined, undefined, undefined], длина которого равняется 3.<br>\nПеременная "bottom" - это прочие элементы массива, ее длина равняется 5.<br>\nВ итоге мы получаем 3 + 5 = 8.\n</p>\n</article>\n</details>\n</section><section id="240"><h3>Вопрос № 240</h3>\n<pre><code class="lang-js">\nlet age = { number: 10 };\n\nconst getAge = (flag) =&gt; {\n    flag ? delete age.number : delete age;\n    return age.number++;\n};\n\nconsole.log(getAge(false));\n\nconsole.log(age.number);\n\nconsole.log(getAge(true));\n\nconsole.log(age.number);\n</code></pre>\n<ul>\n<li>A: 10 - 10 - NaN - NaN</li><li>B: 10 - 10 - undefined - undefined</li><li>C: 10 - 11 - undefined - undefined</li><li>D: 10 - 11 - NaN - NaN</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: D</h3>\n<p>\nОператор "delete" удаляет свойство объекта, а не сам объект. У нас есть простая функция "getAge()" с параметром flag. Если значением flag является true, выполняется код "delete age.number", в противном случае, мы пытаемся удалить объект.<br>\nПоскольку delete не может удалить объект, можно сказать, что "delete age" ничего не делает. console.log(getAge(false)) возвращает 10 и затем увеличивает значение age.number на 1. Данное значение хранится в памяти, поэтому console.log(age.number) возвращает 11.<br>\nКогда мы присваиваем flag значение true, console.log(getAge(true)) выполняет код "delete age.number", что удаляет свойство age.number. Это означает, что age.number = undefined. Однако, поскольку мы пытаемся увеличить значение на 1 с помощью оператора ++, возвращается NaN.\n</p>\n</article>\n</details>\n</section><section id="241"><h3>Вопрос № 241</h3>\n<pre><code class="lang-js">\nconst youtube = { name: "hoccoban" };\n\nconst copy = Object.create(youtube);\n\nconst cloneA = Object.assign({}, copy);\n\nconst cloneB = Object.assign({}, youtube);\n\nconsole.log(cloneA.name);\n\nconsole.log(cloneB.name);\n\nconsole.log(copy.name);\n</code></pre>\n<ul>\n<li>A: undefined - "hoccoban" - "hoccoban"</li><li>B: "hoccoban" - "hoccoban" - "hoccoban"</li><li>C: "hoccoban" - "hoccoban" - "undefined"</li><li>D: undefined - "undefined" - "hoccoban"</li>\n</ul>\n<details>\n<summary>Ответ</summary>\n<article>\n<h3 class="right-answer">Правильный ответ: A</h3>\n<p>\nСначала "console.log(cloneA.name)" выводит в консоль undefined, но почему? Мы используем Object.assign() для получения нового объекта из пустого объекта и объекта "copy". Объект "copy" является копией объекта "youtube", созданной с помощью Object.create(). Поскольку мы используем Object.create() объект "copy" наследует данные объекта "youtube", но сам остается пустым.<br>\nconsole.log(cloneB.name) и console.log(copy.name) выводят в консоль "hoccoban", поскольку "cloneB.name" имеет собственное свойство "name", а "copy.name" наследует свойство "name" объекта "youtube".\n</p>\n</article>\n</details>\n</section>\n<h1 id="bonus">Бонус</h1>\n\n<h3>Передача значений</h3>\n\n<section id="242"><h3>Вопрос № 242</h3>\n<pre><code class="lang-js">\nconst strA = \'Привет!\'\nlet strB = strA\nstrB = \'Пока!\'\nconsole.log(strA)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Привет!</p>\n</details>\n</section>\n\n\n<section id="243"><h3>Вопрос № 243</h3>\n<pre><code class="lang-js">\nconst objA ={ prop: 42 }\nlet objB = objA\nobjB.prop1 = 24\nconsole.log(objA)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>{ prop: 24}</p>\n</details>\n</section>\n\n<section id="244"><h3>Вопрос № 244</h3>\n<pre><code class="lang-js">\nconst objA = { prop: 42 }\nlet objB = objA\nobjB = {}\nconsole.log(objA)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>{ prop: 42 }</p>\n</details>\n</section>\n\n<section id="245"><h3>Вопрос № 245</h3>\n<pre><code class="lang-js">\nconst arrA = [0, 1, 2, 3, 4, 5]\nlet arrB = arrA\narrB[0] = 42\nconsole.log(arrA)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[42, 1, 2, 3, 4, 5]</p>\n</details>\n</section>\n\n<section id="246"><h3>Вопрос № 246</h3>\n<pre><code class="lang-js">\nconst arrA = [0, 1, 2, 3, 4, 5]\nlet arrB = arrA.slice()\narrB[0] = 42\nconsole.log(arrA)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[0, 1, 2, 3, 4, 5]</p>\n</details>\n</section>\n\n<section id="247"><h3>Вопрос № 247</h3>\n<pre><code class="lang-js">\nconst arrA = [ {prop1: \'элемент массива А\'} , {prop2: \'еще один элемент массива А\'}, 3, 4, 5 ]\nlet arrB = arrA\narrB[0].prop1 = 42\nconsole.log(arrA)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[ {prop1: 42} , {prop2: \'еще один элемент массива А\'}, 3, 4, 5 ]</p>\n</details>\n</section>\n\n<section id="248"><h3>Вопрос № 248</h3>\n<pre><code class="lang-js">\nconst arrA = [ {prop1: \'элемент массива А\'} , {prop2: \'еще один элемент массива А\'}, 3, 4, 5 ]\nlet arrB = arrA.slice()\narrB[0].prop1 = 42\narrB[3] = 24\nconsole.log(arrA)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[ {prop1: \'элемент массива А\'} , {prop2: \'еще один элемент массива А\'}, 3, 4, 5 ]</p>\n</details>\n</section>\n\n<h3>Поднятие переменных</h3>\n\n<section id="249"><h3>Вопрос № 249</h3>\n<pre><code class="lang-js">\nconsole.log(id)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>ReferenceError: id is not defined</p>\n</details>\n</section>\n\n<section id="250"><h3>Вопрос № 250</h3>\n<pre><code class="lang-js">\nconsole.log(id)\nvar id = \'123abc\'\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="251"><h3>Вопрос № 251</h3>\n<pre><code class="lang-js">\nvar id = \'123abc\'\n(function () {\n    console.log(id)\n    var id = \'321cba\'\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="252"><h3>Вопрос № 252</h3>\n<pre><code class="lang-js">\nvar id = \'123abc\'\n(function () {\n    console.log(id)\n    var id = \'321cba\'\n    (function () {\n        var id = \'abc123\'\n    })()\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="253"><h3>Вопрос № 253</h3>\n<pre><code class="lang-js">\n(function () {\n    console.log(typeof f)\n    var f = function () {\n        console.log(\'Привет, я нахожусь внутри f.\')\n    }\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="254"><h3>Вопрос № 254</h3>\n<pre><code class="lang-js">\nvar id = \'123abc\'\nfunction foo () {\n    id = \'abc123\'\n    return;\n}\nfoo()\nconsole.log(id)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>abc123</p>\n</details>\n</section>\n\n<section id="255"><h3>Вопрос № 255</h3>\n<pre><code class="lang-js">\nvar id = \'123abc\'\n\nfunction foo () {\n    id = \'abc123\'\n    return;\n\n    function id () {}\n}\nfoo()\nconsole.log(id)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>123abc</p>\n</details>\n</section>\n\n<section id="256"><h3>Вопрос № 256</h3>\n<pre><code class="lang-js">\nvar id = \'123abc\'\n\nfunction foo () {\n    id = \'abc123\'\n    return;\n\n    function id () {\n        console.log(typeof id)\n    }\n}\nfoo()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>function</p>\n</details>\n</section>\n\n<section id="257"><h3>Вопрос № 257</h3>\n<pre><code class="lang-js">\nfunction foo () {\n    id()\n    var product = \'Автомобиль\'\n    return;\n\n    function id () {\n        console.log(product)\n    }\n}\n\nfoo()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="258"><h3>Вопрос № 258</h3>\n<pre><code class="lang-js">\n(function foo () {\n    bar()\n\n    function bar () {\n        baz()\n        console.log(typeof baz)\n    }\n\n    function baz() {\n        console.log(typeof bar)\n    }\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>function function</p>\n</details>\n</section>\n\n<h3>Объекты</h3>\n\n<section id="259"><h3>Вопрос № 259</h3>\n<pre><code class="lang-js">\n(function () {\n    \'use strict\'\n\n    var person = {\n        name: \'Ванька\'\n    }\n    person.salary = \'100000\'\n    person[\'country\'] = \'Россия\'\n\n    Object.defineProperty(person, \'phone\', {\n        value: \'+123456789\',\n        enumerable: true\n    })\n\n    console.log(Object.keys(person))\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[ \'name\', \'salary\', \'country\', \'phone\' ]</p>\n</details>\n</section>\n\n<section id="260"><h3>Вопрос № 260</h3>\n<pre><code class="lang-js">\n(function () {\n    \'use strict\'\n\n    var person = {\n        name: \'Ванька\'\n    }\n    person.salary = \'100000\'\n    person[\'country\'] = \'Россия\'\n\n    Object.defineProperty(person, \'phone\', {\n        value: \'+123456789\',\n        enumerable: false\n    })\n\n    console.log(Object.keys(person))\n}())\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[ \'name\', \'salary\', \'country\' ]</p>\n</details>\n</section>\n\n<section id="261"><h3>Вопрос № 261</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const objA = {\n        foo: \'foo\',\n        bar: \'bar\'\n    }\n    const objB = {\n        foo: \'foo\',\n        bar: \'bar\'\n    }\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>false false</p>\n</details>\n</section>\n\n<section id="262"><h3>Вопрос № 262</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const objA = new Object({ foo: \'foo\' })\n    const objB = new Object({ foo: \'foo\' })\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>false false</p>\n</details>\n</section>\n\n<section id="263"><h3>Вопрос № 263</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const objA = Object.create({\n        foo: \'foo\'\n    })\n    const objB = Object.create({\n        foo: \'foo\'\n    })\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>false false</p>\n</details>\n</section>\n\n<section id="264"><h3>Вопрос № 264</h3>\n<pre><code class="lang-js">\n!function () {\n    const objA = Object.create({\n        foo: \'foo\'\n    })\n    const objB = Object.create(objA)\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n}()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>false false true</p>\n</details>\n</section>\n\n<section id="265"><h3>Вопрос № 265</h3>\n<pre><code class="lang-js">\n(function () {\n    const objA = Object.create({\n        foo: \'foo\'\n    })\n    const objB = Object.create(objA)\n\n    console.log(objA.toString() == objB.toString())\n    console.log(objA.toString() === objB.toString())\n}())\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>true true</p>\n</details>\n</section>\n\n<section id="266"><h3>Вопрос № 266</h3>\n<pre><code class="lang-js">\n+function () {\n    const objA = Object.create({\n        foo: \'foo\'\n    })\n    const objB = objA\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n\n    console.log(objA.toString() == objB.toString())\n    console.log(objA.toString() === objB.toString())\n}()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>true true true true NaN</p>\n</details>\n</section>\n\n<section id="267"><h3>Вопрос № 267</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const objA = Object.create({\n        foo: \'foo\'\n    })\n    const objB = objA\n\n    objB.foo = \'bar\'\n\n    console.log(objA.foo)\n    console.log(objB.foo)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>bar bar</p>\n</details>\n</section>\n\n<section id="268"><h3>Вопрос № 268</h3>\n<pre><code class="lang-js">\nnew function () {\n    const objA = Object.create({\n        foo: \'foo\'\n    })\n    const objB = objA\n\n    objB.foo = \'bar\'\n\n    delete objA.foo\n\n    console.log(objA.foo)\n    console.log(objB.foo)\n}\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>foo foo {}</p>\n</details>\n</section>\n\n<section id="269"><h3>Вопрос № 269</h3>\n<pre><code class="lang-js">\nnew function () {\n    const objA = {\n        foo: \'foo\'\n    }\n    const objB = objA\n\n    objB.foo = \'bar\'\n\n    delete objA.foo\n\n    console.log(objA.foo)\n    console.log(objB.foo)\n}()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined undefined {}</p>\n</details>\n</section>\n\n<h3>Массивы</h3>\n\n<section id="270"><h3>Вопрос № 270</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const array = new Array(\'100\')\n    console.log(array)\n    console.log(array.length)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[\'100\'] 1</p>\n</details>\n</section>\n\n<section id="271"><h3>Вопрос № 271</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const array1 = []\n    const array2 = new Array(100)\n    const array3 = new Array([\'1\', 2, \'3\', 4, 5.6])\n\n    console.log(\n        array1,\n        array2,\n        array3,\n        array3.length\n    )\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Зависит от браузера. В Chrome выводится следующее: [] (100)&nbsp;[empty × 100] [Array(5)] 1</p>\n</details>\n</section>\n\n<section id="272"><h3>Вопрос № 272</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const array = new Array(\'a\', \'b\', \'c\', \'d\', \'e\')\n    array[10] = \'f\'\n    delete array[10]\n    console.log(array.length)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>11</p>\n</details>\n</section>\n\n<section id="273"><h3>Вопрос № 273</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const animals = [\'корова\', \'лошадь\']\n\n    animals.push(\'кошка\')\n    animals.push(\'собака\', \'осел\', \'козел\')\n    console.log(animals.length)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>6</p>\n</details>\n</section>\n\n<section id="274"><h3>Вопрос № 274</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const animals = [\'корова\', \'лошадь\']\n\n    animals.push(\'кошка\')\n    animals.unshift(\'собака\', \'осел\', \'козел\')\n    console.log(animals)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>["собака", "осел", "козел", "корова", "лошадь", "кошка"]</p>\n</details>\n</section>\n\n<section id="275"><h3>Вопрос № 275</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const array = [1,2,3,4,5]\n\n    console.log(array.indexOf(2))\n\n    console.log([{ name: \'Ванька\' }, { name: \'Петька\' }].indexOf({ name: \'Ванька\' }))\n\n    console.log([[1],[2],[3],[4]].indexOf(2))\n\n    console.log(\'abcdef\'.indexOf(\'c\'))\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>1 -1 -1 2</p>\n</details>\n</section>\n\n<section id="276"><h3>Вопрос № 276</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const array = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6]\n\n    console.log(array.indexOf(2))\n    console.log(array.indexOf(2,3))\n    console.log(array.indexOf(2,10))\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>1 6 -1</p>\n</details>\n</section>\n\n<section id="277"><h3>Вопрос № 277</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const nums = [2, 3, 4, 8, 9, 11, 13, 12, 16]\n\n    const even = nums.filter((el, i) =&gt; el % 2 === 0)\n    console.log(even)\n\n    const divBy3 = nums.some((el, i) =&gt; el % 3 === 0)\n    console.log(divBy3)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[2, 4, 8, 12, 16] true</p>\n</details>\n</section>\n\n<section id="278"><h3>Вопрос № 278</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    var array = [2, 0, false, \'\', \'12\', true]\n\n    var array = array.filter(Boolean)\n    console.log(array)\n\n    var array = array.filter(Number)\n    console.log(array)\n\n    var array = array.filter(String)\n    console.log(array)\n\n    var array = array.filter(Object)\n    console.log(array)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[2,\'12\',true] <br>\n[2,\'12\',true] <br>\n[2,\'12\',true] <br>\n[2,\'12\',true]</p>\n</details>\n</section>\n\n<section id="279"><h3>Вопрос № 279</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const list = [\'foo\', \'bar\', \'baz\', \'qux\']\n\n    console.log(`\n    &#36;{list.slice(1)}\n\n    &#36;{list.slice(1,3)}\n\n    &#36;{list.slice()}\n\n    &#36;{list.slice(2,2)}\n\n    &#36;{list}\n    `)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>\nbar, baz, qux <br>\nbar, baz <br>\nfoo, bar, baz, qux <br>\n(пусто) <br>\nfoo, bar, baz, qux <br>\n</p>\n</details>\n</section>\n\n<section id="280"><h3>Вопрос № 280</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const list = [\'foo\', \'bar\', \'baz\']\n\n    console.log(`\n    &#36;{list.splice(1)}\n\n    &#36;{list.slice(1,2)}\n\n    &#36;{list}\n    `)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>\nbar, baz <br>\n(пусто) <br>\nfoo <br>\n</p>\n</details>\n</section>\n\n<section id="281"><h3>Вопрос № 281</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const nums = [2, 8, 15, 16, 23, 42]\n    nums.sort().reverse()\n    console.log(nums)\n\n    nums.reverse().sort((x, y) =&gt; x - y)\n    console.log(nums)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>\n[8, 42, 23, 2, 16, 15]\n[2, 8, 15, 16, 23, 42]\n</p>\n</details>\n</section>\n\n<h3>Функции</h3>\n\n<section id="282"><h3>Вопрос № 282</h3>\n<pre><code class="lang-js">\nfunction f1 () {\n    console.log(\'f1\', this)\n    ;(function f2 () {\n        console.log(\'f2\', this)\n        ;(function f3 () {\n            console.log(\'f3\', this)\n        })()\n    })()\n}\n\nf1()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>\nf1 Window&nbsp;{…} <br>\nf2 Window&nbsp;{…} <br>\nf3 Window&nbsp;{…}\n</p>\n</details>\n</section>\n\n<section id="283"><h3>Вопрос № 283</h3>\n<pre><code class="lang-js">\nconst obj = {\n    message: \'Привет!\',\n    innerMessage: !(() =&gt; {\n        console.log(this.message)\n    })()\n}\n\nobj.innerMessage()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined true</p>\n</details>\n</section>\n\n<section id="284"><h3>Вопрос № 284</h3>\n<pre><code class="lang-js">\nconst obj = {\n    message: \'Привет!\',\n    innerMessage: function () {\n        console.log(this.message)\n    }\n}\n\nconsole.log(obj.innerMessage())\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Привет!</p>\n</details>\n</section>\n\n<section id="285"><h3>Вопрос № 285</h3>\n<pre><code class="lang-js">\nconst obj = {\n    message: \'Привет!\',\n    innerMessage: () =&gt; {\n        (() =&gt; {\n            console.log(this.message)\n        })()\n    }\n}\nobj.innerMessage()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="286"><h3>Вопрос № 286</h3>\n<pre><code class="lang-js">\nconst obj = {\n    message: \'Привет!\',\n    innerMessage: function () {\n        const self = this\n        ;(function () {\n            console.log(self.message)\n        })()\n    }\n}\nobj.innerMessage()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Привет!</p>\n</details>\n</section>\n\n<section id="287"><h3>Вопрос № 287</h3>\n<pre><code class="lang-js">\nfunction f () {\n    console.log(this.message)\n}\nf.message = \'Привет!\'\n\nf()\nf.call(f)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined Привет!</p>\n</details>\n</section>\n\n<section id="288"><h3>Вопрос № 288</h3>\n<pre><code class="lang-js">\nfunction f () {\n    console.log(f.message)\n}\nf.message = \'Привет!\'\n\nf()\nf.bind(f)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Привет! f () {...}</p>\n</details>\n</section>\n\n<section id="289"><h3>Вопрос № 289</h3>\n<pre><code class="lang-js">\nfunction f1 () {\n    f1.message = \'Привет!\'\n    console.log(f1.message)\n}\nfunction f2 () {\n    f2.message = \'Пока!\'\n}\nf1()\nf1.bind(f2)()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Привет! Привет!</p>\n</details>\n</section>\n\n<section id="290"><h3>Вопрос № 290</h3>\n<pre><code class="lang-js">\nfunction f1 (par1, par2) {\n    console.log(arguments.length)\n    console.log(arguments)\n}\nfunction f2 (...rest) {\n    console.log(rest.length)\n    console.log(rest)\n}\n\nf1()\nf1(1, 2)\nf1(1, 2, 3, 4)\n\nf2()\nf2(1, 2)\nf2(1, 2, 3, 4)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>\n2 [] 2 [1, 2] 2 [1, 2, 3, 4] <br>\n0 [] 0 [1, 2] 0 [1, 2, 3, 4]\n</p>\n</details>\n</section>\n\n<section id="291"><h3>Вопрос № 291</h3>\n<pre><code class="lang-js">\nfunction f1 (par1, par2) {\n    console.log(arguments.length)\n}\nfunction f2 (...rest) {\n    console.log(rest.length)\n}\n\nf1()\nf1(1,2)\nf1(1,2,3,4)\n\nf2()\nf2(1,2)\nf2(1,2,3,4)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>\n0 2 4\n0 2 4\n</p>\n</details>\n</section>\n\n<h3>Область видимости</h3>\n\n<section id="292"><h3>Вопрос № 292</h3>\n<pre><code class="lang-js">\nfunction f () {\n    const password = \'12345\'\n    this.name = \'Ванька\'\n    return {\n        pwd: password\n    }\n}\nconst info = f()\nconsole.log(info.pwd)\nconsole.log(info.name)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>12345 undefined</p>\n</details>\n</section>\n\n<section id="293"><h3>Вопрос № 293</h3>\n<pre><code class="lang-js">\nconst id = \'123abc\'\nfunction F () {\n    this.id = \'abc123\'\n}\nconsole.log(F.id)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="294"><h3>Вопрос № 294</h3>\n<pre><code class="lang-js">\nconst foo = \'foo\'\nfunction F () {\n    this.foo = \'bar\'\n}\nconsole.log(new F().foo)\n\nF.prototype.foo = \'baz\'\nF.prototype.bar = \'qux\'\nconsole.log(new F().bar)\nconsole.log(new F().foo)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>bar qux bar</p>\n</details>\n</section>\n\n<section id="295"><h3>Вопрос № 295</h3>\n<pre><code class="lang-js">\nconst foo = \'foo\'\n;(function F () {\n    try {\n        throw \'bar\'\n    } catch (foo) {\n        console.log(foo)\n    }\n    console.log(foo)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>bar foo</p>\n</details>\n</section>\n\n<h3>Call, Apply, Bind</h3>\n\n<section id="296"><h3>Вопрос № 296</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const greet = \'Привет, народ!\'\n    const toGreet = [].filter.call(greet, (el, i) =&gt; i &lt; 6)\n    console.log(toGreet)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>["П", "р", "и", "в", "е", "т"]</p>\n</details>\n</section>\n\n<section id="297"><h3>Вопрос № 297</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const foo = {\n        name: \'foo\',\n        amount: 4000,\n        deduct: function (amount) {\n            this.amount -= amount\n            return `Осталось &#36;{this.amount}`\n        }\n    }\n\n    const bar = {\n        name: \'bar\',\n        amount: 6000\n    }\n\n    const amountBy = total =&gt;\n        foo.deduct.bind(bar, total)\n\n    console.log(amountBy(1000)())\n    console.log(amountBy(2000)())\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Осталось 5000 Осталось 3000</p>\n</details>\n</section>\n\n<section id="298"><h3>Вопрос № 298</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const foo = {\n        name: \'foo\',\n        amount: 4000,\n        deduct: function (amount) {\n            this.amount -= amount\n            return `Осталось &#36;{this.amount}`\n        }\n    }\n\n    const bar = {\n        name: \'bar\',\n        amount: 6000\n    }\n\n    const amountBy = total =&gt;\n        foo.deduct.apply(bar, [total])\n\n    console.log(amountBy(1000))\n    console.log(amountBy(2000))\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Осталось 5000 Осталось 3000</p>\n</details>\n</section>\n\n<section id="299"><h3>Вопрос № 299</h3>\n<pre><code class="lang-js">\nconst user1 = (name = \'Ванька\', age = 24) =&gt; ({\n    name,\n    age,\n    getInfo() {\n        console.log(`&#36;{this.name} &#36;{this.age}`)\n    }\n})\n\nconst user2 = (name = \'Петька\', age = 42) =&gt; ({name, age})\n\nuser1().getInfo()\nuser1().getInfo.bind(user2())()\nuser1().getInfo.call(user2(\'Васька\', 30))\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Ванька 24 <br>\nПетька 42 <br>\nВаська 30</p>\n</details>\n</section>\n\n<section id="300"><h3>Вопрос № 300</h3>\n<pre><code class="lang-js">\n(function () {\n    console.log(`Привет, &#36;{this.name}!`)\n}.bind({\n    name: \'Ванька\'\n}))()\n\n;(function () {\n    console.log(`Пока, &#36;{this.name}!`)\n}).call({\n    name: \'Петька\'\n})\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Привет, Ванька! <br>\nПока, Петька!</p>\n</details>\n</section>\n\n<h3>Колбэк</h3>\n\n<section id="301"><h3>Вопрос № 301</h3>\n<pre><code class="lang-js">\nfunction getData () {\n    const name = \'Ванька\'\n    return {\n        then: function (f) {\n            f(name)\n        }\n    }\n}\n\ngetData().then(name =&gt; console.log(name))\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Ванька</p>\n</details>\n</section>\n\n<section id="302"><h3>Вопрос № 302</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    const nums = [2, 8, 15, 16, 23, 42]\n    Array.prototype.sort = (a, b) =&gt; a - b\n    nums.sort()\n    console.log(nums)\n})()\n\n;(() =&gt; {\n    const nums = [2, 8, 15, 16, 23, 42]\n    nums.sort((a, b) =&gt; {\n        (a === b)\n            ? 0\n            : a &lt; b ? -1 : 1\n    })\n    console.log(nums)\n})()\n\n;(() =&gt; {\n    const nums = [2, 8, 15, 16, 23, 42]\n    nums.sort((a, b) =&gt; b - a)\n    console.log(nums)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>[ 2, 8, 15, 16, 23, 42 ] <br>\n[ 2, 8, 15, 16, 23, 42 ] <br>\n[ 2, 8, 15, 16, 23, 42 ]</p>\n</details>\n</section>\n\n<h3>Return</h3>\n\n<section id="303"><h3>Вопрос № 303</h3>\n<pre><code class="lang-js">\n(() =&gt; {\n    function hello () {\n        const name = \'Ванька\'\n        return\n        {\n            greet: `Привет, &#36;{name}!`\n        }\n    }\n    console.log(hello().greet)\n})()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>TypeError: Cannot read property \'greet\' of undefined</p>\n</details>\n</section>\n\n<section id="304"><h3>Вопрос № 304</h3>\n<pre><code class="lang-js">\nfunction getNums () {\n    return (2, 3, 4)\n}\nconst nums = getNums()\nconsole.log(nums)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>4</p>\n</details>\n</section>\n\n<section id="305"><h3>Вопрос № 305</h3>\n<pre><code class="lang-js">\nfunction getNum () {\n    return\n}\nconst num = getNum()\nconsole.log(num)\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>undefined</p>\n</details>\n</section>\n\n<section id="306"><h3>Вопрос № 306</h3>\n<pre><code class="lang-js">\nfunction mult(x) {\n    return function (y) {\n        return [x * y, function (z) {\n            return x * y + z\n        }]\n    }\n}\nconsole.log(mult(2)(3)[0])\nconsole.log(mult(2)(3)[1](4))\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>6 10</p>\n</details>\n</section>\n\n<section id="307"><h3>Вопрос № 307</h3>\n<pre><code class="lang-js">\nfunction mult(x) {\n    return function (y) {\n        return {\n            result: x * y,\n            add: function (z) {\n                return x * y + z\n            }\n        }\n    }\n}\nconsole.log(mult(2)(3).result)\nconsole.log(mult(2)(3).add(4))\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>6 10</p>\n</details>\n</section>\n\n<section id="308"><h3>Вопрос № 308</h3>\n<pre><code class="lang-js">\nconst calc = a =&gt; b =&gt; c =&gt; d =&gt; {\n    switch (d) {\n        case \'*\': return a * b * c\n        case \'/\': return a / b / c\n        case \'+\': return a + b + c\n        case \'-\': return a - b - c\n        default: return \'Некорректная операция!\'\n    }\n}\n\nconsole.log(calc(1)(2)(3)(\'*\'))\nconsole.log(calc(2)(3)(4)(\'+\'))\nconsole.log(calc(6)(3)(1)(\'-\'))\nconsole.log(calc(6)(3)(2)(\'x\'))\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>6 9 2 Некорректная операция!</p>\n</details>\n</section>\n\n<section id="309"><h3>Вопрос № 309</h3>\n<pre><code class="lang-js">\nfunction getName1() {\n    console.log(this.name)\n}\n\nObject.prototype.getName2 = () =&gt; console.log(this.name)\n\nconst person = {\n    name: \'Ванька\',\n    displayName: getName1\n}\n\nperson.displayName()\nperson.getName2()\n</code></pre>\n<details>\n<summary>Ответ</summary>\n<p>Ванька undefined</p>\n</details>\n</section>\n';